% \iffalse meta-comment
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% prooftrees.dtx
% Additions and changes Copyright (C) 2016-2025 Clea F. Rees.
% Code from skeleton.dtx Copyright (C) 2015-2024 Scott Pakin (see below).
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3c
% of this license or (at your option) any later version.
% The latest version of this license is in
%   https://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX
% version 2008-05-04 or later.
%
% This work has the LPPL maintenance status 'muaintained'.
%
% The Current Maintainer of this work is Clea F. Rees.
%
% This work consists of all files listed in manifest.txt.
%
% The file prooftrees.dtx is a derived work under the terms of the
% LPPL. It is based on version 2.4 of skeleton.dtx which is part of
% dtxtut by Scott Pakin. A copy of dtxtut, including the
% unmodified version of skeleton.dtx is available from
% https://www.ctan.org/pkg/dtxtut and released under the LPPL.
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% arara: pdflatex: { synctex: true, shell: false }
% arara: biber
% arara: makeindex 
% arara: pdflatex: { synctex: true, shell: false }
% arara: pdflatex: { synctex: true, shell: false }
% biber --output_format=bibtex --output_resolve prooftrees.bcf to generate .bib for upload
% sed -i '/1977/s/DATE/YEAR'
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% \fi
%
% \iffalse
%<*driver>
\RequirePackage{svn-prov}
% ^^A ref. ateb Max Chernoff: https://tex.stackexchange.com/a/723294/
% ^^A \def\MakePrivateLetters{\makeatletter\ExplSyntaxOn\endlinechar13}
% ^^A \ExplSyntaxOff
\ProvidesFileSVN{$Id: prooftrees.dtx 11204 2025-09-04 03:23:15Z cfrees $}[v0.9.1 \revinfo][\filebase DTX: ]
\DefineFileInfoSVN[prooftreesdoc]
\GetFileInfoSVN*
\let\prooftreesdocversion\fileversion
\let\prooftreesdocrev\filerev
\let\prooftreesdocbase\filebase
\let\prooftreesdocinfo\fileinfo
\let\prooftreesdocdate\filedate
\let\prooftreesdocname\filename
%^^A BEGIN preamble <<<
\documentclass[10pt,british,a4paper,doc2]{ltxdoc}
\usepackage[extract=python]{memoize}
\mmzset{%
  prefix={memos/},
  include context in ccmemo,
  auto=\cref{multiref},
  auto=\Cref{multiref},
  auto=\labelcref{multiref},
  auto=\cpageref{multiref},
  auto=\labelcpageref{multiref},
  auto=\namecref{ref},
  auto=\nameCref{ref},
  auto=\namecrefs{ref},
  auto=\nameCrefs{ref},
  auto=\lcnamecrefs{ref},
  auto=\lcnamecrefs{ref},
  auto=\crefrange{refrange},
  auto=\cpagerefrange{refrange},
  auto=\Cpagerefrange{refrange},
  mkdir,
}
\CodelineIndex
\RecordChanges
\EnableCrossrefs
\usepackage{babel,geometry,fancyhdr,enumitem}
\usepackage{csquotes}
  \MakeAutoQuote{‘}{’}
  \MakeAutoQuote*{“}{”}
\usepackage[rm={lining},sf={lining},tt={tabular,lining,monowidth}]{cfr-lm}
\usepackage{microtype}
\usepackage[section]{placeins}
\usepackage[citestyle=authoryear-comp,bibstyle=authoryear,mergedate=basic,isbn=false,url=true,sortcites=true,backend=biber,mincrossrefs=6]{biblatex}
% ^^A \bibliography{abbrv, authors, journals-series, pub, lleoedd, phil, ref}
\bibliography{prooftrees_biber.bib}% generate for upload (gweler uchod)
\usepackage{etoolbox,verbatim,parskip,changepage,titling,makeidx}
\usepackage[dvipsnames,svgnames,rgb,x11names]{xcolor}
\usepackage[tableaux]{prooftrees}
\GetFileInfoSVN{prooftrees}
\let\prooftreesversion\fileversion
\let\prooftreesrev\filerev
\let\prooftreesbase\filebase
\let\prooftreesinfo\fileinfo
\let\prooftreesdate\filedate
\let\prooftreesname\filename
\usepackage{mathtools,turnstile,pifont}
\newcommand*{\fycheck}{\text{\ding{52}}}
\newcommand*{\fycross}{\text{\ding{56}}}
\usetikzlibrary{decorations.pathreplacing,arrows.meta,positioning,calc,arrows.meta,fit,backgrounds,tikzmark}
\tikzset{%
  nodiad/.style={text=#1, draw=#1, font=\footnotesize\scshape, align=left, shorten >=-1.5pt, shorten <=-1.5pt, {Circle[width=3pt, length=3pt, fill=#1]}-{Circle[width=3pt, length=3pt, fill=#1]}, fill=none},
  grwp/.style={fill opacity=.25, fill=#1, rounded corners, draw=#1},
  post grwp/.style={fill=white, postaction={fill opacity=.25, fill=#1}, draw=#1, rounded corners},
}
\forestset{%
  nyth/.style n args=3{%
    tikz+={%
      \pgfmathsetmacro\lliw{#2*100/14}
      \scoped[on background layer]\node [fit=(.west) (.east) (!F) (!L) (!1) (!11) (!l) (!ll) #1 (#3#2.center), inner xsep=28-2*#2 pt, inner ysep=0pt, draw=WildStrawberry!\lliw!blue, rounded corners] {};
    },
  },
}
\usepackage{tcolorbox}
\tcbuselibrary{listingsutf8}% ^^A if you use skins, you need to disable externalisation for boxes which use the relevant options - gweler nodiadau/tex/tex.se/tcolorbox-coursepacket-exp.tex
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% ^^A Sašo Živanović: https://github.com/sasozivanovic/memoize/issues/31#issuecomment-2424700001
\csappto{tcb@shield@@externalize}{\ifdefined\memoizefalse\memoizefalse\fi}
\tcbset{shield externalize}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\let\docenvironment\environment
\let\enddocenvironment\endenvironment
\let\docmacrocode\macrocode
\let\enddocmacrocode\endmacrocode
\let\docmacro\macro
\let\enddocmacro\endmacro
\usepackage[%^^A 
  loadHyperref=true,
  createIndexEntries=false,
]{doctools}
\usepackage{hypdoc}%^^A ateb Ulrike Fischer: https://tex.stackexchange.com/a/695555/
\usepackage{bookmark}
\hypersetup{%^^A 
  colorlinks=true,
  citecolor={moss},
  extension=pdf,
  linkcolor={strawberry},
  linktocpage=true,
  pdfcreator={TeX},
  pdfproducer={pdfeTeX},
  urlcolor={blueberry},
}
\usepackage{cleveref}
\makeatletter
% ^^A Joseph Wright: from \file{siunitx.sty} ; \url{https://chat.stackexchange.com/transcript/message/64327823#64327823}
\providecommand\IfFormatAtLeastTF{\@ifl@t@r\fmtversion}
% ^^A  \IfFormatAtLeastTF {2024-11-01}
% ^^A  {% ^^A ateb sgwrsio Ulrike Fischer: https://chat.stackexchange.com/transcript/message/66562343#66562343
% ^^A    \NewSocketPlug{refstepcounter}{cleveref}{%
% ^^A      \ifHy@pdfstring\else#1
% ^^A        {%
% ^^A          \firstaid@cref@updatelabeldata{\@currentcounter}%
% ^^A        }%
% ^^A      \fi
% ^^A    }%
% ^^A    \AssignSocketPlug{refstepcounter}{cleveref}%
% ^^A  }{}
\renewcommand*\Describe@Macro[1]{\endgroup
  \marginpar{%^^A 
    \raggedleft\PrintDescribeMacro{#1}\par
    \PrintLabelName[\macrolabelfont]{\macrolabelname}%^^A 
  }%^^A 
  \expandafter\prooftrees@index{\macrolabelname}{\protect\ttfamily\protect\string\protect#1}\@esphack\ignorespaces}
\renewcommand*\Describe@Env[1]{\endgroup
  \marginpar{%^^A 
    \raggedleft\PrintDescribeMacro{#1}\par
    \PrintLabelName[\macrolabelfont]{\envlabelname}%^^A 
  }%^^A 
  \expandafter\prooftrees@index{\envlabelname}{#1}\@esphack\ignorespaces}
\newcommand*\DescribeKey{\leavevmode\@bsphack
  \begingroup\MakePrivateLetters\Describe@Key}
\newcommand*\Describe@Key[2][key]{\endgroup
  \marginpar{%^^A 
    \raggedleft\PrintDescribeMacro{#2}\par
    \PrintLabelName[\macrolabelfont]{\csname #1labelname\endcsname}%^^A 
  }%^^A 
  \edef\tempa{\csname #1labelname\endcsname}%^^A 
  \expandafter\prooftrees@index{\tempa}{#2}\@esphack\ignorespaces}
\newcommand*\DescribeKeys{\leavevmode\@bsphack
  \begingroup\MakePrivateLetters\Describe@Keys}
\expandafter\newif\csname ifcyntafun\endcsname
\newcommand*\Describe@Keys[2][key]{\endgroup
  \renewcommand*\do[1]{\ifcyntafun ##1\else\\##1\fi\cyntafunfalse}%^^A 
  \cyntafuntrue
  \marginpar{%^^A
    \raggedleft\PrintDescribeMacro{ %^^A paid â dileu'r gwagle hwn!!
      \expandafter\docsvlist{#2}%^^A
    }\par
    \PrintLabelName[\macrolabelfont]{\csname #1labelname\endcsname}%^^A 
  }%^^A
  \edef\tempa{\csname #1labelname\endcsname}%^^A
  \renewcommand*\do[1]{\expandafter\prooftrees@index{\tempa}{##1}}%^^A
  \expandafter\docsvlist{#2}\@esphack\ignorespaces}
\def\get@first#1,#2\@null{#1}
\def\get@rest#1,#2\@null{#2}
\newcommand*\vals[1]{%^^A 
  \edef\tempa{\expandafter\get@first #1\@null}%^^A 
  \edef\tempb{\expandafter\get@rest #1\@null}%^^A 
  \renewcommand*\do[1]{\textbar ##1}%^^A 
  {\ttfamily = \tempa
    \expandafter\docsvlist{\tempb}%^^A 
  }%^^A 
}
\newcommand*\val[1]{{\ttfamily = \meta{#1}}}
\newcommand*\valmarg[1]{{\ttfamily = \marg{#1}}}
\newcommand*\pkg[1]{\textsf{#1}}
\DeclareRobustCommand\macrolabelfont{\normalfont\footnotesize\em\normalcolor}
\ExplSyntaxOn
\cs_new_nopar:Npn \prooftreesdoc_new_label:nnn #1#2#3
{
  \cs_new_nopar:cpn {#1labelname} {#2}
  \cs_new_nopar:cpn {#1shortname} {#3}
}
\cs_new_nopar:Npn \__prooftreesdo_new_forest_label:nn #1#2
{
  \prooftreesdoc_new_label:nnn {#1}{Forest~#2}{#2}
}
\seq_set_split:Nnn \l_tmpa_seq {,}
{
  fkeylist,
  fregkeylist,
  foptkeylist,
  freg,
  fopt,
  fregdim,
  fregcount,
  fregtoks,
  fopttoks,
  fregbool,
  foptbool,
  fregautotoks,
  foptautotoks,
  fstyle,
  fstylewrap,
  fbracketkey,
  flstep,
  fsstep,
  fstep,
}
\seq_set_split:Nnn \l_tmpb_seq {,}
{
  keylist,
  keylist~register,
  keylist~option,
  register,
  option,
  dimension~register,
  count~register,
  toks~register,
  toks~option,
  boolean~register,
  boolean~option,
  autowrapped~toks~register,
  autowrapped~toks~option,
  style,
  wrapped~style,
  bracket~key,
  long~step,
  short~step,
  step,
}
\seq_map_pairwise_function:NNN \l_tmpa_seq \l_tmpb_seq \__prooftreesdo_new_forest_label:nn
\ExplSyntaxOff
\newcommand*\macrolabelname{macro}
\newcommand*\PrintLabelName[2][\normalfont\normalsize\normalcolor]{#1#2}
\newcommand*\envlabelname{environment}
\newcommand*\keylabelname{key}
\newcommand*\pkgoptlabelname{package option}
\newcommand*\pkglabelname{package}
\let\PrintDescribeKey\PrintDescribeMacro
\newcommand*\keyval[1]{\texttt{#1}}
\NewDocumentCommand\keyname { s O {key} m }{%^^A 
  \texttt{#3}%^^A 
  \IfBooleanTF {#1}{}{%^^A 
    \edef\tempa{\csname #2labelname\endcsname}%^^A 
    \expandafter\prooftrees@index{\tempa}{#3}%^^A 
  }%^^A 
}
\def\prooftrees@index#1#2{%^^A 
  \index{#1s\actualchar\doctools@indexHeadFont{#1s}\levelchar #2}%^^A 
}
\renewenvironment{theindex}
{%^^A 
  \twocolumn[\section*{\indexname}
    \emph{%^^A 
      Features are sorted by kind.
      Page references are given for both definitions and comments on use.
      Underlined numbers refer to code line numbers; the remainder to pages.%
    }\bigskip
  ]%^^A 
  \markboth{\indexname}%^^A 
  {\indexname}%^^A 
  \pagestyle{fancyplain}%^^A 
  \thispagestyle{plain}%^^A 
  \parindent\z@
  \parskip\z@ \@plus .3\p@\relax
  \let\item\@idxitem}
{}
\makeatother
\lstdefinestyle{lstcoeden}{%^^A modified from style used by doctools.sty for the latexcode environment
  style=lstDocStyleBase,
  numbers=none,
  stringstyle=\color{doc@stringcolor},
  keywordstyle=\color{doc@keywordcolor},
  commentstyle=\color{doc@commentcolor},
  frame=none,
}
\lstdefinestyle{lstsrc}{%^^A
  style=lstDemoStyleLaTeXCode,
  stringstyle=\color{doc@stringcolor},
  keywordstyle=\color{doc@keywordcolor},
  commentstyle=\color{doc@commentcolor},
  texcsstyle=\color{doc@keywordcolor},
  frame=none,
  numbers=left,
  moretexcs={forestset,linenumberstyle,ifcsname,ProcessOptions,DeclareOption,ProvidesPackageSVN,bracketset,NewDocumentEnvironment,ExplSyntaxOn,mmzset,ExplSyntaxOff,forest,prooftrees@enw,foresteregister,foresteoption,forestregister,forestoption,PackageError,PackageWarning,PassOptionsToPackage,CurrentOption,@ifpackageloaded,endforest,draw},
}
\geometry{headheight=12pt,marginparwidth=45mm,hmarginratio=4:1,vscale=.8,hscale=.7,verbose}
\newlength\tewadjust
\setlength\tewadjust{\marginparwidth+\marginparsep-\paperwidth+\textwidth+\oddsidemargin+1in}
\tcbset{%^^A
  coeden/.style={
    colback=doc@demo@backcolor,
    colframe=doc@rulecolor,
    halign=center,
    fonttitle=\sffamily\plstyle\bfseries,
    sharpish corners,
    list entry={\protect\numberline{\thetcbcounter\textbar}#1},
    title={\fbox{\plstyle\thetcbcounter}\hskip 1.5em #1},
    float,
    floatplacement={!tbp},
  },
  coeden dew/.style={
    coeden=#1,
    grow to left by=\tewadjust,
  },
  cod coeden/.style={
    coeden=#1,
    listing style=lstcoeden,
  },
  cod coeden dew/.style={
    cod coeden=#1,
    grow to left by=\tewadjust,
  },
  every float=\centering,
}
\NewTColorBox[auto counter, crefname={box}{boxes}, Crefname={Box}{Boxes},]{coeden}{s O {} m }
{%^^A
  IfBooleanTF={#1}{coeden dew=#3}{coeden=#3},
  #2,
}
\NewTCBListing[use counter from=coeden, crefname={box}{boxes}, Crefname={Box}{Boxes}]{codcoeden}{ s O {} m }
{%^^A
  IfBooleanTF={#1}{cod coeden dew=#3}{cod coeden=#3},
  listing side text,
  halign lower=center,
  #2,
}
\NewTCBListing[use counter from=coeden, crefname={box}{boxes}, Crefname={Box}{Boxes}]{codcoedenhir}{ s O {} m }
{%^^A
  IfBooleanTF={#1}{cod coeden dew=#3}{cod coeden=#3},
  listing above text,
  halign lower=center,
  #2,
}
\newcommand*{\tnot}{\ensuremath{\mathord{\sim}}}
\newcommand*{\lif}{\ensuremath{\mathbin{\rightarrow}}}
\newcommand*{\liff}{\ensuremath{\mathbin{\leftrightarrow}}}
\DeclareMathSymbol{\aand}{\mathbin}{operators}{38}
\newcommand*\TikZ{Ti\emph{k}Z}
\newcommand*{\elim}{\,\text{E}}
\newcommand*\wff{\emph{wff}}
\newcommand*\wffs{\emph{wffs}}
\newcounter{lliw}
\setcounter{lliw}{0}
\newcounter{rhiflliwnyth}
\setcounter{rhiflliwnyth}{0}
\def\rhiflliw{14}
\colorlet{fylliw}{WildStrawberry!\rhiflliw!blue}
\NewDocumentCommand\nyth { s o }{%^^A 
  \IfBooleanTF {#1}{%^^A 
    \stepcounter{lliw}%^^A 
  }{}%^^A 
  \IfValueTF {#2}{%^^A 
    \setcounter{rhiflliwnyth}{#2}%^^A 
  }{%^^A 
    \setcounter{rhiflliwnyth}{\value{lliw}}%^^A 
  }%^^A 
  \pgfmathsetmacro\rhiflliw{int(\value{rhiflliwnyth}*100/14)}%^^A 
  \colorlet{fylliw}{WildStrawberry!\rhiflliw!blue}%^^A 
  \tikz[baseline=(a.base),/mmz/csname meaning to context={c@rhiflliwnyth},/mmz/meaning to context=\rhiflliw]{%^^A 
    \node (a) [circle, fill=fylliw, inner sep=0pt, font=\sffamily, text width=12pt, text depth=0pt, text centered, text=white] {\arabic{rhiflliwnyth}};
  }%^^A 
}
\NewDocumentCommand\bocsnyth { O {} }{%^^A 
  \tikz[baseline=(a.base)]{\node (a) [rounded corners, draw=fylliw, text width=15pt, text height=10pt, inner sep=0pt] {#1};
  }%^^A 
}
\renewcommand\maketitlehookb{%^^A 
  \begin{center}
    Version \prooftreesdocversion{} 
  \end{center}%^^A 
}
\appto\mmzAtEndMemoization{%^^A
  \xtoksapp\mmzCMemo{\string^\string^A}%^^A
}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ExplSyntaxOn
\keys_define:nn { prooftrees / doc }
{
  unknown .code:n = {
    \cs_if_free:cT { \l_keys_key_str }
    {
      \tl_gset:cn { \l_keys_key_str } { #1 }
    }
  },
}
\NewDocumentCommand \prooftreesdocset { +m }
{
  \keys_set:nn { prooftrees / doc } { #1 }
}
\ExplSyntaxOff
\prooftreesdocset{%^^A
  bug={\href{https://codeberg.org/cfr/prooftrees/issues}{\textsc{bugtracker}}},
  codeberg={\href{https://codeberg.org/cfr/prooftrees}{\textsc{codeberg}}},
  github={\href{https://github.com/cfr42/prooftrees}{\textsc{github}}},
  ctan={\href{https://ctan.org/}{\textsc{ctan}}},
}
\title{\filebase}
\author{Clea F. Rees\thanks{%^^A 
    Bug tracker:
    \href{https://codeberg.org/cfr/prooftrees/issues}{\url{codeberg.org/cfr/prooftrees/issues}}
    \textbar{} Code:
    \href{https://codeberg.org/cfr/prooftrees}{\url{codeberg.org/cfr/prooftrees}}
    \textbar{} Mirror:
    \href{https://github.com/cfr42/prooftrees}{\url{github.com/cfr42/prooftrees}}%^^A 
}}
\date{\prooftreesdocdate}
\title{\prooftreesdocbase}
\ExplSyntaxOn
\hook_gput_code:nnn {shipout/lastpage} {.}
{
  \property_record:nn {t:lastpage}{abspage,page,pagenum}
}
\cs_new_protected_nopar:Npn \lastpage 
{
  \property_ref:nn {t:lastpage}{page}
}
\cs_new:Npn \__prooftreesdoc_mpl: {
  \char_set_catcode_letter:N \@\char_set_catcode_letter:N \_\char_set_catcode_letter:N \:
}
\cs_set_eq:NN \MakePrivateLetters \__prooftreesdoc_mpl:
\cs_new_eq:NN \__prooftreesdoc_cs_orig:n \cs
\cs_new_protected:Npn \__prooftreesdoc_cs_expl:n #1
{
  \exp_args:Ne \__prooftreesdoc_cs_orig:n {\tl_to_str:n {#1}}
}
\cs_new_eq:NN \ecs \__prooftreesdoc_cs_expl:n
\ExplSyntaxOff
% ^^A % ^^A if these are commented where the f*** are they defined?
% ^^A % ^^A \definecolor{strawberry}{rgb}{1.000,0.000,0.502}
% ^^A % ^^A \definecolor{blueberry}{rgb}{0.000,0.000,1.000}
% ^^A % ^^A \definecolor{moss}{rgb}{0.000,0.502,0.251}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagestyle{fancy}
\fancyhf{}
\fancyhf[lh]{\textit{\leftmark}}
\fancyhf[rh]{\textit{\rightmark}}
\fancyhf[cf]{\textit{--- \thepage{} of \lastpage{} ---}}
\fancypagestyle{fancyplain}{%^^A
  \fancyhf{}%^^A
  \fancyhf[lh]{\textit{\leftmark}}%^^A
  \renewcommand*\headrulewidth{0pt}%^^A
  \fancyhf[cf]{\textit{--- \thepage{} of \lastpage{} ---}}}
\fancypagestyle{plain}{%^^A
  \fancyhf{}%^^A
  \renewcommand*\headrulewidth{0pt}%^^A
  \fancyhf[cf]{\textit{--- \thepage{} of \lastpage{} ---}}}
\patchcmd{\sectionmark}{\MakeUppercase}{}{\typeout{sectionmark patched OK!}}{\typeout{sectionmark patch failed!}}
\patchcmd{\tableofcontents}{\MakeUppercase}{}{\typeout{sectionmark patched OK!}}{\typeout{tableofcontents patch failed!}}
\patchcmd{\tableofcontents}{\MakeUppercase\contentsname}{}{\typeout{sectionmark patched OK!}}{\typeout{tableofcontents patch failed!}}
% ^^A Really, why on Earth does Biblatex do something this obnoxious?
% ^^A It is all for unilaterally declaring standard LaTeX macros 'deprecated' and trying to replace them with its own less convenient versions.
% ^^A It could at least do us the favour of holding some of its much less defensible and much more inconvenient design decisions in equal contempt!!
\defbibheading{bibliography}[\refname]{%^^A
  \section*{#1}%^^A
  \markboth{#1}{}}
\errorcontextlines=10
% ^^A break long code lines unsuccessfully
\makeatletter
\def\@xobeysp{\leavevmode\penalty100\ }
\makeatother
%^^A END preamble >>>
\begin{document}
%^^A \let\MakePrivateLetters\MyMakePrivateLetters
\DocInput{\prooftreesdocname}
\end{document}
%</driver>
% \fi
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% \newgeometry{headheight=12pt,scale=.8,marginparwidth=0pt,marginparsep=0pt}%
% \savegeometry{safonol}%
% \setlength\tewadjust{\marginparwidth+\marginparsep}%
% \fancyheadoffset[lh]{0pt}% ^^A REQUIRED - do NOT remove this line!!
% \pagenumbering{arabic}%
% \maketitle
% \bigskip
%
% \begin{abstract}
%   \noindent \keyname[pkg]{\pkg{prooftrees}} is a \LaTeXe{} package, based on \keyname[pkg]{\pkg{forest}}, designed to support the typesetting of logical tableaux --- ‘proof trees’ or ‘truth trees’ --- in styles sometimes used in teaching introductory logic courses, especially those aimed at students without a strong background in mathematics.
%   One textbook which uses proofs of this kind is \textcite{hodges-logic}.
%   Like \pkg{forest}, \pkg{prooftrees} supports \keyname[pkg]{\pkg{memoize}} out-of-the-box.
% \end{abstract}
% \bigskip
% 
% ^^A <<<
% \begin{figure}[!b]
% \begin{adjustwidth}{-3em}{-5em}
%   \centering
%   \begin{minipage}[t]{.475\linewidth}
%     \begin{tableau}
%       {
%         to prove={S \liff \lnot T, T \liff \lnot R \sststile{\mathcal{L}}{} S \liff R},
%         highlight format={text=WildStrawberry},
%         line no sep=.35em,
%         just sep=.35em,
%         wff format={Purple4},
%         line no format={Purple4},
%         just format={Purple4},
%         close format={Purple4},
%         for tree={edge=Purple4},
%         close with format={Purple4},
%         where level=0{%
%           tikz+={%
%             \draw [Purple4, thick] (current bounding box.north west) rectangle (current bounding box.south east);
%             \draw [Purple4, semithick] (.south -| current bounding box.west) -- (.south -| current bounding box.east);
%           },
%         }{},
%       }
%       [{S \liff \lnot T}, checked, just=pr.
%         [T \liff \lnot R, checked, just=pr.
%           [\lnot(S \liff R), checked, just=$\lnot$ conc.
%             [S,  just={$\liff$\elim:!uuu}
%               [\lnot T , just={$\liff$\elim:!uuuu}
%                 [T, just={$\liff$\elim:!uuuu}
%                   [\lnot R, close={:!uu,!u} , just={$\liff$\elim:!uuuuu}
%                   ]
%                 ]
%                 [\lnot T
%                   [\lnot \lnot R, checked
%                   [\lnot S, just={$\lnot\liff$\elim:!r111}, highlight line
%                   [R, just={$\lnot\liff$\elim:!r111}, close={:!uuuuu,!u}, highlight line
%                       ]
%                     ]
%                     [S
%                       [\lnot R
%                         [R, just={$\lnot\lnot$\elim:!uuu}, close={:!u,!c}
%                         ]
%                       ]
%                     ]
%                   ]
%                 ]
%               ]
%             ]
%             [\lnot S,  just={$\liff$\elim:!uuu}
%               [\lnot \lnot T, just={$\liff$\elim:!uuuu}, checked
%                 [T, just={$\liff$\elim:!uuuu}
%                   [\lnot R, just={$\liff$\elim:!uuuuu}
%                     [\lnot S, just={$\lnot\liff$\elim:!r111}
%                     [R, just={$\lnot\liff$\elim:!r111}, close={:!uu,!c}
%                       ]
%                     ]
%                     [S
%                       [\lnot R, close={:!r1111,!u}
%                       ]
%                     ]
%                   ]
%                 ]
%                 [\lnot T
%                   [\lnot \lnot R, checked
%                   [T, close={:!uu,!c}, just={$\lnot\lnot$\elim:!uuu}
%                     ]
%                   ]
%                 ]
%               ]
%             ]
%           ]
%         ]
%       ]
%     \end{tableau}%
%   \end{minipage}\hfill
%   \begin{minipage}[t]{.525\linewidth}
%     \begin{tableau}
%       {
%         to prove={(\exists x)((\forall y)(Py \Rightarrow (x = y)) \cdot Px) \sststile{\mathcal{L}_1}{} (\exists x)(\forall y)(Py \Leftrightarrow (x = y))},
%         line no sep=.35em,
%         just sep=.35em,
%         wff format={RoyalBlue4},
%         line no format={RoyalBlue4},
%         just format={RoyalBlue4},
%         close format={RoyalBlue4},
%         for tree={edge=RoyalBlue4},
%         close with format={RoyalBlue4},
%         where level=0{%
%           tikz+={%
%             \draw [RoyalBlue4, thick] (current bounding box.north west) rectangle (current bounding box.south east);
%             \draw [RoyalBlue4, semithick] (.south -| current bounding box.west) -- (.south -| current bounding box.east);
%           },
%         }{},
%       }
%       [{(\exists x)((\forall y)(Py \Rightarrow (x = y)) \cdot Px)}, checked=d, just=pr.
%         [{\tnot (\exists x)(\forall y)(Py \Leftrightarrow (x = y))}, subs=d, just=$\lnot$ conc.
%           [{(\forall y)(Py \Rightarrow (d = y)) \cdot Pd}, checked, just={$\exists$\elim:!uu}
%             [{(\forall y)(Py \Rightarrow (d = y))}, subs=c, just={$\cdot$\elim:!u}
%               [Pd, just=$\cdot$\elim:!uu
%                 [{\tnot (\forall y)(Py \Leftrightarrow (d = y))}, checked=c, just={$\tnot\exists$\elim:!r11}
%                   [{\tnot (Pc \Leftrightarrow (d = c))}, checked, just={$\tnot\forall$\elim:!u}
%                     [Pc, just={$\tnot\Leftrightarrow$\elim:!u}
%                       [d \neq c, just={$\tnot\Leftrightarrow$\elim:!uu}, name=fred
%                         [{Pc \Rightarrow (d = c)}, checked, just=$\forall$\elim:!r1111, move by=1
%                           [\tnot Pc, close={:!uuu,!c} , just=$\Rightarrow$\elim:!u, wff options=WildStrawberry, !uuu.wff options=WildStrawberry
%                           ]
%                           [{d = c}
%                             [d \neq d, close={:!c} , just={$=$:fred,!u}, wff options=red
%                             ]
%                           ]
%                         ]
%                       ]
%                     ]
%                     [\tnot Pc
%                       [{d = c}
%                         [Pc, just={$=$:!r11111,!u}, close={:!uu,!c}, wff options=blue!50!cyan, !uu.wff options=blue!50!cyan
%                         ]
%                       ]
%                     ]
%                   ]
%                 ]
%               ]
%             ]
%           ]
%         ]
%       ]
%     \end{tableau}%
%   \end{minipage}%
% \end{adjustwidth}
% \end{figure}
% ^^A >>>
%
% \emph{\bfseries Note that this package requires version 2.1 (2016/12/04) of \keyname[pkg]{\pkg{forest}} \autocite{saso-forest-manual}.
%   It will not work with versions prior to 2.1.}
% \bigskip
%
% \emph{I would like to thank \citeauthor{saso-forest-manual} both for developing \pkg{forest} and for considerable patience in answering my questions, addressing my confusions and correcting my mistakes.
% The many remaining errors are, of course, entirely my own.
% This package's deficiencies would be considerably greater and more numerous were it not for his assistance.}
%
%
% \clearpage
%
% \tableofcontents
%
% \section{Raison d'être}\label{sec:raisondetre}
%^^A BEGIN raisondetre <<<
%
% Suppose that we wish to typeset a typical tableau demonstrating the following entailment
% \[
%   \{P \vee (Q \vee \lnot R), P \lif \lnot R, Q \lif \lnot R\} \sststile{}{} \lnot R
% \]
%
% We start by typesetting the tree using \pkg{forest}'s default settings (\cref{fordefaults}) and find our solution has several advantages: the proof is specified concisely and the code reflects the structure of the tree.
% \iffalse
%<*verb>
% \fi
\begin{codcoeden}[label=fordefaults,floatplacement=bp!]{\pkg{forest}: default settings}
\begin{forest}
  [$P \vee (Q \vee \lnot R)$
    [$P \lif \lnot R$
      [$Q \lif \lnot R$
        [$\lnot\lnot R$
          [$P$
            [$\lnot P$]
            [$\lnot R$]
          ]
          [$Q \vee \lnot R$
            [$Q$
              [$\lnot Q$]
              [$\lnot R$]
            ]
            [$\lnot R$]
          ]
        ]
      ]
    ]
  ]
\end{forest}
\end{codcoeden}
% \iffalse
%</verb>
% \fi
% It is relatively straightforward to specify a proof using \pkg{forest}'s bracket notation, and the spacing of nodes and branches is automatically calculated.
%
% Despite this, the results are not quite what we might have hoped for in a tableau.
% The assumptions should certainly be grouped more closely together and no edges (lines) should be drawn between them because these are not steps in the proof --- they do not represent inferences.
% Preferably, edges should start from a common point in the case of branching inferences, rather than there being a gap.
%
% Moreover, tableaux are often compacted so that \emph{non-branching} inferences are grouped together, like assumptions, without explicitly drawn edges.
% Although explicit edges to represent non-branching inferences are useful when introducing students to tableaux, more complex proofs grow unwieldy and the more compact presentation becomes essential.
%
% Furthermore, it is useful to have the option of \emph{annotating} tableaux by numbering the lines of the proof on the left and entering the justification for each line on the right.
%
% \pkg{forest} is a powerful and flexible package capable of all this and, indeed, a good deal more.
% It is not enormously difficult to customise particular trees to meet most of our desiderata.
% However, it is difficult to get things perfectly aligned even in simple cases, requires the insertion of ‘phantom’ nodes and management of several sub-trees in parallel (one for line numbers, one for the proof and one for the justifications).
% The process requires a good deal of manual intervention, trial-and-error and hard-coding of things it would be better to have \LaTeXe{} manage for us, such as keeping count of lines and line references.
%
% \pkg{prooftrees} aims to make it as easy to specify tableaux as it was to specify our initial tree using \pkg{forest}'s default settings.
% The package supports a small number of options which can be configured to customise the output.
% The code for a \pkg{prooftrees} tableau is shown in \cref{ptdefaults}, together with the output obtained using the default settings.
%
% \iffalse
%<*verb>
% \fi
\begin{codcoeden}*[label=ptdefaults]{\pkg{prooftrees}: default settings}
\begin{tableau}
  {
    to prove={\{P \vee (Q \vee \lnot R), P \lif \lnot R, Q \lif \lnot R\} \sststile{}{} \lnot R}
  }
  [P \vee (Q \vee \lnot R),  just=Ass, checked
    [P \lif \lnot R,  just=Ass, checked
      [Q \lif \lnot R,  just=Ass, checked, name=last premise
        [\lnot\lnot R, just={$\lnot$ Conc}, name=not conc
          [P,  just={$\vee$ Elim:!uuuu}
            [\lnot P, close={:!u,!c}]
            [\lnot R,  close={:not conc,!c}, just={$\lif$ Elim:!uuuu}]]
          [Q \vee \lnot R
            [Q, move by=1
              [\lnot Q, close={:!u,!c}]
              [\lnot R,  close={:not conc,!c}, just={$\lif$ Elim:last premise}]]
            [\lnot R, close={:not conc,!c}, move by=1, just={$\vee$ Elim:!u}]]]]]]
\end{tableau}
\end{codcoeden}
% \iffalse
%</verb>
% \fi
% More extensive configuration can be achieved by utilising \pkg{forest} \autocite{saso-forest-manual} and/or \TikZ{} \autocite{tantau-tikz-pgf-manual} directly.
% A sample of supported tableau styles are shown in \cref{sample}.
% The package is \emph{\bfseries not} intended for the typesetting of tableaux which differ significantly in structure.
% \clearpage
% \thispagestyle{plain}%
% \begin{coeden}[label=sample, floatplacement={!bp}, grow to left by=3em, grow to right by=3em]{\pkg{prooftrees}: sample output}
%   \centering
% \mbox{%^^A required by docstrip + memoize (but only for both)
%   \begin{tableau}
%     {
%       to prove={\{ P \lor (Q \lor \lnot R), P \lif \lnot R, Q \lif \lnot R \} \sststile{}{} \lnot R},
%       line no sep=.35em,
%       just sep=.35em,
%     }
%     [P \lor (Q \lor \lnot R),  just=Ass, checked
%       [P \lif \lnot R,  just=Ass, checked
%         [Q \lif \lnot R,  just=Ass, checked
%           [\lnot\lnot R, just={Neg conc}
%             [P,  just={$\lor$ Elim:!r1}
%               [\lnot P, close={:!u,!c}]
%               [\lnot R,  close={:!uu,!c}, just={$\lif$ Elim:!r11}
%               ]
%             ]
%             [Q \lor \lnot R, checked
%               [Q, move by=1
%                 [\lnot Q, close={:!u,!c}
%                 ]
%                 [\lnot R,  close={:!r1111,!c}, just={$\lif$ Elim:!r111}
%                 ]
%               ]
%               [\lnot R, close={:!r1111,!c}, just={$\lor$ Elim:!u}, move by=1
%               ]
%             ]
%           ]
%         ]
%       ]
%     ]
%   \end{tableau}%
% }%^^A
%   \hfill
%   {%
%     \renewcommand*\linenumberstyle[1]{#1)}%
% \mbox{%^^A required by docstrip + memoize (but only for both)
%     \begin{tableau}
%       {
%         close with={\ensuremath{\ast}},
%         just format={text=gray, font=\itshape},
%         line no format={text=gray},
%         for tree={
%           edge path'={(!u.parent anchor) -- +(0,-5pt) -| (.child anchor)},
%           edge={gray},
%         },
%         line no sep=.35em,
%         just sep=.35em,
%       }
%       [P \lor (Q \lor \tnot R),  just=Ass, checked
%         [P \supset \tnot R,  just=Ass, checked
%           [Q \supset \tnot R,  just=Ass, checked
%             [\tnot\tnot R, just={Neg conc}
%               [P,  just={$\lor$ Elim:!r1}
%                 [\tnot P, close={:!u,!c}]
%                 [\tnot R,  close={:!uu,!c}, just={$\supset$ Elim:!r11}
%                 ]
%               ]
%               [Q \lor \tnot R, checked
%                 [Q, move by=1
%                   [\tnot Q, close={:!u,!c}]
%                   [\tnot R,  close={:!r1111,!c}, just={$\supset$ Elim:!r111}
%                   ]
%                 ]
%                 [\tnot R,  close={:!r1111,!c}, just={$\lor$ Elim:!u}, move by=1
%                 ]
%               ]
%             ]
%           ]
%         ]
%       ]
%     \end{tableau}%
% }%^^A
%   }
%
% \mbox{%^^A required by docstrip + memoize (but only for both)
%   \begin{tableau}
%     {
%       not line numbering,
%       single branches,
%       close with={\fycross},
%       check with={\fycheck},
%       check left,
%       line no sep=.35em,
%       just sep=.35em,
%     }
%     [P \lor (Q \lor \lnot R),  just=Ass, checked
%       [P \lif \lnot R,  just=Ass, checked, grouped
%         [Q \lif \lnot R,  just=Ass, checked, grouped
%           [\lnot\lnot R, just={Neg conc}, grouped
%             [P,  just={$\lor$ Elim}
%               [\lnot P, close]
%               [\lnot R,  close, just={$\lif$ Elim}
%               ]
%             ]
%             [Q \lor \lnot R, checked
%               [Q, move by=1
%                 [\lnot Q, close]
%                 [\lnot R,  close, just={$\lif$ Elim}
%                 ]
%               ]
%               [\lnot R, close, just={$\lor$ Elim}, move by=1
%               ]
%             ]
%           ]
%         ]
%       ]
%     ]
%   \end{tableau}%
% }%^^A
%   \hfill
% \mbox{%^^A required by docstrip + memoize (but only for both)
%   \begin{tableau}
%     {
%       to prove={\{ P \lor (Q \lor \lnot R), P \lif \lnot R, Q \lif \lnot R \} \therefore \lnot R},
%       close with={\ensuremath{\times}},
%       highlight format={text=red},
%       line no sep=.35em,
%       just sep=.35em,
%     }
%     [P \lor (Q \lor \lnot R),  just=Ass, checked
%       [P \lif \lnot R,  just=Ass, checked
%         [Q \lif \lnot R,  just=Ass, checked
%           [\lnot\lnot R, just={Neg conc}, highlight wff
%             [P,  just={$\lor$ Elim:!r1}
%               [\lnot P, close={:!u,!c}, move by=2]
%               [\lnot R,  close={:!uu,!c}, just={$\lif$ Elim:!r11}, highlight wff, move by=2
%               ]
%             ]
%             [Q \lor \lnot R, checked
%               [Q
%                 [\lnot Q, close={:!u,!c}
%                 ]
%                 [\lnot R,  close={:!r1111,!c}, just={$\lif$ Elim:!r111}, highlight wff
%                 ]
%               ]
%               [\lnot R, close={:!r1111,!c}, just={$\lor$ Elim:!u}, highlight wff
%               ]
%             ]
%           ]
%         ]
%       ]
%     ]
%   \end{tableau}
% }%^^A
%
% \mbox{%^^A required by docstrip + memoize (but only for both)
%   \begin{tableau}
%     {
%       to prove={(\exists x)(Lx \lor Mx) \sststile{}{} (\exists x) Lx \lor (\exists x) Mx},
%       highlight format={text=blue!50!cyan},
%       line no sep=.5em,
%       just sep=.5em,
%     }
%     [(\exists x) (Lx \lor Mx), checked=a, just=Ass
%       [\lnot ((\exists x) Lx \lor (\exists x) Mx), checked, just=Neg Conc
%         [La \lor Ma, checked, just={1 $\exists$\elim}
%         [\lnot (\exists x) Lx, subs=a, just={2 $\lnot\lor$\elim}, highlight line, tikz+/.wrap pgfmath arg={%
%           \draw [decorate, decoration={brace, mirror}, draw=blue!50!cyan] (!1.south east -| just #1.east) ++(0,5pt) -- (just #1.north east);
%         }{level()}
%             [\lnot (\exists x) Mx, subs=a, highlight line
%               [\lnot La, just={4 $\lnot\exists$\elim}
%                 [\lnot Ma, just={5 $\lnot\exists$\elim}
%                 [La, close={6,8}, just={3 $\lor$\elim}]
%                   [Ma, close={7,8}]
%                 ]
%               ]
%             ]
%           ]
%         ]
%       ]
%     ]
%   \end{tableau}%
% }%^^A
%   \hfill
% \mbox{%^^A required by docstrip + memoize (but only for both)
%   \begin{tableau}
%     {
%       for tree={%
%         plain content,
%         edge path'={(!u.parent anchor) -- ++(0,-5pt) -| (.child anchor)},
%         align=center,
%         edge={rounded corners},
%       },
%       not line numbering,
%       just sep=.5em,
%     }
%     [Either Alice saw nobody\\or she didn't see nobody.
%       [Alice saw nobody., just={$\vee$\elim}, subs=Jones
%         [Alice didn't see Jones., just={$\forall$\elim}]
%       ]
%       [Alice didn't see nobody., move by=2, just={$\vee$\elim}
%         [Alice saw somebody., just={$\lnot\lnot$\elim}, checked=Jones
%         [Alice saw Jones., just={$\exists$\elim}, before typesetting nodes={for current and ancestors/.wrap pgfmath arg={edge+/.wrap pgfmath arg={red!##1!blue}{100*(level)/#1}, text/.wrap pgfmath arg={red!##1!blue}{100*(level)/#1}}{level}}]
%         ]
%       ]
%     ]
%   \end{tableau}%
% }%^^A
% \end{coeden}
%^^A END sec:raisondetre >>>
% \clearpage
%
% \section{Assumptions \& Limitations}\label{sec:ass}
%^^A BEGIN sec:ass <<<
%
% \pkg{prooftrees} makes certain assumptions about the nature of the proof system, $\mathcal{L}$, on which proofs are based.
% \begin{itemize}
%   \item All derivation rules yield equal numbers of \wff{}s on all branches.
%   \begin{center}
%     \begin{tableau}
%       {
%         not line numbering,
%         for tree={plain content},
%         for root={s sep+=10pt}
%       }
%       [\wff[\wff][\wff[\phantom{\wff}, label={[text=Green3]right:{\fycheck}}]]]
%       [\wff[\wff[\wff]][\wff[\wff, label={[text=Green3]right:{\fycheck}}]]]
%       [\wff[\wff][\wff[\wff, label={[text=red]right:{\fycross}}]]]
%       [\wff[\wff[\wff]][\wff[\phantom{\wff}, label={[text=red]right:{\fycross}}]]]
%     \end{tableau}
%   \end{center}
%   If $\mathcal{L}$ fails to satisfy this condition, \pkg{prooftrees} is likely to violate the requirements of affected derivation rules by splitting branches ‘mid-inference’.
%   \item No derivation rule yields \wff{}s on more than two branches.
%   \item All derivation rules proceed in a downwards direction at an angle of -90\textdegree{} i.e.~from north to south.
%   \item Any justifications are set on the far right of the tableau.
%   \item Any line numbers are set on the far left of the tableau.
%   \item Justifications can refer only to earlier lines in the proof.
%   \pkg{prooftrees} can typeset proofs if $\mathcal{L}$ violates this condition, but the cross-referencing system explained in \cref{subsec:lo} cannot be used for affected justifications.
% \end{itemize}
% \pkg{prooftrees} does not support the automatic breaking of tableaux across pages\footnote{%
%   It is possible to persuade \pkg{prooftrees} to do this automatically or semi-automatically.
%   However, the code is not in a state I would wish to inflict on an unsuspecting public.
%   The perilously inquisitive may search TeX Stack Exchange at their own risk.%^^A
% }.
% Tableaux can be manually broken by using \keyname[fregcount]{line no shift} with an appropriate value for parts after the first (\cref{subsec:go}).
% However, horizontal alignment across page breaks will not be consistent in this case.
%
% In addition, \pkg{prooftrees} almost certainly relies on additional assumptions not articulated above and certainly depends on a feature of \pkg{forest} which its author classifies as experimental (\keyname*{do dynamics}).
%
%^^A END sec:ass >>>
%
% \section{Typesetting a Tableau}\label{sec:ee}
%^^A BEGIN sec:ee <<<
%
% After loading \pkg{prooftrees} in the document preamble:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
% in document's preamble
\usepackage{prooftrees}
\end{latexcode}
% \iffalse
%</verb>
% \fi
% the \env{prooftree} environment is available for typesetting tableaux.
% This takes an argument used to specify a \meta{tree preamble}, with the body of the environment consisting of a \meta{tree specification} in \pkg{forest}'s notation.
% The \meta{tree preamble} can be as simple as an empty argument --- \arg{} --- or much more complex.
%
% Customisation options and further details concerning loading and invocation are explained in \cref{sec:llwytho}, \cref{sec:invoke}, \cref{sec:anatomy}, \cref{sec:ops} and \cref{sec:macros}.
% In this section, we begin by looking at a simple example using the default settings.
%
% Suppose that we wish to typeset the tableau for
% \[
%   (\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)
% \]
% and we would like to typeset the entailment established by our proof at the top of the tree.
% Then we should begin like this:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
\begin{tableau}
  {
    to prove={(\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)}
  }
\end{tableau}
\end{latexcode}
% \iffalse
%</verb>
% \fi
% That is all the preamble we want, so we move onto consider the \meta{tree specification}.
% \pkg{forest} uses square brackets to specify trees' structures.
% To typeset a proof, think of it as consisting of nested trees, trunks upwards, and work from the outside in and the trunks down (\cref{nythod}).
% \begin{coeden}[label=nythod]{Nested structure of tableau}
% \begin{tableau}
%   {
%     to prove={(\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)},
%     just sep*=3,
%     line no sep*=3,
%     for root={%
%       tikz+={%
%         \foreach \i [evaluate=\i as \j using 100*\i/14, evaluate=\i as \k using (11*(\i-7))-30, evaluate=\i as \m using (11*(7-\i))-30] in {13,...,1}
%         {%
%           \ifnum\i<8
%             \coordinate (p\i) at ([yshift=-1 pt,xshift=\k pt]current bounding box.south);
%           \else
%             \ifnum\i<10
%               \coordinate (p\i) at ([yshift=-1 pt,xshift=\m pt]current bounding box.south);
%             \else
%               \ifnum\i=10
%                 \coordinate (p\i) at ([yshift=-1 pt,xshift=\k+40 pt]current bounding box.south);
%               \else
%                 \coordinate (p\i) at ([yshift=-1 pt,xshift=\k-52 pt]current bounding box.south);
%               \fi
%             \fi
%           \fi
%           \node [fill=WildStrawberry!\j!blue, circle, font=\sffamily\small, text width=12pt, text centered, text=white, inner sep=0pt] at (p\i) {\i};
%           \ifnum\i>7
%             \ifnum\i<10
%               \coordinate (q\i) at ([xshift=\k+40 pt]current bounding box.south |- p\i);
%               \node [fill=WildStrawberry!\j!blue, circle, font=\sffamily\small, text width=12pt, text centered, text=white, inner sep=0pt] at (q\i) {\i};
%             \else
%               \ifnum\i=12
%                 \coordinate (q\i) at ([xshift=\m pt]current bounding box.south |- p\i);
%                 \node [fill=WildStrawberry!\j!blue, circle, font=\sffamily\small, text width=12pt, text centered, text=white, inner sep=0pt] at (q\i) {\i};
%               \fi
%             \fi
%           \fi
%         }
%       },
%     },
%     for tree={%
%       s sep'+=30pt,
%       if={%
%         > O_> O_= & {level}{0} {proof tree rhifo}{1}
%       }{%
%         node options/.process={%
%           OOw2+nw+Pw {level}{proof tree toing by}{#1+#2}{#1*100/14}{%
%             draw,rounded corners,WildStrawberry!#1!blue}},
%         fill=white,
%         delay={%
%           tempcounta/.process={OOw2+n{level}{proof tree toing by}{#1+#2}},
%           if={> R_< {tempcounta}{8}}{%
%             nyth/.process={Rw{tempcounta}{{(!r211111111112111) (!Luu) (!Luuu) (!11) (!Fuu) (!r21111111111)}{#1}{p}}},
%           }{%
%             if={>R_>{tempcounta}{9}}{%
%               if={>O_={!uu.n}{2}}{}{%
%                 tempcounta'+=1,
%                 if={>O_=O_=&{n}{1}{!u.n children}{2}}{%
%                   nyth/.process={Rw{tempcounta}{{}{#1}{q}}},
%                 }{%
%                   nyth/.process={Rw{tempcounta}{{}{#1}{p}}},
%                 },
%               },
%             }{%
%               tempcountb/.register=tempcounta,
%               if={>R_={tempcounta}{8}}{%
%                 if n=1{%^^A is-goeden ar y chwith
%                   nyth={(!1111) (!llll) (!lllll)}{8}{p},
%                 }{%^^A is-goeden ar y dde
%                   nyth={(!1) (!11)}{8}{q},
%                 },
%                 tempcounta'+=1,
%                 for n=1{%
%                   if={>O_={!u.n}{1}}{%^^A is-goeden ar y chwith
%                     nyth={(!Fuu) (!Luu)}{9}{p},
%                   }{%^^A is-goeden ar y dde
%                     nyth={(!1)}{9}{q},
%                     tempcounta'+=1,
%                     for n=1{%
%                       nyth={}{10}{p},
%                     },
%                   },
%                 },
%               }{},
%             },
%           },
%         },
%       }{},
%     },
%   }
%   [{(\exists x)((\forall y)(Py \lif x = y) \land Px)}, checked=a, just=Pr., name=pr
%     [{\lnot (\exists x)(\forall y)(Py \liff x = y)}, subs=a, just=Conc.~neg., name=neg conc
%       [{(\forall y)(Py \lif a = y) \land Pa}, checked, just=$\exists\elim$:pr
%         [{(\forall y)(Py \lif a = y)}, subs=b, just=$\land\elim$:!u, name=mark
%           [Pa, just=$\land\elim$:!uu, name=simple
%             [{\lnot (\forall y)(Py \liff a = y)}, checked=b, just=$\lnot\exists\elim$:neg conc
%               [{\lnot (Pb \liff a = b)}, checked, just=$\lnot\forall\elim$:!u
%                 [Pb, just=$\liff\elim$:!u, name=to Pb or not to Pb
%                   [a \neq b, just=$\liff\elim$:!u
%                     [{Pb \lif a = b}, checked, just=$\forall\elim$:mark, move by=1
%                       [\lnot Pb, close={:to Pb or not to Pb,!c}, just=$\lif\elim$:!u
%                       ]
%                       [{a = b}
%                         [a \neq a, close={:!c}, just={$=\elim$:{!uuu,!u}}
%                         ]
%                       ]
%                     ]
%                   ]
%                 ]
%                 [\lnot Pb
%                   [{a = b}
%                     [Pb, just={$=\elim$:{simple,!u}}, close={:to Pb or not to Pb,!c}
%                     ]
%                   ]
%                 ]
%               ]
%             ]
%           ]
%         ]
%       ]
%     ]
%   ]
% \end{tableau}
% \end{coeden}
%
% Starting with the outermost tree \nyth*{} and the topmost trunk, we replace the \bocsnyth{} with square brackets and enter the first \wff{} inside, adding \verb|just=Pr.| for the justification on the right and \verb|checked=a| so that the line will be marked as discharged with $a$ substituted for $x$.
% We also use \pkg{forest}'s \keyname*[fopttoks]{name} to label the line for ease of reference later.
% (Technically, it is the node rather than the line which is named, but, for our purposes, this doesn't matter.
% \pkg{forest} will create a name if we don't specify one, but it will not necessarily be one we would have chosen for ease of use!)
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
\begin{tableau}
  {
    to prove={(\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)}
  }
  [{(\exists x)((\forall y)(Py \lif x = y) \land Px)}, checked=a, just=Pr., name=pr
  ]
\end{tableau}
\end{latexcode}
% \iffalse
%</verb>
% \fi
% We can refer to this line later as \verb|pr|.
%
% We then consider the next tree \nyth*{}.
% Its \bocsnyth{} goes inside that for \nyth[1], so the square brackets containing the next \wff{} go inside those we used for \nyth[1].
% Again, we add the justification with \keyname[foptautotoks]{just}, but we use \verb|subs=a| rather than \verb|checked=a| as we want to mark substitution of $a$ for $x$ without discharging the line.
% Again, we use \keyname*[fopttoks]{name} so that we can refer to the line later as \verb|neg conc|.
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
\begin{tableau}
  {
    to prove={(\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)}
  }
  [{(\exists x)((\forall y)(Py \lif x = y) \land Px)}, checked=a, just=Pr., name=pr
    [{\lnot (\exists x)(\forall y)(Py \liff x = y)}, subs=a, just=Conc.~neg., name=neg conc
    ]
  ]
\end{tableau}
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% Turning to tree \nyth*{}, we again note that its \bocsnyth{} is nested within the previous two, so the square brackets for its \wff{} need to be nested within those for the previous \wff{}s.
% This time, we want to mark the line as discharged without substitution, so we simply use \keyname[fstyle]{checked} without a value.
% Since the justification for this line includes mathematics, we need to ensure that the relevant part of the justification is surrounded by \verb|$|\dots \verb|$| or \verb|\(|\dots\verb|\)|.
% This justification also refers to an earlier line in the proof.
% We could write this as \verb|just=1 $\exists\elim$|, but instead we use the name we assigned earlier with the referencing feature provided by \pkg{prooftrees}.
% To do this, we put the reference, \verb|pr| \emph{after} the rest of the justification, separating the two parts by a colon i.e.~\verb|$\exists\elim$:pr| and allow \pkg{prooftrees} to figure out the correct number.
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
\begin{tableau}
  {
    to prove={(\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)}
  }
  [{(\exists x)((\forall y)(Py \lif x = y) \land Px)}, checked=a, just=Pr., name=pr
    [{\lnot (\exists x)(\forall y)(Py \liff x = y)}, subs=a, just=Conc.~neg., name=neg conc
      [{(\forall y)(Py \lif a = y) \land Pa}, checked, just=$\exists\elim$:pr
      ]
    ]
  ]
\end{tableau}
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% Continuing in the same way, we surround each of the \wff{}s for \nyth*{}, \nyth*{}, \nyth*{} and \nyth*{} within square brackets nested within those surrounding the previous \wff{} since each of the trees is nested within the previous one.
% Where necessary, we use \keyname*[fopttoks]{name} to label lines we wish to refer to later, but we also use \pkg{forest}'s \emph{relative} naming system when this seems easier.
% For example, in the next line we add, we specify the justification as \verb|just=$\land\elim$:!u|.
% \verb|!| tells \pkg{forest} that the reference specifies a relationship between the current line and the referenced one, rather than referring to the other line by name.
% \verb|!u| refers to the current line's parent line --- in this case, \verb|{(\forall y)(Py \lif a = y) \land Pa}, checked, just=$\exists\elim$:pr|.
% \verb|!uu| refers to the current line's parent line's parent line and so on.
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
\begin{tableau}
  {
    to prove={(\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)}
  }
  [{(\exists x)((\forall y)(Py \lif x = y) \land Px)}, checked=a, just=Pr., name=pr
    [{\lnot (\exists x)(\forall y)(Py \liff x = y)}, subs=a, just=Conc.~neg., name=neg conc
      [{(\forall y)(Py \lif a = y) \land Pa}, checked, just=$\exists\elim$:pr
        [{(\forall y)(Py \lif a = y)}, subs=b, just=$\land\elim$:!u, name=mark
          [Pa, just=$\land\elim$:!uu, name=simple
            [{\lnot (\forall y)(Py \liff a = y)}, checked=b, just=$\lnot\exists\elim$:neg conc
              [{\lnot (Pb \liff a = b)}, checked, just=$\lnot\forall\elim$:!u
              ]
            ]
          ]
        ]
      ]
    ]
  ]
\end{tableau}
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% Reaching \nyth*{}, things get a little more complex since we now have not one, but \emph{two} \bocsnyth{} nested within \nyth[7].
% This means that we need \emph{two} sets of square brackets for \nyth{} --- one for each of its two trees.
% Again, both of these should be nested within the square brackets for \nyth[7] but neither should be nested within the other because the trees for the two branches at \nyth{} are distinct.
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
\begin{tableau}
  {
    to prove={(\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)}
  }
  [{(\exists x)((\forall y)(Py \lif x = y) \land Px)}, checked=a, just=Pr., name=pr
    [{\lnot (\exists x)(\forall y)(Py \liff x = y)}, subs=a, just=Conc.~neg., name=neg conc
      [{(\forall y)(Py \lif a = y) \land Pa}, checked, just=$\exists\elim$:pr
        [{(\forall y)(Py \lif a = y)}, subs=b, just=$\land\elim$:!u, name=mark
          [Pa, just=$\land\elim$:!uu, name=simple
            [{\lnot (\forall y)(Py \liff a = y)}, checked=b, just=$\lnot\exists\elim$:neg conc
              [{\lnot (Pb \liff a = b)}, checked, just=$\lnot\forall\elim$:!u
                [Pb, just=$\liff\elim$:!u, name=to Pb or not to Pb
                ]
                [\lnot Pb
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
\end{tableau}
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% At this point, we need to work separately or in parallel on each of our two branches since each constitutes its own tree.
% Turning to trees \nyth*{}, each needs to be nested within the relevant tree \nyth[8], since each \bocsnyth{} is nested within the applicable branch's tree.
% Hence, we nest square brackets for each of the \wff{}s at \nyth{} within the previous set.
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
\begin{tableau}
  {
    to prove={(\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)}
  }
  [{(\exists x)((\forall y)(Py \lif x = y) \land Px)}, checked=a, just=Pr., name=pr
    [{\lnot (\exists x)(\forall y)(Py \liff x = y)}, subs=a, just=Conc.~neg., name=neg conc
      [{(\forall y)(Py \lif a = y) \land Pa}, checked, just=$\exists\elim$:pr
        [{(\forall y)(Py \lif a = y)}, subs=b, just=$\land\elim$:!u, name=mark
          [Pa, just=$\land\elim$:!uu, name=simple
            [{\lnot (\forall y)(Py \liff a = y)}, checked=b, just=$\lnot\exists\elim$:neg conc
              [{\lnot (Pb \liff a = b)}, checked, just=$\lnot\forall\elim$:!u
                [Pb, just=$\liff\elim$:!u, name=to Pb or not to Pb
                 [a \neq b, just=$\liff\elim$:!u
                 ]
                ]
                [\lnot Pb
                 [{a = b}
                 ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
\end{tableau}
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% We only have one tree \nyth*{} as there is no corresponding tree in the left-hand branch.
% This isn't a problem: we just need to ensure that we nest it within the appropriate tree \nyth[9].
% There are two additional complications here.
% The first is that the justification contains a comma, so we need to surround the argument we give \keyname[foptautotoks]{just} with curly brackets.
% That is, we must write \verb|just={5,9 $=\elim$}| or \verb|just={$=\elim$:{simple,!u}}|.
% The second is that we wish to close this branch with an indication of the line numbers containing inconsistent \wff{}s.
% We can use \verb|close={8,10}| for this or we can use the same referencing system we used to reference lines when specifying justifications and write \verb|close={:to Pb or not to Pb,!c}|.
% In either case, we again surrounding the argument with curly brackets to protect the comma.
% \verb|!c| refers to the current line --- something useful in many close annotations, but not helpful in specifying non-circular justifications.
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
\begin{tableau}
  {
    to prove={(\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)}
  }
  [{(\exists x)((\forall y)(Py \lif x = y) \land Px)}, checked=a, just=Pr., name=pr
    [{\lnot (\exists x)(\forall y)(Py \liff x = y)}, subs=a, just=Conc.~neg., name=neg conc
      [{(\forall y)(Py \lif a = y) \land Pa}, checked, just=$\exists\elim$:pr
        [{(\forall y)(Py \lif a = y)}, subs=b, just=$\land\elim$:!u, name=mark
          [Pa, just=$\land\elim$:!uu, name=simple
            [{\lnot (\forall y)(Py \liff a = y)}, checked=b, just=$\lnot\exists\elim$:neg conc
              [{\lnot (Pb \liff a = b)}, checked, just=$\lnot\forall\elim$:!u
                [Pb, just=$\liff\elim$:!u, name=to Pb or not to Pb
                 [a \neq b, just=$\liff\elim$:!u
                 ]
                ]
                [\lnot Pb
                 [{a = b}
                    [Pb, just={$=\elim$:{simple,!u}}, close={:to Pb or not to Pb,!c}
                    ]
                 ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
\end{tableau}
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% This completes the main right-hand branch of the tree and we can focus solely on the remaining left-hand one.
% Tree \nyth*{} is straightforward --- we just need to nest it within the left-hand tree \nyth[9].
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
\begin{tableau}
  {
    to prove={(\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)}
  }
  [{(\exists x)((\forall y)(Py \lif x = y) \land Px)}, checked=a, just=Pr., name=pr
    [{\lnot (\exists x)(\forall y)(Py \liff x = y)}, subs=a, just=Conc.~neg., name=neg conc
      [{(\forall y)(Py \lif a = y) \land Pa}, checked, just=$\exists\elim$:pr
        [{(\forall y)(Py \lif a = y)}, subs=b, just=$\land\elim$:!u, name=mark
          [Pa, just=$\land\elim$:!uu, name=simple
            [{\lnot (\forall y)(Py \liff a = y)}, checked=b, just=$\lnot\exists\elim$:neg conc
              [{\lnot (Pb \liff a = b)}, checked, just=$\lnot\forall\elim$:!u
                [Pb, just=$\liff\elim$:!u, name=to Pb or not to Pb
                 [a \neq b, just=$\liff\elim$:!u
                  [{Pb \lif a = b}, checked, just=$\forall\elim$:mark%, move by=1
                  ]
                ]
                ]
                [\lnot Pb
                 [{a = b}
                    [Pb, just={$=\elim$:{simple,!u}}, close={:to Pb or not to Pb,!c}
                    ]
                 ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
\end{tableau}
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% At this point, the main left-hand branch itself branches, so we have two trees \nyth*{}.
% Treating this in the same way as the earlier branch at \nyth[8], we use two sets of square brackets nested within those for tree \nyth{}, but with neither nested within the other.
% Since we also want to mark the leftmost branch as closed, we add \verb|close={:to Pb or not to Pb,!c}| in the same way as before.
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
\begin{tableau}
  {
    to prove={(\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)}
  }
  [{(\exists x)((\forall y)(Py \lif x = y) \land Px)}, checked=a, just=Pr., name=pr
    [{\lnot (\exists x)(\forall y)(Py \liff x = y)}, subs=a, just=Conc.~neg., name=neg conc
      [{(\forall y)(Py \lif a = y) \land Pa}, checked, just=$\exists\elim$:pr
        [{(\forall y)(Py \lif a = y)}, subs=b, just=$\land\elim$:!u, name=mark
          [Pa, just=$\land\elim$:!uu, name=simple
            [{\lnot (\forall y)(Py \liff a = y)}, checked=b, just=$\lnot\exists\elim$:neg conc
              [{\lnot (Pb \liff a = b)}, checked, just=$\lnot\forall\elim$:!u
                [Pb, just=$\liff\elim$:!u, name=to Pb or not to Pb
                 [a \neq b, just=$\liff\elim$:!u
                  [{Pb \lif a = b}, checked, just=4 $\forall\elim$
                      [\lnot Pb, close={:to Pb or not to Pb,!c}, just=$\lif\elim$:!u
                      ]
                      [{a = b}
                      ]
                  ]
                ]
                ]
                [\lnot Pb
                 [{a = b}
                    [Pb, just={$=\elim$:{simple,!u}}, close={:to Pb or not to Pb,!c}
                    ]
                 ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
\end{tableau}
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% We complete our initial specification by nesting \nyth*{} within the appropriate tree \nyth[12], again marking closure appropriately.
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
\begin{tableau}
  {
    to prove={(\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)}
  }
  [{(\exists x)((\forall y)(Py \lif x = y) \land Px)}, checked=a, just=Pr., name=pr
    [{\lnot (\exists x)(\forall y)(Py \liff x = y)}, subs=a, just=Conc.~neg., name=neg conc
      [{(\forall y)(Py \lif a = y) \land Pa}, checked, just=$\exists\elim$:pr
        [{(\forall y)(Py \lif a = y)}, subs=b, just=$\land\elim$:!u, name=mark
          [Pa, just=$\land\elim$:!uu, name=simple
            [{\lnot (\forall y)(Py \liff a = y)}, checked=b, just=$\lnot\exists\elim$:neg conc
              [{\lnot (Pb \liff a = b)}, checked, just=$\lnot\forall\elim$:!u
                [Pb, just=$\liff\elim$:!u, name=to Pb or not to Pb
                 [a \neq b, just=$\liff\elim$:!u
                  [{Pb \lif a = b}, checked, just=4 $\forall\elim$
                      [\lnot Pb, close={:to Pb or not to Pb,!c}, just=$\lif\elim$:!u
                      ]
                      [{a = b}
                        [a \neq a, close={:!c}, just={$=\elim$:{!uuu,!u}}
                        ]
                      ]
                  ]
                ]
                ]
                [\lnot Pb
                 [{a = b}
                    [Pb, just={$=\elim$:{simple,!u}}, close={:to Pb or not to Pb,!c}
                    ]
                 ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
\end{tableau}
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% Compiling our code, we find that the line numbering is not quite right:
%
% \begin{tableau}
%   {
%     to prove={(\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)}
%   }
%   [{(\exists x)((\forall y)(Py \lif x = y) \land Px)}, checked=a, just=Pr., name=pr
%     [{\lnot (\exists x)(\forall y)(Py \liff x = y)}, subs=a, just=Conc.~neg., name=neg conc
%       [{(\forall y)(Py \lif a = y) \land Pa}, checked, just=$\exists\elim$:pr
%         [{(\forall y)(Py \lif a = y)}, subs=b, just=$\land\elim$:!u, name=mark
%           [Pa, just=$\land\elim$:!uu, name=simple
%             [{\lnot (\forall y)(Py \liff a = y)}, checked=b, just=$\lnot\exists\elim$:neg conc
%               [{\lnot (Pb \liff a = b)}, checked, just=$\lnot\forall\elim$:!u
%                 [Pb, just=$\liff\elim$:!u, name=to Pb or not to Pb
%                   [a \neq b, just=$\liff\elim$:!u
%                   [{Pb \lif a = b}, checked, just=4 $\forall\elim$
%                       [\lnot Pb, close={:to Pb or not to Pb,!c}, just=$\lif\elim$:!u
%                       ]
%                       [{a = b}
%                         [a \neq a, close={:!c}, just={$=\elim$:{!uuu,!u}}
%                         ]
%                       ]
%                   ]
%                 ]
%                 ]
%                 [\lnot Pb
%                   [{a = b}
%                     [Pb, just={$=\elim$:{simple,!u}}, close={:to Pb or not to Pb,!c}
%                     ]
%                   ]
%                 ]
%               ]
%             ]
%           ]
%         ]
%       ]
%     ]
%   ]
% \end{tableau}
%
% \pkg{prooftrees} warns us about this:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
Package prooftrees Warning: Merging conflicting justifications for line 10! Please examine the output carefully and use "move by" to move lines later in the proof if required. Details of how to do this are included in the documentation.
\end{latexcode}
% \iffalse
%</verb>
% \fi
% We would like line 10 in the left-hand branch to be moved down by one line, so we add \verb|move by=1| to the relevant line of our proof.
% That is, we replace the line
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
                  [{Pb \lif a = b}, checked, just=4 $\forall\elim$
\end{latexcode}
% \iffalse
%</verb>
% \fi
% by
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
                  [{Pb \lif a = b}, checked, just=$\forall\elim$:mark, move by=1
\end{latexcode}
% \iffalse
%</verb>
% \fi
% giving us the following code:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
\begin{tableau}
  {
    to prove={(\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)}
  }
  [{(\exists x)((\forall y)(Py \lif x = y) \land Px)}, checked=a, just=Pr., name=pr
    [{\lnot (\exists x)(\forall y)(Py \liff x = y)}, subs=a, just=Conc.~neg., name=neg conc
      [{(\forall y)(Py \lif a = y) \land Pa}, checked, just=$\exists\elim$:pr
        [{(\forall y)(Py \lif a = y)}, subs=b, just=$\land\elim$:!u, name=mark
          [Pa, just=$\land\elim$:!uu, name=simple
            [{\lnot (\forall y)(Py \liff a = y)}, checked=b, just=$\lnot\exists\elim$:neg conc
              [{\lnot (Pb \liff a = b)}, checked, just=$\lnot\forall\elim$:!u
                [Pb, just=$\liff\elim$:!u, name=to Pb or not to Pb
                 [a \neq b, just=$\liff\elim$:!u
                  [{Pb \lif a = b}, checked, just=$\forall\elim$:mark, move by=1
                      [\lnot Pb, close={:to Pb or not to Pb,!c}, just=$\lif\elim$:!u
                      ]
                      [{a = b}
                        [a \neq a, close={:!c}, just={$=\elim$:{!uuu,!u}}
                        ]
                      ]
                  ]
                ]
                ]
                [\lnot Pb
                 [{a = b}
                    [Pb, just={$=\elim$:{simple,!u}}, close={:to Pb or not to Pb,!c}
                    ]
                 ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
\end{tableau}
\end{latexcode}
% \iffalse
%</verb>
% \fi
% which produces our desired result:
%
% \begin{tableau}
%   {
%     to prove={(\exists x)((\forall y)(Py \lif x = y) \land Px) \sststile{}{} (\exists x)(\forall y)(Py \liff x = y)}
%   }
%   [{(\exists x)((\forall y)(Py \lif x = y) \land Px)}, checked=a, just=Pr., name=pr
%     [{\lnot (\exists x)(\forall y)(Py \liff x = y)}, subs=a, just=Conc.~neg., name=neg conc
%       [{(\forall y)(Py \lif a = y) \land Pa}, checked, just=$\exists\elim$:pr
%         [{(\forall y)(Py \lif a = y)}, subs=b, just=$\land\elim$:!u, name=mark
%           [Pa, just=$\land\elim$:!uu, name=simple
%             [{\lnot (\forall y)(Py \liff a = y)}, checked=b, just=$\lnot\exists\elim$:neg conc
%               [{\lnot (Pb \liff a = b)}, checked, just=$\lnot\forall\elim$:!u
%                 [Pb, just=$\liff\elim$:!u, name=to Pb or not to Pb
%                   [a \neq b, just=$\liff\elim$:!u
%                   [{Pb \lif a = b}, checked, just=$\forall\elim$:mark, move by=1
%                       [\lnot Pb, close={:to Pb or not to Pb,!c}, just=$\lif\elim$:!u
%                       ]
%                       [{a = b}
%                         [a \neq a, close={:!c}, just={$=\elim$:{!uuu,!u}}
%                         ]
%                       ]
%                   ]
%                 ]
%                 ]
%                 [\lnot Pb
%                   [{a = b}
%                     [Pb, just={$=\elim$:{simple,!u}}, close={:to Pb or not to Pb,!c}
%                     ]
%                   ]
%                 ]
%               ]
%             ]
%           ]
%         ]
%       ]
%     ]
%   ]
% \end{tableau}
%
%^^A END sec:ee >>>
%
% \restoregeometry
% \setlength\tewadjust{\marginparwidth+\marginparsep-\paperwidth+\textwidth+\oddsidemargin+1in}%
% \fancyheadoffset[lh]{\tewadjust}%
% \section{Loading the Package}\label{sec:llwytho}
%^^A BEGIN sec:llwytho <<<
%
% To load the package simply add the following to your document's preamble.
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
\usepackage{prooftrees}
\end{latexcode}
% \iffalse
%</verb>
% \fi
% \keyname[pkg]{\pkg{prooftrees}} will load \keyname[pkg]{\pkg{forest}} automatically.
%
% \changes{v0.6}{}{Add compatibility option for use with \pkg{bussproofs}.
% Thanks to Peter Smith for suggesting this.}
% The only option currently supported is \keyname[pkgopt]{\option{tableaux}}.
% If this option is specified, the \env{prooftree} environment will be called \env{tableau} instead.
% \Example{\cs{usepackage}[tableaux]{prooftrees}} would cause the \env{tableau} environment to be defined \emph{rather than} \env{prooftree}.
%
% Any other options given will be passed to \keyname[pkg]{\pkg{forest}}.
% \Example{\cs{usepackage}[debug]{prooftrees}} would enable \keyname[pkg]{\pkg{forest}}'s debugging.
%
% If one or more of \keyname[pkg]{\pkg{forest}}'s libraries are to be loaded, it is recommended that these be loaded separately and their defaults applied, if applicable, within a local \TeX{} group so that they do not interfere with \keyname[pkg]{\pkg{prooftrees}}'s environment.
%^^A END sec:llwytho >>>
%
% \section{Invocation}\label{sec:invoke}
%^^A BEGIN sec:invoke <<<
% \DescribeEnv{prooftree}\cs{begin}\arg{\env{prooftree}}\marg{tree preamble}\meta{tree specification}\cs{end}\arg{\env{prooftree}}\AfterLastParam
% The \meta{tree preamble} is used to specify any non-default options which should be applied to the tree.
% It may contain any code valid in the preamble of a regular \pkg{forest} tree, in addition to setting \pkg{prooftree} options.
% The preamble may be empty, but the argument is \emph{required}\footnote{%
%   Failure to specify a required argument does not always yield a compilation error in the case of environments.
%   However, failure to specify required arguments to environments often fails to achieve the best consequences, even when it does not result in compilation failures, and will, therefore, be avoided by the prudent.}.
% The \meta{tree specification} specifies the tree in the bracket notation parsed by \pkg{forest}.
%
% {\em
%   {\bfseries
%     Users of \keyname[pkg]{\pkg{forest}} should note that the environments \env{prooftree} and \env{forest} differ in important ways.%
%   }%
%   \begin{itemize}
%     \item \env{prooftree}'s argument is \emph{mandatory}.
%     \item The tree's preamble \emph{cannot} be given in the body of the environment.
%     \item \cs{end}\arg{prooftree} \emph{must} follow the \meta{tree specification} \emph{immediately}.
%   \end{itemize}%
% }
%
% \DescribeEnv{tableau}\cs{begin}\arg{\env{tableau}}\marg{tree preamble}\meta{tree specification}\cs{end}\arg{\env{tableau}}\AfterLastParam
% A substitute for \env{prooftree}, defined \emph{instead} of \env{prooftree} if the package option \option{tableaux} is specified or a \cs{prooftree} macro is already defined when \keyname[pkg]{\pkg{prooftrees}} is loaded.
% See \cref{sec:llwytho} for details and \cref{sec:compat} for this option's raison d'être.
%
%^^A END sec:invoke >>>
%
% \section{Tableau Anatomy}\label{sec:anatomy}
%^^A BEGIN sec:anatomy <<<
% The following diagram provides an overview of the configuration and anatomy of a \pkg{prooftrees} proof tree.
% Detailed documentation is provided in \cref{sec:ops} and \cref{sec:macros}.
%
% \forestset{declare count register={cau},cau'=0}
% \begin{tableau}
%   {
%     to prove={proof statement},
%     for tree={%
%       plain content,
%       font=\itshape,
%       delay={content=wff, shape=rectangle,},
%       if level=0{}{just=justification},
%       if n children=0{%
%         close={$n,m$},
%         cau'+=1,
%         tikz+/.wrap pgfmath arg={%
%           \begin{scope}[on background layer]
%             \node (cau#1) [inner sep=-2pt, post grwp=DarkOrchid4, fit=(!1) (!11)] {};
%           \end{scope}
%         }{cau},
%         if={cau==5}{%
%           tikz+={%
%             \path [nodiad=DarkOrchid4] (cau5.south) -- ++(0,-30pt) |- ++(-50:85pt) node (x2) [anchor=west] {Closure};
%             \begin{scope}[every node/.append style={font=\scriptsize, align=left, inner sep=0pt}]
%               \node [text=DarkOrchid4, anchor=north west, xshift=10pt, text width=.475\textwidth] at (x2.south west) {\textbullet\ closure symbol \& optional annotation\\\textbullet\ location \& annotation content controlled by \keyname[fstyle]{close} within the \meta{tree specification}\\\textbullet\ annotations support cross-references\\\textbullet\ closure symbol controlled by \keyname[fregtoks]{close with} and \keyname[fregkeylist]{close with format}\\\textbullet\ global annotation format controlled by \keyname[fregkeylist]{close format} \& \keyname[fregdim]{close sep}};
%             \end{scope}
%           }
%         }{}
%       }{},
%     },
%     for root={%
%       delay={%
%         tikz+={%
%           \begin{scope}[on background layer]
%             \begin{scope}[inner sep=0pt]
%               \node (cas) [fit=(), grwp=DodgerBlue3] {};
%               \node (rhif) [fit=(!1) (!1F), grwp=Green4] {};
%               \node (nod) [fit=(!3) (!3F), grwp=DarkOrange3] {};
%               \node (wff) [fit=(!2) (!2F) (!2L) (!2LP) (!2LPP), grwp=WildStrawberry] {};
%             \end{scope}
%             \path [nodiad=DodgerBlue3] (cas.north) -- ++(0,7.5pt) |- ++(85:90pt) node (cas2) [anchor=west] {Theorem/Entailment};
%             \path [nodiad=Green4] (rhif.south) -- ++(0,-45pt) |- ++(-85:130pt) node (rhif2) [anchor=west] {Line Numbers};
%             \path [nodiad=DarkOrange3] (nod.north) |- ++(40:35pt) node (nod2) [anchor=west] {Justifications};
%             \path [nodiad=WildStrawberry] (wff.south) |- ++(-50pt,-15pt) -- ++(0,-15pt) node (wff2) [anchor=north] {\wff s};
%             \begin{scope}[every node/.append style={font=\scriptsize, align=left, inner sep=0pt}]
%               \node [text=DodgerBlue3, anchor=north west, xshift=10pt,] at (cas2.south west) {\textbullet\ specified with \texttt{to prove}\\\textbullet\ format controlled by \keyname[fregkeylist]{proof statement format}\\\textbullet\ named \texttt{proof statement}};
%               \node [text=Green4, anchor=north west, xshift=10pt, text width=.6\textwidth] at (rhif2.south west) {\textbullet\ content \& location automatic\\\textbullet\ existence controlled by \texttt{line numbering}\\\textbullet\ global format controlled by \keyname[fregkeylist]{line no format} \& \cs{linenumberstyle}\\\textbullet\ local format controlled by \keyname[foptbool]{highlight line no} \& \keyname[foptautotoks]{line no options}\\\textbullet\ named \texttt{line no $n$} for proof line $n$};
%               \node (nod3) [text=DarkOrange3, anchor=north west, xshift=10pt, text width=.4\textwidth] at (nod2.south west) {\textbullet\ location automatic\\\textbullet\ existence controlled implicitly or with \texttt{justifications}\\\textbullet\ content specified with \texttt{just}\\\textbullet\ cross-references supported\\\textbullet\ global format controlled by \keyname[fregkeylist]{just format} \& \keyname[fregbool]{just refs left}\\\textbullet\ local format controlled by \keyname[foptbool]{highlight just} \& \keyname[foptautotoks]{just options}\\\textbullet\ named \texttt{just $n$} for proof line $n$};
%               \node [text=WildStrawberry, anchor=north west, xshift=10pt, text width=.25\textwidth] at (wff2.south west) {\textbullet\ from \meta{tree specification}\\\textbullet\ global format controlled by \keyname[fregkeylist]{wff format}\\\textbullet\ local format controlled by \keyname[foptbool]{highlight wff} \& \keyname[foptautotoks]{wff options}\\\textbullet\ \keyname[foptbool]{highlight line} and \keyname[foptautotoks]{line options} control the format of the current \wff's proof line};
%             \end{scope}
%             \node (esb) [below=10pt of nod3.south west, font=\footnotesize, anchor=north west, align=left, text width=.4\textwidth] {\textsc{Anatomy \& Ontology}\\\textbullet\ \pkg{forest} trees consist of  (\TikZ) \texttt{nodes}\\\textbullet\ \pkg{prooftrees} places \wff s, line numbers, justifications \& proof statements into nodes\\\textbullet\ the content \& location of each node depends on its type: line number, \wff{}, justification or proof statement\\\textbullet\ the proof's structure \& appearance is determined by the \meta{tree preamble} \& \meta{tree specification}\\\textbullet\ node content, existence \& location is controlled by one or both of these, depending on the node type};
%             \node [below=5pt of esb.south west, font=\footnotesize, anchor=north west, align=left, text width=.55\textwidth, xshift=-.15\textwidth] {\textsc{Meaning \& Reference}\\\textbullet\ nodes for the proof statement, justifications \& line numbers are given standard names for ease of reference\\\textbullet\ the proof statement node is the \texttt{root}\\\textbullet\ \wff{} nodes may be named as required\\\textbullet\ a cross-referencing system supports annotations in justifications and closures};
%           \end{scope}
%         },
%       },
%     },
%   }
%   [, checked,
%     tikz+={%
%       \node (c1) [anchor=base east] at (.base east) {\phantom{$\checkmark$}};
%       \begin{scope}[on background layer]
%         \node [post grwp=DarkOrchid4,anchor=base east, inner sep=-2pt, fit=(c1)] {};
%         \path [nodiad=DarkOrchid4] ([yshift=-2pt]c1.north) |- ++(80:75pt) node (ann2) [anchor=west] {Discharge \& Substitution};
%         \begin{scope}[every node/.append style={font=\scriptsize, align=left, inner sep=0pt}]
%           \node [text=DarkOrchid4, anchor=north west, xshift=10pt, text width=.7\textwidth] at (ann2.south west) {\textbullet\ location \& annotation content controlled by \keyname[fstyle]{checked} and \keyname[fstyle]{subs} within the \meta{tree specification}\\\textbullet\ discharge \& substitution symbols controlled by \keyname[fregtoks]{check with} \& \keyname[fregtoks]{subs with}\\\textbullet\ \keyname[fregbool]{check right} \& \keyname[fregbool]{subs right} control relative location};
%         \end{scope}
%       \end{scope}
%     }
%     [, checked=a,
%       tikz+={%
%         \node (c2) [anchor=base east] at (.base east) {\phantom{$\checkmark a$}};
%         \begin{scope}[on background layer]
%           \node [post grwp=DarkOrchid4,anchor=base east, inner sep=-2pt, fit=(c2)] {};
%         \end{scope}
%        }
%       [, subs={a,b},
%         tikz+={%
%           \node (s1) [anchor=base east] at (.base east) {\phantom{$\backslash a,b$}};
%           \begin{scope}[on background layer]
%             \node [post grwp=DarkOrchid4,anchor=base east, inner sep=-2.5pt, fit=(s1)] {};
%           \end{scope}
%        }
%         [[[[][]]]][[[[[]][[[]]]][[]]]]]]]
% \end{tableau}
%
%^^A END sec:anatomy >>>
%
% \section{Options}\label{sec:ops}
%^^A BEGIN sec:ops <<<
% Most configuration uses the standard key/value interface provided by \TikZ{} and extended by \pkg{forest}.
% These are divided into those which determine the overall appearance of the proof as a whole and those with more local effects.
% See \cref{sec:keylists} for advanced customisation.
%
% \subsection{Global Options}\label{subsec:go}
%^^A BEGIN subsec:go <<<
%
% The following options affect the global style of the tree and should typically be set in the tree's preamble if non-default values are desired.
% The default values for the document can be set outside the \env{prooftree} environment using \cs{forestset}\marg{settings}.
% If \emph{only} tableaux will be typeset, a default style can be configured using \pkg{forest}'s \keyname*[fkeylist]{default preamble}.
%
% \changes{v0.7}{}{Implement \pkg{forest} boolean register \texttt{auto move}.
% The main point of this option is to allow automatic moves to be switched off if one teaches students to first apply  all available non-branching rules for the tableau as a whole, as opposed to all non-branching rules for the sub-tree.
% The automatic algorithm is consistent with the latter, but not former, approach.
% The algorithm favours compact trees, which are more likely to fit on \pkg{beamer} slides.
% Switching the algorithm off permits users to specify exactly how things should or should not be moved.
% Thanks to Peter Smith for prompting this.}
% \DescribeKeys[fregbool]{auto move, not auto move}\vals{true,false}\AfterLastParam
% \Default{true}
% Determines whether \pkg{prooftrees} will move lines automatically, where possible, to avoid combining different justifications when different branches are treated differently.
% The default is to avoid conflicts automatically where possible.
% Turning this off permits finer-grained control of what gets moved using \keyname[fstyle]{move by}.
% The following are equivalent to the default setting:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  auto move
  auto move=true
\end{latexcode}
% \iffalse
%</verb>
% \fi
% Either of the following will turn auto move off:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  not auto move
  auto move=false
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% \DescribeKeys[fregbool]{line numbering, not line numbering}\vals{true,false}\AfterLastParam
% \Default{true}
% This determines whether lines should be numbered.
% The default is to number lines.
% The following are equivalent to the default setting:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  line numbering
  line numbering=true
\end{latexcode}
% \iffalse
%</verb>
% \fi
% Either of the following will turn line numbering off:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  not line numbering
  line numbering=false
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% \DescribeKeys[fregbool]{justifications, not justifications}\vals{true,false}\AfterLastParam
% This determines whether justifications for lines of the proof should be typeset to the right of the tree.
% It is rarely necessary to set this option explicitly as it will be automatically enabled if required.
% The only exception concerns a proof for which a line should be moved but no justifications are specified.
% In this case either of the following should be used to activate the option:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  justifications
  justifications=true
\end{latexcode}
% \iffalse
%</verb>
% \fi
% This is not necessary if \keyname[foptautotoks]{just} is used for any line of the proof.
%
% \DescribeKeys[fregbool]{single branches, not single branches}\vals{true,false}\AfterLastParam
% \Default{false}
% This determines whether inference steps which do not result in at least two branches should draw and explicit branch.
% The default is to not draw single branches explicitly.
% The following are equivalent to the default setting:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  not single branches
  single branches=false
\end{latexcode}
% \iffalse
%</verb>
% \fi
% Either of the following will turn line numbering off:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  single branches
  single branches=true
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% \subsubsection{Dimensions}\label{subsubsec:go-dims}
% ^^A subsubsec:go-dims <<<
%
% \DescribeKey[fregdim]{line no width}\val{dimension}\AfterLastParam
% The maximum width of line numbers.
% By default, this is set to the width of the formatted line number \keyval{99}.
% \Example{line no width=20pt}
%
% \DescribeKey[fregdim]{just sep}\val{dimension}\AfterLastParam
% \Default{1.5em}
% Amount by which to shift justifications away from the tree.
% A larger value will shift the justifications further to the right, increasing their distance from the tree, while a smaller one will decrease this distance.
% Note that a negative value ought never be given.
% Although this will not cause an error, it may result in strange things happening.
% If you wish to decrease the distance between the tree and the justifications further, please set \keyname[fregdim]{just sep} to zero and use the options provided by \pkg{forest} and/or \TikZ{} to make further negative adjustments.
% \Example{just sep=.5em}
%
% \DescribeKey[fregdim]{line no sep}\val{dimension}\AfterLastParam
% \Default{1.5em}
% Amount by which to shift line numbers away from the tree.
% A larger value will shift the line numbers further to the left, increasing their distance from the tree, while a smaller one will decrease this distance.
% Note that a negative value ought never be given.
% Although this will not cause an error, it may result in strange things happening.
% If you wish to decrease the distance between the tree and the line numbers further, please set \keyname[fregdim]{line no sep} to zero and use the options provided by \pkg{forest} and/or \TikZ{} to make further negative adjustments.
% \Example{line no sep=5pt}
%
% \DescribeKey[fregdim]{close sep}\val{dimension}\AfterLastParam
% \Default{.75\cs{baselineskip}}
% Distance between the symbol marking branch closure and any following annotation.
% If the format of such annotations is changed with \keyname[fregkeylist]{close format}, this dimension may require adjustment.
% \Example{close sep=\cs{baselineskip}}
%
% \DescribeKey[fregdim]{proof tree inner proof width}\val{dimension}\AfterLastParam
% \Default{0pt}
%
% \DescribeKey[fregdim]{proof tree inner proof midpoint}\val{dimension}\AfterLastParam
% \Default{0pt}
% ^^A subsubsec:go-dims >>>
%
% \subsubsection{Line Numbers}\label{subsubsec:go-nos}
% ^^A subsubsec:go-nos <<<
%
% \DescribeKey[fregcount]{line no shift}\val{integer}\AfterLastParam
% \Default{0}
% This value increments or decrements the number used for the first line of the proof.
% By default, line numbering starts at \texttt{1}.
% \Example{line no shift=3} would begin numbering the lines at 4.
%
% \DescribeKey[fstyle]{zero start}
% Start line numbering from 0 rather than 1.
% The following are equivalent:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  zero start
  line no shift=-1
\end{latexcode}
% \iffalse
%</verb>
% \fi
% ^^A subsubsec:go-nos >>>
%
% \subsubsection{Proof Statement}\label{subsubsec:go-prove}
% ^^A subsubsec:go-prove <<<
%
% \DescribeKey[fstyle]{to prove}\val{wff}\AfterLastParam
% Statement of theorem or entailment to be typeset above the proof.
% In many cases, it will be necessary to enclose the statement in curly brackets.
% \Example{to prove=\arg{\cs{sststile}\arg{}\arg{} P \cs{lif} P}}
% By default, the content is expected to be suitable for typesetting in maths mode and should \emph{not}, therefore, be enclosed by dollar signs or equivalent.
% ^^A END subsubsec:go-prove >>>
%
% \subsubsection{Format}\label{subsubsec:go-format}
% ^^A subsubsec:go-format <<<
%
% \DescribeKey[fregtoks]{check with}\val{symbol}\AfterLastParam
% \Default{\cs{ensuremath}\arg{\cs{checkmark}} (\ensuremath{\checkmark})}
% Symbol with which to mark discharged lines.
% \Example{check with=\arg{\cs{text}\arg{\cs{ding}\arg{52}}}}
% Within the tree, \keyname[fstyle]{checked} is used to identify discharged lines.
%
% \DescribeKeys[fregbool]{check right, not check right}\vals{true,false}\AfterLastParam
% \Default{true}
% Determines whether the symbol indicating that a line is discharged should be placed to the right of the \wff{}.
% The alternative is, unsurprisingly, to place it to the left of the \wff{}.
% The following are equivalent to the default setting:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  check right
  check right=true
\end{latexcode}
% \iffalse
%</verb>
% \fi
% \DescribeKeys[fstyle]{check left}%
% Set \keyname[fregbool]{check right}\verb|=false|.
% The following are equivalent ways to place the markers to the left:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  check right=false
  not check right
  check left
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% \DescribeKey[fregtoks]{close with}\val{symbol}\AfterLastParam
% \Default{\cs{ensuremath}\arg{\cs{otimes}} (\ensuremath{\otimes})}
% Symbol with which to close branches.
% \Example{close with=\arg{\cs{ensuremath}\arg{\cs{ast}}}}
% Within the tree, \keyname[fstyle]{close} is used to identify closed branches.
%
% \DescribeKey[fregkeylist]{close with format}\val{key-value list}\AfterLastParam
% Additional \TikZ{} keys to apply to the closure symbol.
% Empty by default.
% \Example{close with format=\arg{red, font=\Huge}}
% To replace a previously set value, rather than adding to it, use \keyname[fregkeylist]{close with format\textquotesingle} rather than \keyname[fregkeylist]{close with format}.
%
% \DescribeKey[fregkeylist]{close format}\val{key-value list}\AfterLastParam
% \Default{font=\cs{scriptsize}}
% Additional \TikZ{} keys to apply to any annotation following closure of a branch.
% \Example{close format=\arg{font=\cs{footnotesize}\cs{sffamily}, text=gray!75}}
% To replace the default value of \keyname[fregkeylist]{close format}, rather than adding to it, use \keyname[fregkeylist]{close format\textquotesingle} rather than \keyname[fregkeylist]{close format}.
% \Example{close format\textquotesingle=\arg{text=red}} will produce red annotations in the default font size, whereas
% \Example{close format=\arg{text=red}} will produce red annotations in \verb|\scriptsize|.
%
% \DescribeKey[fregtoks]{subs with}\val{symbol}\AfterLastParam
% \Default{\cs{ensuremath}\arg{\cs{backslash}} (\ensuremath{\backslash})}
% Symbol to indicate variable substitution.
% \Example{\cs{text}\arg{:}}
% Within the tree, \keyname[fstyle]{subs} is used to indicate variable substitution.
%
% \DescribeKeys[fregbool]{subs right, not subs right}\vals{true,false}\AfterLastParam
% \Default{true}
% Determines whether variable substitution should be indicated to the right of the \wff{}.
% The alternative is, again, to place it to the left of the \wff{}.
% The following are equivalent to the default setting:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  subs right
  subs right=true
\end{latexcode}
% \iffalse
%</verb>
% \fi
% \DescribeKeys[fstyle]{subs left}%
% Set \keyname[fregbool]{subs right}\verb|=false|.
% The following are equivalent ways to place the annotations to the left:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  subs right=false
  not subs right
  subs left
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% \DescribeKeys[fregbool]{just refs left, not just refs left}\vals{true,false}\AfterLastParam
% \Default{true}
% Determines whether line number references should be placed to the left of justifications.
% The alternative is to place them to the right of justifications.
% The following are equivalent to the default setting:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  just refs left
  just refs left=true
\end{latexcode}
% \iffalse
%</verb>
% \fi
% \DescribeKeys[fstyle]{just refs right}%
% Set \keyname[fregbool]{just refs left}\verb|=false|.
% The following are equivalent ways to place the references to the right:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  just refs left=false
  not just refs left
  just refs right
\end{latexcode}
% \iffalse
%</verb>
% \fi
% Note that this setting \emph{only affects the placement of line numbers specified using the cross-referencing system} explained in \cref{subsec:lo}.
% Hard-coded line numbers in justifications will be typeset as is.
%
% \DescribeKey[fregkeylist]{just format}\val{key-value list}\AfterLastParam
% Additional \TikZ{} keys to apply to line justifications.
% Empty by default.
% \Example{just format=\arg{red, font=\itshape}}
% To replace a previously set value, rather than adding to it, use \keyname[fregkeylist]{just format\textquotesingle} rather than \keyname[fregkeylist]{just format}.
%
% \DescribeKey[fregkeylist]{line no format}\val{key-value list}\AfterLastParam
% Additional \TikZ{} keys to apply to line numbers.
% Empty by default.
% \Example{line no format=\arg{align=right, text=gray}}
% To replace a previously set value, rather than adding to it, use \keyname[fregkeylist]{line no format\textquotesingle} rather than \keyname[fregkeylist]{line no format}.
% To change the way the number itself is formatted --- to eliminate the dot, for example, or to put the number in brackets --- redefine \cs{linenumberstyle} (see \cref{sec:macros}).
%
% \DescribeKey[fregkeylist]{wff format}\val{key-value list}\AfterLastParam
% Additional \TikZ{} keys to apply to \wff s.
% Empty by default.
% \Example{wff format=\arg{draw=orange}}
% To replace a previously set value, rather than adding to it, use \keyname[fregkeylist]{wff format\textquotesingle} rather than \keyname[fregkeylist]{wff format}.
%
% \DescribeKey[fregkeylist]{proof statement format}\val{key-value list}\AfterLastParam
% Additional \TikZ{} keys to apply to the proof statement.
% Empty by default.
% \Example{proof statement format=\arg{text=gray, draw=gray}}
% To replace a previously set value, rather than adding to it, use \keyname[fregkeylist]{proof statement format\textquotesingle} rather than \keyname[fregkeylist]{proof statement format}.
%
% \DescribeKey[fregautotoks]{highlight format}\val{key-value list}\AfterLastParam
% \Default{draw=gray, rounded corners}
% Additional \TikZ{} keys to apply to highlighted \wff s.
% \Example{highlight format=\arg{text=red}}
% To apply highlighting, use the \keyname[foptbool]{highlight wff}, \keyname[foptbool]{highlight just}, \keyname[foptbool]{highlight line no} and/or \keyname[foptbool]{highlight line} keys (see \cref{subsec:lo}).
%
% \DescribeKey[fregtoks]{merge delimiter}\val{punctuation}\AfterLastParam
% \Default{\cs{text}\arg{; } (\text{; })}
% Punctuation to separate distinct justifications for a single proof line.
% Note that \pkg{prooftrees} will issue a warning if it detects different justifications for a single proof line and will suggest using \keyname[fstyle]{move by} to avoid the need for merging justifications.
% In general, justifications ought not be merged because it is then less clear to which \wff(s) each justification applies.
% Moreover, later references to the proof line will be similarly ambiguous.
% That is, \keyname[fregtoks]{merge delimiter} ought almost never be necessary because it is almost always better to restructure the proof to avoid ambiguity.
%
%^^A END subsubsec:go-format >>>
%^^A END subsec:go >>>
%
% \subsection{Local Options}\label{subsec:lo}
%^^A BEGIN subsec:lo <<<
%
% The following options affect the local structure or appearance of the tree and should typically be passed as options to the relevant node(s) within the tree.
%
% \DescribeKeys[foptbool]{grouped, not grouped}
% Indicate that a line is not an inference.
% When \keyname[fregbool]{single branches} is false, as it is with the default settings, this key is applied automatically and need not be given in the specification of the tree.
% When \keyname[fregbool]{single branches} is true, however, this key must be specified for any line which ought not be treated as an inference.
% \Example{grouped}
%
% \subsubsection{Annotations}\label{subsubsec:lo-annot}
% ^^A subsubsec:lo-annot <<<
% 
% \DescribeKey[fstyle]{checked}
% Mark a complex \wff{} as resolved, discharging the line.
% \Example{checked}
% \DescribeKey[fstyle]{checked}\val{name}\AfterLastParam
% Existential elimination, discharge by substituting \meta{name}.
% \Example{checked=a}
%
% \DescribeKey[fstyle]{close}
% Close branch.
% \Example{close}
% \DescribeKey[fstyle]{close}\val{annotation}\AfterLastParam
% \val{annotation prefix}\texttt{:}\meta{references}\AfterLastParam
% Close branch with annotation.
% In the simplest case, \meta{annotation} contains no colon and is typeset simply as it is.
% Any required references to other lines of the proof are assumed to be given explicitly.
% \Example{close=\arg{12,14}}
% If \meta{annotation} includes a colon, \pkg{prooftrees} assumes that it is of the form \meta{annotation prefix}\texttt{:}\meta{references}.
% In this case, the material prior to the colon should include material to be typeset before the line numbers and the material following the colon should consist of one or more references to other lines in the proof.
% In typical cases, no prefix will be required so that the colon will be the first character.
% In case there is a prefix, \pkg{prooftrees} will insert a space prior to the line numbers.
% \meta{references} may consist of either \pkg{forest} names (e.g.~given by \keyname*[fopttoks]{name}\val{name label} and then used as \meta{name label}) or \pkg{forest} relative node names (e.g.~\meta{nodewalk}) or a mixture.
% \Example{close=\arg{:negated conclusion}} where \verb|name=negated conclusion| was used to label an earlier proof line \verb|negated conclusion|.
% If multiple references are given, they should be separated by commas and either \meta{references} or the entire \meta{annotation} must be enclosed in curly brackets, as is usual for \TikZ{} and \pkg{forest} values containing commas.
% \Example{close=\arg{:!c,!uuu}}
%
% \DescribeKey[fstyle]{subs}\val{name}/\meta{names}\AfterLastParam
% Universal instantiation, instantiate with \meta{name} or \meta{names}.
% \Example{subs=\arg{a,b}}
%
% \DescribeKey[foptautotoks]{just}\val{justification}\AfterLastParam
% \val{justification prefix/suffix}\texttt{:}\meta{references}\AfterLastParam
% Justification for inference.
% This is typeset in text mode.
% Hence, mathematical expressions must be enclosed suitably in dollar signs or equivalent.
% In the simplest case, \meta{justification} contains no colon and is typeset simply as it is.
% Any required references to other lines of the proof are assumed to be given explicitly.
% \Example{just=3 \$\cs{lor}\$D}
% If \meta{justification} includes a colon, \pkg{prooftrees} assumes that it is of the form \meta{justification prefix/suffix}\texttt{:}\meta{references}.
% In this case, the material prior to the colon should include material to be typeset before or after the line numbers and the material following the colon should consist of one or more references to other lines in the proof.
% Whether the material prior to the colon is interpreted as a \meta{justification prefix} or a \meta{justification suffix} depends on the value of \keyname[fregbool]{just refs left}.
% \meta{references} may consist of either \pkg{forest} names (e.g.~given by \keyname*[fopttoks]{name}\val{name label} and then used as \meta{name label}) or \pkg{forest} relative node names (e.g.~\meta{nodewalk}) or a mixture.
% If multiple references are given, they should be separated by commas and \meta{references} must be enclosed in curly brackets.
% If \keyname[fregbool]{just refs left} is true, as it is by default, then the appropriate line number(s) will be typeset before the \meta{justification suffix}.
% \Example{just=\$\cs{lnot}\cs{exists}\$\cs{elim}:\arg{!uu,!u}}
% If \keyname[fregbool]{just refs left} is false, then the appropriate line number(s) will be typeset after the \meta{justification prefix}.
% \Example{just=From:bertha}
% ^^A subsubsec:lo-annot >>>
%
% \subsubsection{Moving}\label{subsubsec:lo-move}
% ^^A subsubsec:lo-move <<<
%
% \DescribeKey[fstyle]{move by}\val{positive integer}\AfterLastParam
% Move the content of the current line \meta{positive integer} lines later in the proof.
% If the current line has a justification and the content is moved, the justification will be moved with the line.
% Later lines in the same branch will be moved appropriately, along with their justifications.
% \Example{move by=3}
% Note that, in many cases, \pkg{prooftrees} will automatically move lines later in the proof.
% It does this when it detects a condition in which it expects conflicting justifications may be required for a line while initially parsing the tree.
% Essentially, \pkg{prooftrees} tries to detect cases in which a branch is followed closely by asymmetry in the structure of the branches.
% This happens, for example, when the first branch's first \wff{} is followed by a single \wff{}, while the second branch's first \wff{} is followed by another branch.
% Diagrammatically:
% \begin{center}
%   \forestset{declare boolean={go iawn}{1}}
%   \begin{forest}
%     for root={%
%       shape=coordinate,
%       for children={%
%         shape=coordinate,
%         no edge
%       },
%     },
%     for tree={%
%       delay={content={\wff}},
%       if level=3{WildStrawberry}{},
%       if level=2{edge={densely dashed},not go iawn}{},
%       parent anchor=children,
%       child anchor=parent,
%     },
%     before computing xy={%
%       where={n_children()==1}{%
%         for children={%
%           if go iawn={%
%             l=\baselineskip, no edge,
%           }{},
%         },
%       }{},
%     }
%     [
%       [[[[]][[][]]]]
%       [[[[[[,edge={densely dashed}, shape=coordinate, not go iawn, before drawing tree={for tree={fill=none, content={}, typeset node}}[,edge={densely dashed,-{Stealth[]}}, not go iawn]]]]][[][]]]]
%     ]
%   \end{forest}
% \end{center}
% In this case, \pkg{prooftrees} tries to adjust the tree by moving lines appropriately if required.
%
% However, this detection is merely structural --- \pkg{prooftrees} does not examine the content of the \wff s or justifications for this purpose.
% Nor does it look for slightly more distant structural asymmetries, conflicting justifications in the absence of structural asymmetry or potential conflicts with justifications for lines in other, more distant parallel branches.
% Although it is not that difficult to detect the \emph{need} to move lines in a greater proportion of cases, the problem lies in providing general rules for deciding \emph{how} to resolve such conflicts.
% (Indeed, some such conflicts might be better left unresolved e.g.~to fit a proof on a single Beamer slide.)
% In these cases, a human must tell \pkg{prooftrees} if something should be moved, what should be moved and how far it should be moved.
%
% Because simple cases are automatically detected, it is best to typeset the proof before deciding whether or where to use this option since \pkg{prooftrees} will assume that this option specifies movements which are required \emph{in addition to} those it automatically detects.
% Attempting to move a line ‘too far’ is not advisable.
% \pkg{prooftrees} tries to simply ignore such instructions, but the results are likely to be unpredictable.
%
% Not moving a line far enough --- or failing to move a line at all --- may result in the content of one justification being combined with that of another.
% This happens if \keyname[foptautotoks]{just} is specified more than once for the same proof line with differing content.
% \pkg{prooftrees} \emph{does} examine the content of justifications for \emph{this} purpose.
% When conflicting justifications are detected for the same proof line, the justifications are merged and a warning issued suggesting the use of \keyname[fstyle]{move by}.
% ^^A subsubsec:lo-move >>>
%
% \subsubsection{Format: \wff{}, justification \& line number}\label{subsubsec:lo-format}
% ^^A subsubsec:lo-format <<<
%
% \DescribeKeys[foptbool]{highlight wff, not hightlight wff}
% Highlight \wff{}.
% \Example{highlight wff}
%
% \DescribeKeys[foptbool]{highlight just, not hightlight just}
% Highlight justification.
% \Example{highlight just}
%
% \DescribeKeys[foptbool]{highlight line no, not highlight line no}
% Highlight line number.
% \Example{highlight line no}
%
% \DescribeKeys[foptbool]{highlight line, not highlight line}
% Highlight proof line.
% \Example{highlight line}
%
% \DescribeKey[foptautotoks]{line no options}\val{key-value list}\AfterLastParam
% Additional \TikZ{} keys to apply to the line number for this line.
% \Example{line no options=\arg{blue}}
%
% \DescribeKey[foptautotoks]{just options}\val{key-value list}\AfterLastParam
% Additional \TikZ{} keys to apply to the justification for this line.
% \Example{just options=\arg{draw, font=\cs{bfseries}}}
%
% \DescribeKey[foptautotoks]{wff options}\val{key-value list}\AfterLastParam
% Additional \TikZ{} keys to apply to the \wff{} for this line.
% \Example{wff options=\arg{magenta, draw}}
% Note that this key is provided primarily for symmetry as it is faster to simply give the options directly to \pkg{forest} to pass on to \TikZ{}.
% Unless \keyname[fregkeylist]{wff format} is set to a non-default value, the following are equivalent:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  wff options={magenta, draw}
  magenta, draw
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% \DescribeKey[foptautotoks]{line options}\val{key-value list}\AfterLastParam
% Additional \TikZ{} keys to apply to this proof line.
% \Example{line options=\arg{draw, rounded corners}}
%
% \DescribeKey[fstyle]{line no override}\val{text}\AfterLastParam
% Substitute \meta{text} for the programmatically-assigned line number.
% \meta{text} will be wrapped by \keyname[macro]{\cs{linenumberstyle}}, so should not be anything which would not make sense in that context.
% \Example{line no override=\arg{n}}
%
% \DescribeKey[fstyle]{no line no}
% Do not typeset a line number for this line.
% Intended for use in trees where \keyname[foptbool]{line numbering} is activated, but some particular line should not have its number typeset.
% Note that the number for the line is still assigned and the node which would otherwise contain that number is still typeset.
% If the next line is automatically numbered, the line numbering will, therefore, ‘jump’, skipping the omitted number.
% \Example{no line no}
%
%^^A END subsubsec:lo-format >>>
%^^A END subsec:lo >>>
%^^A END sec:ops >>>
%
% \section{Macros}\label{sec:macros}
%^^A BEGIN sec:macros <<<
%
% \DescribeMacro{\linenumberstyle}\marg{number}\AfterLastParam
% This macro is responsible for formatting the line numbers.
% The default definition is
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  \newcommand*\linenumberstyle[1]{#1.}
\end{latexcode}
% \iffalse
%</verb>
% \fi
% It may be redefined with \cs{renewcommand*} in the usual way.
% For example, if for some reason you would like bold line numbers, try
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  \renewcommand*\linenumberstyle[1]{\textbf{#1.}}
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
%^^A END sec:macros >>>
%
% \section{Extras}\label{sec:ychwanegol}
% ^^A sec:ychwanegol <<<
%
% \subsection{Steps}\label{subsec:camau}
% ^^A subsec:camau <<<
%
% \DescribeKey[flstep]{every wff}
% A nodewalk long step which visits the proof statement and every \wff{} exactly once in proof line number order.
% This is the default order used for tagging the tableau, but may be used for other purposes.
% As with the next step, this one should be used in \keyname[foptkeylist]{before annotating} or similar.
%
% \DescribeKey[flstep]{wff from proof line no to}\marg{start}\marg{end}\AfterLastParam
% A long step which visits all \wffs{} between proof lines numbered \meta{start} and \marg{end} inclusive.
% \meta{start} and \meta{end} must be proof line numbers in the tableau.
%
% \textbf{This step cannot be used until quite late in the tableau's processing, as it is valid only once line numbers have been assigned.}
% Hence use of this step must always be delayed.
% For example, to colour the \wffs{} in lines 3, 4 and 5 blue, you could add the following to the preamble:
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
before annotating={for nodewalk={wffs from proof line no to={3}{5}}{blue,typeset node}},
\end{latexcode}
% \iffalse
%</verb>
% \fi
% Note the use of \texttt{typeset node} to re-typeset the content. 
% Without this option, the colour would have no effect.
% ^^A subsec:camau >>>
%
% \subsection{Fit}\label{subsec:fit}
% ^^A subsec:fit <<<
%
% \DescribeKey[fstyle]{nodewalk to node}\val{name}\marg{nodewalk}\AfterLastParam
% A simple wrapper around \pkg{forest}'s \keyname[fstyle]{fit to}, which is a \TikZ{} key used to create a node fitted around a nodewalk using the \TikZ{} \pkg{fit} library.
% This does not depend on the code used for tableaux and may be used in an ordinary \env{forest} environment.
% (But do not load \pkg{prooftrees} just for this!)
%
% For example, adding the following to a tableau's preamble would create a node named \texttt{a} around all the \wffs{} in lines \texttt{4} to \texttt{7} inclusive.
% Note that this does not include the line number or justification, if used, but only the \wffs{} in the ‘main’ part of the proof.
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
  nodewalk to node={a}{wffs from proof line no to={4}{7}},
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% \DescribeKeys[fstylewrap]{nodewalk node, nodewalk node+, +nodewalk node, nodewalk node\textquotesingle}\val{key-value list}\AfterLastParam
% \Default{inner sep=0pt}
% Style applied to any \TikZ{} nodes created using \keyname[fstyle]{nodewalk to node}.
% The versions with \texttt{+} prepend/append to the existing style, while the \texttt{\textquotesingle} version replaces it.
% \texttt{nodewalk node} is aliased to \texttt{nodewalk node+}.
% \Example{nodewalk node=\{draw=magenta,rounded corners\},}
% This would cause the options \texttt{inner sep=0pt,draw=magenta,rounded corners} to be applied to any nodes created by \keyname[fstyle]{nodewalk to node}.
%
% Note that, despite any similarity in syntax, these are not \pkg{forest} options or registers, but just code wrappers around a simple \TikZ{} style. 
% ^^A subsec:fit >>>
% ^^A sec:ychwanegol >>>
%
% \section{Advanced Configuration}\label{sec:keylists}
% ^^A sec:keylists <<<
%
% \pkg{forest}'s default \foptkeylistlabelname{} options may be used to customise tableaux if the provided options prove insufficient.
% In versions 0.9 and earlier, great care must be taken to avoid conflicts with \pkg{prooftrees}'s use of these lists.
% In later versions, internal versions are reserved for \pkg{prooftrees}'s use, enabling \pkg{forest}'s to be used more freely by the user.
% Note that you should still avoid changing the basic structure of the proof.
% For example, deleting extant justifications or line numbers (as opposed to modifying their content or options), would end badly.
%
% See \cref{sec:manylion} for details of the typesetting process.
%
% \DescribeKey[foptkeylist]{before making annotations}\val{key-value list}\AfterLastParam
% This \foptkeylistlabelname{} allows customisation after node positions are first computed by \pkg{forest} but before annotations are created.
% This is sometimes useful.
%
% \DescribeKey[foptkeylist]{before annotating}\val{key-value list}\AfterLastParam
% This \foptkeylistlabelname{} allows customisation after annotations are created, but before they are attached to their corresponding \wffs{}.
% I do not know if this option is useful or not.
%
% The remaining options in this section are applicable only if tagging is active.
%
% \DescribeKey[foptkeylist]{before copying content}\val{key-value list}\AfterLastParam
% Only relevant if tagging is active.
% This \foptkeylistlabelname{} allows the content of a node to be altered before it is copied for tagging.
% Changes made after \keyname[foptkeylist]{proof tree copy content} will affect only the visual representation.
% \Example{P \cs{supset} Q, before copying content=\{content+=\{*\}\}, before typesetting nodes=\{blue\},}
% This would include the \texttt{*} into the content of the node used for tagging, but not the colouration.
%
% \DescribeKey[foptkeylist]{before making tags}\val{key-value list}\AfterLastParam
% Only relevant if tagging is active (see \cref{sec:tag}).
% Allow changes before tagged content for a node is finalised.
% This \foptkeylistlabelname{} is processed before annotations are added to a node's tagged content.
% \Example{P \cs{supset} Q, before making tags=\{ttoks'=\{P horseshoe Q\},\},}
% This would replace \verb|P \supset Q| with \texttt{P horseshoe Q} in the content used for tagging\footnote{%
%   This is not the best way to handle the horseshoe, however.
%   It would be better to define a dedicated macro to produce the symbol such as \cs{horseshoe} and assign an appropriate ‘output intent’, regardless of whether you choose to override the content in tagging.%
% }.
% 
% \DescribeKey[foptkeylist]{before getting tags}\val{key-value list}\AfterLastParam
% Only relevant if tagging is active (see \cref{sec:tag}).
% This \foptkeylistlabelname{} is processed after annotations are added to a node's tagged content, but before that content is used for tagging.
% \Example{P \cs{supset} Q, just=Ass, before getting tags=\{ttoks'=\{P horseshoe Q\},\}}
% This would prevent \texttt{Ass} from being used in the tagged content.
% Note that it would also lose any line number, so this should be added explicitly if required.
%
%^^A END sec:keylists >>>
%
% \section{Memoization}\label{sec:memoize}
%^^A BEGIN sec:memoize <<<
%
% Tableaux created by \pkg{prooftrees} cannot, in general, be externalised with \TikZ's \keyname[pkg]{\pkg{external}} library.
% Since \keyname[pkg]{\pkg{pgf}}/\TikZ{}, in general, and \pkg{prooftrees}, in particular, can be rather slow to compile, this is a serious issue.
% If you only have a two or three small tableaux, the compilation time will be negligible.
% But if you have large, complex proofs or many smaller ones, compilation time will quickly become excessive.
%
% Version 0.9 does not cure the disease, but it does offer an extremely effective remedy for the condition.
% While it does not make \pkg{prooftrees} any faster, it supports the \keyname[pkg]{\pkg{memoize}} package developed by \pkg{forest}'s author, Sašo Živanović \autocite*{saso-memoize-manual}.
% Memoization is faster, more secure, more robust and easier to use than \TikZ's externalisation.
% \begin{description}
%   \item[It is faster.] It does not require separate compilations for each memoized object, so it is comparatively fast even when memoizing.
%   \item[It is more secure.] It requires only restricted shell-escape, which almost all \TeX{} installations enable by default, so it is considerably more secure and can be utilised even where shell-escape is disabled.
%   \item[It is more robust.] It can successfully memoize code which defeats all ordinary mortals' attempts to externalize with the older \TikZ{} library.
%   \item[It is easier to use.] It requires less configuration and less intervention.
%   For example, it detects problematic code and aborts memoization automatically in many cases in which \TikZ's \pkg{external} would either cause a compilation error or silently produce nonsense output, forcing the user to manually disable the process for relevant code.
% \end{description}
%
% There is always a ‘but’, but this is a pretty small ‘but’ as ‘but’s go.
% \begin{description}
%   \item[But installation requires slightly more work.] To reap the full benefits, you want to use either the \texttt{perl} or the \texttt{python} ‘extraction’ method.
%   There is a third method, which does not require any special installation, but this lacks several of the advantages explained above and is not recommended.
%
%   If you use \TeX{} Live, you have \texttt{perl} already, but you may need to install a couple of libraries.
%   \texttt{python} is not a prerequisite for \TeX{} Live but, if you happen to have it installed, you will probably only need an additional library to use this method.
%
%   See \citetitle{saso-memoize-manual} \autocite{saso-memoize-manual} for further details.
% \end{description}
%
% Once you have the prerequisites setup, all you need do is load \pkg{memoize} \emph{before} \pkg{prooftrees}.
%
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
\usepackage[extraction method=perl]{memoize}% or python
\usepackage{prooftrees}
\end{latexcode}
% \iffalse
%</verb>
% \fi
%
% After a single compilation, your document will have expanded to include extra pages.
% At this point, it will look pretty weird.
% After the next compilation, your document will return to its normal self, the only difference being the speed with which it does so as all your memoized tableaux will simply be included, as opposed to recompiled.
% Only when you alter the code for a tableau, delete the generated files, disable memoization or explicitly request it will the proof be recompiled.
%
% Memoization is compatible with both \pkg{prooftrees}'s cross-referencing system and \LaTeXe's cross-references, but the latter require an additional compilation.
% In general, if a document element takes $n$ compilations to stabilise, it will take $n+1$ compilations to complete the memoization process.
% See \citetitle{saso-memoize-manual} \autocite{saso-memoize-manual} for details.
%
%^^A END sec:memoize >>>
%
% \iffalse
% \section{Tagging}\label{sec:tag}
% ^^A sec:tag <<<
%
% See also \cref{sec:keylists}.
% Most options here are global and fairly straightforward.
%
% \subsection{Global Tagging Options}\label{subsec:tag-go}
% ^^A subsec:tag-go <<<
%
% \DescribeKey[fregbool]{tag}\vals{true,false}\AfterLastParam
% \Default{\texttt{true} {\normalfont if tagging is active; otherwise} \texttt{false}}
% Whether to tag the tableau or not.
% This register should not generally be set by the user, as \pkg{prooftrees} adjusts it automatically.
% However, it might be useful in exceptional cases.
% 
% \DescribeKey[fregtoks]{plug}\texttt{alt}\AfterLastParam
% \Default{alt}
% The only choice with package-specific support is currently \texttt{alt}.
% Use of \pkg{latex-lab}'s plugs for \pkg{tikz} will yield chaotic results at best, but more likely invalid structures or compilation errors.
% If you need something other than the current \texttt{alt}, file a feature request.
% 
% \DescribeKey[fregtoks]{tag check with}\val{text}\AfterLastParam
% \Default{discharged}
% Text replacement for \keyname[fregtoks]{check with} for tagging.
% 
% \DescribeKey[fregtoks]{tag close with}\val{text}\AfterLastParam
% \Default{closed}
% Text replacement for \keyname[fregtoks]{close with} for tagging.
% 
% \DescribeKey[fregtoks]{tag subs with}\val{text}\AfterLastParam
% \Default{substituted}
% Text replacement for \keyname[fregtoks]{subs with} for tagging.
% 
% \DescribeKey[fregtoks]{tag to prove}\val{text}\AfterLastParam
% \Default{To prove: }
% Text to prepend to the proof statement when tagging.
% ^^A subsec:tag-go >>>
% 
% \subsection{Local Tagging Options}\label{subsec:tag-lo}
% ^^A subsec:tag-lo <<<
%
% \DescribeKey[fopttoks]{ttoks}\val{text}\AfterLastParam
% \texttt{ttoks} stores the content used to tag the proof statement and each \wff{} in the tableau.
% \pkg{prooftrees} creates this content automatically from either the proof statement given to {to prove} or the content of the \wff{}.
% Additional content is appended or prepended when \keyname[fstyle]{checked}, \keyname[fstyle]{close}, \keyname[fstyle]{subs} and/or \keyname[foptautotoks]{just} are used.
% If applicable, a line number is also added.
% 
% The content used for tagging the node may be supplemented or entirely overridden by the user at any stage, but direct use of the option must be delayed in order for the changes to be effective. 
% \Example{P \cs{equiv} Q, just=Ass, before getting tags=\{ttoks\textquotesingle=\{P iff Q (Premise)\},\}, checked,}
% This would use precisely the specified content when tagging i.e.~the checked marker, justification and any line number would be omitted.
% \Example{P \cs{equiv} Q, just=Ass, before making tags=\{ttoks\textquotesingle=\{P iff Q (Premise)\},\}, checked,}
% The would use the specified content, together with the line number and justification, but would omit the checked marker.
%
% See \cref{sec:keylists,sec:manylion}.
% ^^A subsec:tag-lo >>>
% ^^A sec:tag >>>
% \fi
%
% \section{Typesetting Process}\label{sec:manylion}
% ^^A sec:manylion <<<
%
% This section provides a high-level description of the process \env{prooftree}/\env{tableau} uses to construct and typeset a proof.
% Further details can be found in the code documentation.
%
% \textbf{Most uses of \pkg{prooftrees} do not require knowledge --- or, even, awareness of --- the details described in this section.}
% Indeed, earlier versions of the documentation did not include this section at all.
% The details may be of use to users who wish to modify tableaux in ways unsupported by the features documented in previous sections.
%
% \begin{enumerate}
%   \item Increment a count and determine whether to tag the tableau.
%   \item Initialise tagging, if applicable.
%     This is largely a matter of setting \pkg{latex-lab}'s plug for \pkg{tikz} to \texttt{artifact}.
%     This is necessary because a \pkg{forest} tree involves \emph{many} uses of \env{tikzpicture} and the default tagging can result in erroneous structures and/or compilation errors and produces at best chaotic \texttt{marked content}.
%   \item\label{enum:stages} Starts \env{forest} with a custom definition of \keyname[foptkeylist]{stages}.
% Any \foptkeylistshortname{} prefixed with \texttt{proof tree} is used internally by \pkg{prooftrees} to process the tableau.
% \keyname[fstyle]{tag tableau stage} executes the code actually responsible for tagging the proof. 
% Any \foptkeylistshortname{} described as ‘Does nothing by default.’ is explicitly intended for users to customise the process.
% See \cref{sec:keylists} for details.
%
% Here is a (long!) step-by-step description of \pkg{prooftrees}'s redefinition of \texttt{stages}.
%     \begin{enumerate}[label={Stage \arabic*},align=left,leftmargin=*,widest=99]
%       \item Execute the standard \pkg{forest} parsing for the \keyname[fregkeylist]{default preamble} and \keyname[fregkeylist]{preamble} with
% \iffalse
%<*verb>
% \fi
\begin{latexcode}
for root'={%
  process keylist register=default preamble,
  process keylist register=preamble,
},
\end{latexcode}
% \iffalse
%</verb>
% \fi
%       \item Process the \pkg{forest} \foptkeylistshortname{} \keyname[foptkeylist]{given options}.
%       \item Process the \foptkeylistshortname{} \keyname[foptkeylist]{before copying content}.
%         Does nothing by default.
%       \item Process the \foptkeylistshortname{}  \keyname[foptkeylist]{proof tree copy content}.
%         Does nothing unless tagging.
%       \item Process the \foptkeylistshortname{}  \keyname[foptkeylist]{proof tree after copying content}.
%       \item Process the \foptkeylistshortname{}  \keyname[foptkeylist]{proof tree before typesetting nodes}.
%       \item Process the \pkg{forest} \foptkeylistshortname{} \keyname[foptkeylist]{before typesetting nodes}.
%       \item Process  the \foptkeylistshortname{} \keyname[foptkeylist]{proof tree ffurf}.
%       \item Process  the \foptkeylistshortname{} \keyname[foptkeylist]{proof tree symud awto}.
%       \item Execute \pkg{forest}'s \keyname[fstyle]{typeset nodes stage}.
%       \item Process the \foptkeylistshortname{} \keyname[foptkeylist]{proof tree before packing}.
%       \item Process the \pkg{forest} \foptkeylistshortname{} \keyname[foptkeylist]{before packing}.
%       \item Execute \pkg{forest}'s \keyname[fstyle]{pack stage}.
%       \item Process the \foptkeylistshortname{} \keyname[foptkeylist]{proof tree before computing xy}.
%       \item Process the \pkg{forest} \foptkeylistshortname{} \keyname[foptkeylist]{before computing xy}.
%       \item Execute \pkg{forest}'s \keyname[fstyle]{compute xy stage}.
%       \item Process the \foptkeylistshortname{} \keyname[foptkeylist]{before making annotations}.
%         Does nothing unless by default.
%       \item Process the \foptkeylistshortname{} \keyname[foptkeylist]{proof tree creu nodiadau}.
%       \item Process the \foptkeylistshortname{} \keyname[foptkeylist]{before annotating}.
%         Does nothing unless by default.
%       \item Process the \foptkeylistshortname{} \keyname[foptkeylist]{proof tree nodiadau}.
%       \item Process the \foptkeylistshortname{} \keyname[foptkeylist]{proof tree before drawing tree}.
%       \item Process the \pkg{forest} \foptkeylistshortname{} \keyname[foptkeylist]{before drawing tree}.
%       \item Process the \foptkeylistshortname{} \keyname[foptkeylist]{before making tags}.
%         Does nothing unless by default.
%       \item Process the \foptkeylistshortname{} \keyname[foptkeylist]{proof tree make tags}.
%         Does nothing unless tagging.
%       \item Process the \foptkeylistshortname{} \keyname[foptkeylist]{before getting tags}.
%         Does nothing unless by default.
%       \item Process the \foptkeylistshortname{} \keyname[foptkeylist]{proof tree get tags}.
%         Does nothing unless tagging.
%       \item Execute \keyname[fstyle]{tag tableau stage}.
%         Does nothing unless tagging.
%       \item Execute \pkg{forest}'s \keyname[fstyle]{draw tree stage}.
%     \end{enumerate}
%   \item Applies \fstyleshortname{} \keyname[fstyle]{proof tree}.
%     \textbf{This style should NOT be used directly.}
%   \item Applies \fstyleshortname{} \keyname[fstyle]{ttableau}.
%     This does nothing unless tagging is enabled.
%     \textbf{This style should NOT be used directly.}
%   \item Executes the content of \env{prooftree}/\env{tableau}'s mandatory argument.
%   \item Creates a root node with \keyname[fopttoks]{name}\val{proof statement}.
%   \item Integrates the contents of the \env{prooftree}/\env{tableau}.
% \end{enumerate}
%
% Note that \pkg{prooftrees} sets \pkg{forest}'s \keyname[fbracketkey]{action character} to \verb|@| before defining the \env{prooftree}/\env{tableau} environment.
% ^^A sec:manylion >>>
%
% \section{Compatibility}\label{sec:compat}
%^^A BEGIN sec:compat <<<
%
% Versions of \pkg{prooftrees} prior to 0.5 are incompatible with \pkg{bussproofs}, which also defines a \env{prooftree} environment.
% Version 0.6 is compatible with \env{bussproofs} provided
% \begin{description}[font=\itshape]
%   \item[either] \pkg{bussproofs} is loaded \emph{before} \pkg{prooftrees}
%   \item[or] \pkg{prooftrees} is loaded with option \option{tableaux} (see \cref{sec:llwytho}).
% \end{description}
% In either case, \pkg{prooftrees} will \emph{not} define a \env{prooftree} environment, but will instead define \env{tableau}.
% This allows you to use \env{tableau} for \pkg{prooftrees} trees and \env{prooftree} for \pkg{bussproofs} trees.
%
%^^A END sec:compat >>>
%
% \changes{v0.8}{}{Documentation now loads \pkg{enumitem}, since it depended on it already anyway and specifies \pkg{doc2} in options for \cls{ltxdoc} as the code is incompatible with the current version.}
%
%
% \printbibliography
%
% ^^A \loadgeometry{safonol}%
% ^^A \fancyheadoffset[lh]{0pt}%
% 
% \changes{v0.9.1}{2025-08-20}{Switch to \pkg{docstrip}.}
% \changes{v0.9}{0001-01-01}{Use \cs{NewDocumentEnvironment}, removing direct dependency on \pkg{environ}.}
% \changes{v0.8}{0001-01-01}{Add previously unnoticed dependency on \pkg{amstext}.}
% \changes{v0.8}{0001-01-01}{Attempt to fix straying closure symbols evident in documentation and a \TeX\ SE question (\url{https://tex.stackexchange.com/q/619314/}).}
% \changes{v0.7}{0001-01-01}{Fix bug reported at \href{https://tex.stackexchange.com/q/479263/39222}{tex.stackexchange.com/q/479263/39222}.}
% \changes{v0.5}{0001-01-01}{Significant re-implementation leveraging the new argument processing facilities in \pkg{forest} 2.1.
% This significantly improves performance as the code is executed much faster than the previous \pkg{pgfmath} implementation.}
% \changes{v0.41}{0001-01-01}{Update for compatibility with \pkg{forest} 2.1.}
% \changes{v0.4}{0001-01-01}{Bug fix release:
%   \texttt{forest} count register \texttt{line no shift} was broken;
%   in some cases, an edge was drawn where no edge belonged.%
% }
% \changes{v0.3}{0001-01-01}{First CTAN release.}
% 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% \StopEventually{%^^A \MaybeStop is v3 
%   \def\glossaryname{Change History}%^^A
%   \PrintChanges
%   \PrintIndex
% }
% 
% \section{Implementation}\label{sec:imp}
%
% ^^A if I'd known what doctools did, I'd never have used it in the first place
% ^^A \let\environment\docenvironment
% ^^A \let\endenvironment\enddocenvironment
% \let\macrocode\docmacrocode
% \let\endmacrocode\enddocmacrocode
% \let\macro\docmacro
% \let\endmacro\enddocmacro
%
%^^A sty guards <<<
% \iffalse
%<*sty>
% \fi
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{svn-prov}
%<!debug&!tag>\ProvidesPackageSVN[\filebase.sty]{$Id: prooftrees.dtx 11204 2025-09-04 03:23:15Z cfrees $}[v0.9.1 \revinfo]
%<debug>\ProvidesPackageSVN[\filebase-debug.sty]{$Id: prooftrees.dtx 11204 2025-09-04 03:23:15Z cfrees $}[v0.9.1 \revinfo\ (debugging)]
\DefineFileInfoSVN
%    \end{macrocode}
% \iffalse
% ^^A Paid â defnyddio \GetFileInfoSVN*/\GetFileInfoSVN{} yn y fan hon!!
% \fi
% \iffalse
%<*!debug>
% \fi
% \begin{macro}{\prooftrees@enw}
% Define \cs{prooftrees@enw} to hold the name of the environment.
%
% Default is to name the environment prooftree, this ensures backwards compatibility.
%    \begin{macrocode}
\newcommand*\prooftrees@enw{prooftree}
%    \end{macrocode}
% \end{macro}
% ^^A \begin{opt}{tableaux,tableau}
% Allow users to change the name to tableau using tableaux.
%    \begin{macrocode}
\DeclareOption{tableaux}{\renewcommand*\prooftrees@enw{tableau}}
%    \end{macrocode}
% Just in case.
%    \begin{macrocode}
\DeclareOption{tableau}{\renewcommand*\prooftrees@enw{tableau}}
%    \end{macrocode}
% ^^A \end{opt}
%    \begin{macrocode}
\DeclareOption*{\PassOptionsToPackage{\CurrentOption}{forest}}
%    \end{macrocode}
% If \cs{prooftree} is not yet defined, set the name to \texttt{prooftree}; otherwise, use \texttt{tableau} to avoid conflict with \pkg{bussproofs} (which uses \texttt{prooftree} rather than \texttt{bussproof} as one might expect).
%
% Is there some reason I didn't use a hook here? obviously hooks weren't a thing, but \cs{AtBeginDocument}?
% Oh, I guess I can't \dots.
%    \begin{macrocode}
\ifcsname prooftree\endcsname
  \renewcommand*\prooftrees@enw{tableau}%
\else
  \renewcommand*\prooftrees@enw{prooftree}%
\fi
%    \end{macrocode}
% ^^A \ifundef\prooftree{\renewcommand*\prooftrees@enw{prooftree}}{\renewcommand*\prooftrees@enw{tableau}}
% Let users override the default \texttt{prooftree} in case they need to load \pkg{bussproofs} later.
%    \begin{macrocode}
\ProcessOptions
%    \end{macrocode}
% \changes{v0.9.1}{2025-08-27}{Don't load \pkg{amssymb} or \pkg{amstext} unconditionally.}
% Load \pkg{forest}, but load maths packages later only if needed.
%    \begin{macrocode}
\RequirePackage{forest}[2016/12/04]
%    \end{macrocode}
% \begin{macro}{\linenumberstyle}
%   \mbox{}
%    \begin{macrocode}
\newcommand*\linenumberstyle[1]{#1.}
%    \end{macrocode}
% \end{macro}
% \changes{v0.9.1}{2025-08-25}{Added for tagging experiments.}
% How am I meant to describe these things when they aren't macros or environments?!
%    \begin{macrocode}
\newtoks\prooftrees@tableau@toks
%    \end{macrocode}
% Currently, keys starting \texttt{proof tree} or \texttt{tableau} and macros starting \texttt{prooftree} or \texttt{prooftree@} are intended for internal use only.
%
% This does not apply to the environment \texttt{prooftree}.
%
% Other keys and macros are intended for use in documents.
%
% \textbf{In particular, the style \texttt{proof tree} is **NOT** intended to be used directly by the user and its direct use is **ABSOLUTELY NOT SUPPORTED IN ANY WAY, SHAPE OR FORM**; it is intended only for implicit use when the \texttt{prooftree} environment calls it.}
%
% Don't use \texttt{@} in register/option names - the documentation is lying when it says non-alphanumerics will be converted to underscores when forming pgfmath functions ;)
% \iffalse
%</!debug>
% \fi
%    \begin{macrocode}
\forestset{% 
%    \end{macrocode}
% \iffalse
%<*!debug>
% \fi
% Line numbers
%    \begin{macrocode}
  declare boolean register={line numbering},
%    \end{macrocode}
% Default is for line numbers
%    \begin{macrocode}
  line numbering,
%    \end{macrocode}
% Line justifications
%    \begin{macrocode}
  declare boolean register={justifications},
%    \end{macrocode}
% Default is for no line justifications (b/c there's no point in enabling this if the user doesn't specify any content)
%    \begin{macrocode}
  not justifications,
%    \end{macrocode}
% Single branches: explicitly drawn branches and a normal level distance between lone children and their parents
%    \begin{macrocode}
  declare boolean register={single branches},
%    \end{macrocode}
% Default is for lone children to be grouped with their parents
%    \begin{macrocode}
  not single branches,
%    \end{macrocode}
%    \begin{macrocode}
  declare boolean register={auto move},% ble mae'n bosibl, symud pethau'n awtomatig
%    \end{macrocode}
% Default: symud yn awtomatig
%    \begin{macrocode}
  auto move,
%    \end{macrocode}
% Default will be set to the width of 99 wrapped in the line numbering style
%    \begin{macrocode}
  declare dimen register={line no width},
%    \end{macrocode}
% Fallback default is 0pt
%    \begin{macrocode}
  line no width'=0pt,
%    \end{macrocode}
% Amount by which to shift justifications away from the main tree
%    \begin{macrocode}
  declare dimen register={just sep},
%    \end{macrocode}
% Default is 1.5em
%    \begin{macrocode}
  just sep'=1.5em,
%    \end{macrocode}
% Distance of justifications from centre of inner tree; overrides just sep
%    \begin{macrocode}
  declare dimen register={just dist},
  just dist'=0pt,
%    \end{macrocode}
% Amount by which to shift line numbers away from the main tree
%    \begin{macrocode}
  declare dimen register={line no sep},
  line no sep'=1.5em,
%    \end{macrocode}
% Distance of line nos. from centre of inner tree; overrides line no sep
%    \begin{macrocode}
  declare dimen register={line no dist},
  line no dist'=0pt,
%    \end{macrocode}
% Distance between closure symbols and any following annotation
%    \begin{macrocode}
  declare dimen register={close sep},
  close sep'=.75\baselineskip,
  declare dimen register={proof tree line no x},
  proof tree line no x'=0pt,
  declare dimen register={proof tree justification x},
  proof tree justification x'=0pt,
  declare dimen register={proof tree inner proof width},
  proof tree inner proof width'=0pt,
  declare dimen register={proof tree inner proof midpoint},
  proof tree inner proof midpoint'=0pt,
%    \end{macrocode}
% Count the levels in the proof tree
%    \begin{macrocode}
  declare count register={proof tree rhif lefelau},
  proof tree rhif lefelau'=0,
%    \end{macrocode}
% Count the line numbers (on the left)
%    \begin{macrocode}
  declare count register={proof tree lcount},
  proof tree lcount'=0,
%    \end{macrocode}
% Count the justifications (on the right)
%    \begin{macrocode}
  declare count register={proof tree jcount},
  proof tree jcount'=0,
%    \end{macrocode}
% Adjustment for line numbering
%    \begin{macrocode}
  declare count register={line no shift},
  line no shift'=0,
  declare count register={proof tree aros},
  proof tree aros'=0,
  declare toks register={check with},
  check with={\ensuremath{\checkmark}},
  declare boolean register={check right},
  check right,
  check left/.style={not check right},
  declare toks register={subs with},
  subs with={\ensuremath{\backslash}},
  declare boolean register={subs right},
  subs right,
  subs left/.style={not subs right},
  declare toks register={close with},
  close with={\ensuremath{\otimes}},
  declare keylist register={close format},
  close format={font=\scriptsize},
  declare keylist register={close with format},
  close with format={},
  declare toks register={merge delimiter},
  merge delimiter={\text{; }},
  declare boolean register={just refs left},
  just refs left,
  just refs right/.style={not just refs left},
  declare keylist register={just format},
  just format={},
  declare keylist register={line no format},
  line no format={},
  declare autowrapped toks register={highlight format},
  highlight format={draw=gray, rounded corners},
  declare keylist register={proof statement format},
  proof statement format={},
  declare keylist register={wff format},
  wff format={},
  declare boolean={proof tree justification}{0},
  declare boolean={proof tree line number}{0},
  declare boolean={grouped}{0},
  declare boolean={proof tree phantom}{0},
  declare boolean={highlight wff}{0},
  declare boolean={highlight just}{0},
  declare boolean={highlight line no}{0},
  declare boolean={highlight line}{0},
  Autoforward={highlight line}{highlight just, highlight wff, highlight line no},
  declare boolean={proof tree toing}{0},
  declare boolean={proof tree toing with}{0},
  declare boolean={proof tree rhiant cymysg}{0},
  declare boolean={proof tree rhifo}{1},
  declare boolean={proof tree arweinydd}{0},
  declare autowrapped toks={just}{},
  declare toks={proof tree rhestr rhifau llinellau}{},
  declare toks={proof tree close}{},
  declare toks={proof tree rhestr rhifau llinellau cau}{},
  declare autowrapped toks={just options}{},
  declare autowrapped toks={line no options}{},
  declare autowrapped toks={wff options}{},
  declare autowrapped toks={line options}{},
  Autoforward={line options}{just options={#1}, line no options={#1}, wff options={#1}},
  declare count={proof tree toing by}{0},
  declare count={proof tree cadw toing by}{0},
  declare count={proof tree toooing}{0},
  declare count={proof tree proof line no}{0},
%    \end{macrocode}
% Keylists for internal storage
%    \begin{macrocode}
  declare keylist={proof tree jrefs}{},
  declare keylist={proof tree crefs}{},
%    \end{macrocode}
% Internal keylists for use in stages
%    \begin{macrocode}
  declare keylist={proof tree ffurf}{},
  declare keylist={proof tree symud awto}{},
  declare keylist={proof tree creu nodiadau}{},
  declare keylist={proof tree nodiadau}{},
%    \end{macrocode}
% \changes{v0.9.1}{2025-08-23}{New internal keylists.}
% Additional internal keylists so we don't pollute \pkg{forest}'s and customisation is easier.
%    \begin{macrocode}
  declare keylist={before copying content}{},
  declare keylist={proof tree copy content}{},
  declare keylist={proof tree after copying content}{},
  declare keylist={proof tree before typesetting nodes}{},
  declare keylist={proof tree before packing}{},
  declare keylist={proof tree before computing xy}{},
  declare keylist={proof tree before drawing tree}{},
%    \end{macrocode}
% \changes{v0.9.1}{2025-08-23}{New public keylists.}
% Empty by default. 
% Allow changes in between processing of standard keylists.
%    \begin{macrocode}
  declare keylist={before making annotations}{},
  declare keylist={before annotating}{},
%    \end{macrocode}
% \changes{v0.9.1}{2025-08-25}{Additions for tagging: 
%   tag, plug, tag check with, tag close with, tag subs with, tag to prove, proof tree get tags, before getting tags, before making tags, proof tree make tags, ttoks
% }
% Additions for tagging.
% These are not actually used yet, but make experimenting (with \pkg{prooftrees-debug} easier.
%    \begin{macrocode}
  declare boolean register={tag},
  tag=0,
  declare toks register={plug},
  declare toks register={tag check with},
  tag check with={discharged},
  declare toks register={tag close with},
  tag close with={closed},
  declare toks register={tag subs with},
  tag subs with={substituted},
  declare toks register={tag to prove},
  tag to prove={To prove: },
  declare keylist={before making tags}{},
  declare keylist={proof tree make tags}{},
  declare keylist={before getting tags}{},
  declare keylist={proof tree get tags}{},
  declare toks={ttoks}{},
%    \end{macrocode}
% > indicates use of process when it is the first token, preceding a list of instructions as opposed to pgfmath stuff
%    \begin{macrocode}
  define long step={proof tree symud}{}{%
    root,sort by={>{O}{level},>{_O<}{1}{n children}},sort'=descendants
  },
%    \end{macrocode}
%    \begin{macrocode}
  define long step={proof tree cywiro symud}{}{%
    root,if line numbering={n=2}{n=1},sort by={>{O}{level},>{_O<}{1}{n children}},sort'=descendants
  },
%    \end{macrocode}
% Updated version of defn. from saso's code (forest2-saso-ptsz.tex) \& \url{https://chat.stackexchange.com/transcript/message/28321501#28321501}
%    \begin{macrocode}
  define long step={proof tree camau}{}{%
%    \end{macrocode}
% Angen +d - gweler \url{https://chat.stackexchange.com/transcript/message/28607212#28607212}
%    \begin{macrocode}
    root,sort by={>{O}{y},>{Ow1+d}{x}{-##1}},sort'={filter={descendants}{>{OO!&}{proof tree rhifo}{proof tree phantom}}}% 
  },
%    \end{macrocode}
% coeden brif yn unig ar ôl i greu nodiadau
%    \begin{macrocode}
  define long step={proof tree wffs}{}{% 
    fake=root,if line numbering={n=2}{n=1},tree
  },
%    \end{macrocode}
% \changes{v0.9.1}{2025-08-25}{New long step \texttt{proof tree every wff}.}
% \changes{v0.9.1}{2025-08-31}{Renamed \texttt{every wff}.}
% Unlike the previous step, this includes any proof statement and ensures nodes are only visited once, which we want for tagging.
%    \begin{macrocode}
  define long step={every wff}{}{%
    unique={name=proof statement,proof tree wffs}%
  },
  proof tree get tags processing order=every wff,
%    \end{macrocode}
% \changes{v0.9.1}{2025-08-30}{New long step \texttt{wff from proof line no to}.}
% See \url{https://tex.stackexchange.com/a/749854/39222} for example usage.
%
% Cf.~Sašo Živanović: \url{https://tex.stackexchange.com/a/296771/}
%
% Cf.~Sašo Živanović: \url{https://chat.stackexchange.com/transcript/message/28484520#28484520}
%
% Is there any advantage to sorting here?
%    \begin{macrocode}
  define long step={wffs from proof line no to}{n args=2}{
    sort by={>O{proof tree proof line no}},
    sort={filter={proof tree wffs}{> nO< nO> O! &&{#1-1}{proof tree proof line no}{#2+1}{proof tree proof line no}{phantom}}}%
  },
%    \end{macrocode}
% \iffalse
%</!debug>
%<*tag|!debug>
% \fi
% Mark discharge with optional name substituted into existential
% \changes{v0.9.1}{2025-08-25}{Add checked markers to \texttt{ttoks} if tagging.}
%
% For building \texttt{alt} text, we want to do this after content is copied but still before \texttt{before typesetting nodes} or \texttt{proof tree before typesetting nodes}.
%    \begin{macrocode}
  checked/.style={% 
    proof tree after copying content={%
      if check right={%
        content+'={\ \forestregister{check with}#1},
%<tag>        if tag={%
%<tag>          ttoks+/.process={Rw{tag check with}{ ##1#1}},
%<tag>        }{},
      }{%
        +content'={\forestregister{check with}#1\ },
%<tag>        if tag={%
%<tag>          +ttoks/.process={Rw{tag check with}{##1#1 }},
%<tag>        }{},
      },
    },
  },
%    \end{macrocode}
% Mark substitution of name into universal
% \changes{v0.9.1}{2025-08-25}{Add substitution markers to \texttt{ttoks} if tagging.}
%    \begin{macrocode}
  subs/.style={% 
    proof tree after copying content={%
      if subs right={%
        content+'={\ \forestregister{subs with}#1},
%<tag>        if tag={%
%<tag>          ttoks+/.process={Rw{tag subs with}{ ##1#1}},
%<tag>        }{},
      }{%
        +content'={\forestregister{subs with}#1\ },
%<tag>        if tag={%
%<tag>          +ttoks/.process={Rw{tag subs with}{##1#1 }},
%<tag>        }{},
      },
    },
  },
%    \end{macrocode}
% \iffalse
%</tag|!debug>
%<*!debug>
% \fi
% This now uses nodes rather than a label to accommodate annotations; closing must be done before packing the tree to ensure that sufficient space is allowed for the symbol and any following annotation; the annotations must be processed before anything is moved to ensure that the correct line numbers are used later, even if the references are given as relative node names
%    \begin{macrocode}
  close/.style={% 
    if={%
      >{__=}{#1}{}%
    }{}{%
      temptoksb={},
      temptoksa={#1},
      split register={temptoksa}{:}{proof tree close,temptoksb},
      if temptoksb={}{}{%
        split register={temptoksb}{,}{proof tree cref},
      },
    },
%    \end{macrocode}
% \changes{v0.9.1}{2025-08-26}{Delay appending closures to avoid copying into \texttt{ttoks} when tagging.}
%    \begin{macrocode}
    proof tree after copying content={%
%    \end{macrocode}
% This node holds the closure symbol
%    \begin{macrocode}
      append={% 
        [\forestregister{close with},
          not proof tree rhifo,
          proof tree phantom,
          grouped,
          no edge,
          process keylist register=close with format,
%    \end{macrocode}
% Adjust the distance between the closure symbol and any annotation
%    \begin{macrocode}
          proof tree before computing xy={% 
            delay={%
%    \end{macrocode}
% Cywiro? Fel arall, bydda'r peth byth yn cael ei wneud achos proof tree phantom? Dim yn siwr o gwbl.
%    \begin{macrocode}
              l'=\baselineskip,% 
              for children={%
                l/.register=close sep,
              },
            },
          },
          proof tree before drawing tree={%
            if={>{RR|}{line numbering}{justifications}}{%
              proof tree proof line no/.option=!parent.proof tree proof line no,
            }{},
          },
          if={%
            >{__=}{#1}{}%
          }{}{% 
%    \end{macrocode}
% Don't create a second node if there's no annotation.
%    \begin{macrocode}
            delay={%
              append={% 
%    \end{macrocode}
% This node holds the annotation, possibly including cross-references which will be relative to the node's grandparent.
%    \begin{macrocode}
                [,
                  not proof tree rhifo,
                  proof tree phantom,
                  grouped,
                  no edge,
                  process keylist register=close format,
                  if={%
                    >{O_=}{!parent,parent.proof tree close}{}%
                  }{}{content/.option=!{parent,parent}.proof tree close},
                  proof tree crefs/.option=!{parent,parent}.proof tree crefs,
                  delay={%
                    !{parent,parent}.proof tree crefs'={},
                  },
                  proof tree before drawing tree={%
                    if={>{RR|}{line numbering}{justifications}}{%
                      proof tree proof line no/.option=!{parent,parent}.proof tree proof line no,
                    }{},
                  },
                ]%
              },
            },
          },
        ]%
      },
    },
  },
%    \end{macrocode}
% Creates the line numbers on the left; note that it *does* matter that these are part of the tree, even though they do not need to be packed or to have xy computed; moreover, it matters that each is the child of the previous line number... so it won't do for them to *remain* siblings, even though that's fine when they are created.
%    \begin{macrocode}
  proof tree line no/.style={% 
    anchor=base west,
    no edge,
    proof tree line number,
    text width/.register=line no width,
    x'/.register=proof tree line no x,
    process keylist register=line no format,
    delay={%
      proof tree lcount'+=1,
      tempcounta/.process={RRw2+n}{proof tree lcount}{line no shift}{##1+##2},
      content/.process={Rw1}{tempcounta}{\linenumberstyle{##1}},% content i.e. the line number
%    \end{macrocode}
% Name them so they can be moved later
%    \begin{macrocode}
      name/.expanded={line no \foresteregister{tempcounta}},% 
      typeset node,
%    \end{macrocode}
% The initial location of most line numbers is incorrect and they must be moved
%    \begin{macrocode}
      if proof tree lcount>=3{% 
%    \end{macrocode}
% Move the line number below the previous line number
%    \begin{macrocode}
        for previous={% 
          append/.expanded={line no \foresteregister{tempcounta}}
        },
      }{},
    },
  },
%    \end{macrocode}
% Creates the justifications on the right but does not yet specify any content
%    \begin{macrocode}
  proof tree line justification/.style={% 
    anchor=base west,
    no edge,
    proof tree justification,
    x'/.register=proof tree justification x,
    process keylist register=just format,
    delay={%
      proof tree jcount'+=1,
      tempcounta/.process={RRw2+n}{proof tree jcount}{line no shift}{##1+##2},
%    \end{macrocode}
% Name them so they can be moved
%    \begin{macrocode}
      name/.expanded={just \foresteregister{tempcounta}}, 
%    \end{macrocode}
% Angen i osgoi broblemau 'da highlight just/line etc.
%    \begin{macrocode}
      typeset node, 
%    \end{macrocode}
% Correct the location as for the line numbers (cf. line no style)
%    \begin{macrocode}
      if proof tree jcount>=3{% 
        for previous={%
          append/.expanded={just \foresteregister{tempcounta}},
        },
      }{},
    },
  },
  zero start/.style={%
    line no shift'+=-1,
  },
%    \end{macrocode}
% \iffalse
%</!debug>
% \fi
% Sets a proof statement
%    \begin{macrocode}
  to prove/.style={% 
    for root={%
      proof tree before typesetting nodes={%
        content={#1},
        phantom=false,
        baseline,
        if line numbering={anchor=base west}{anchor=base},
        process keylist register=proof statement format,
%    \end{macrocode}
% \changes{v0.9.1}{2025-08-25}{Add to \texttt{ttoks} if tagging.}
% \iffalse
%<*tag>
% \fi
%    \begin{macrocode}
        if={>R{tag}}{%
%    \end{macrocode}
%    \begin{macrocode}
%<debug>          debug tagging=Copying to prove to ttoks,
%    \end{macrocode}
%    \begin{macrocode}
          ttoks/.process={ORw2{content}{tag to prove}{##2\ \ensuremath{##1}}},
%    \end{macrocode}
%    \begin{macrocode}
%<debug>          debug tagging/.option=ttoks,
%    \end{macrocode}
%    \begin{macrocode}
          proof tree get tags={%
%    \end{macrocode}
%    \begin{macrocode}
%<debug>            debug tagging=Pick up ttoks from to prove,
%    \end{macrocode}
%    \begin{macrocode}
            pick up tag/.option=ttoks,
          },
        }{},
%    \end{macrocode}
% \iffalse
%</tag>
% \fi
%    \begin{macrocode}
      },
      proof tree before computing xy={%
        delay={%
          for children={%
            l=1.5*\baselineskip,
          },
        },
      },
    },
  },
%    \end{macrocode}
% \iffalse
%<*!debug>
% \fi
% This style should **NOT** be used directly in a forest environment - see notes at top of this file.
%    \begin{macrocode}
  proof tree/.style={% 
    for tree={%
%    \end{macrocode}
% manual 64
%    \begin{macrocode}
      parent anchor=children,
%    \end{macrocode}
% manual 64
%    \begin{macrocode}
      child anchor=parent,
      math content,
      delay={%
%    \end{macrocode}
% If we've got justifications, make sure nodes are created for them later and split out cross-references so we identify the correct nodes before anything gets moved, allowing the use of relative node names.
%    \begin{macrocode}
        if just={}{}{% 
          justifications,
          temptoksa={},
          split option={just}{:}{just,temptoksa},
          if temptoksa={}{}{%
            split register={temptoksa}{,}{proof tree jref},
          },
        },
%    \end{macrocode}
% 
%    \begin{macrocode}
        if content={}{% if there's no proof statement
          if level=0{}{%
            shape=coordinate,
          },
        }{},
      },
    },
    where level=0{%
%    \end{macrocode}
% No edges from phantom root or proof statement to children.
%    \begin{macrocode}
      for children={% 
        proof tree before typesetting nodes={%
          no edge,
        },
      },
      delay={%
        if content={}{phantom}{},
%    \end{macrocode}
% Create the line numbers if appropriate.
%    \begin{macrocode}
        if line numbering={% 
          parent anchor=south west,
          if line no width={0pt}{%
            line no width/.pgfmath={width("\noexpand\linenumberstyle{99}")},
          }{},
        }{},
      },
%    \end{macrocode}
% This is processed after computing xy.
%    \begin{macrocode}
      proof tree creu nodiadau={% 
%    \end{macrocode}
% Count proof lines if necessary.
%    \begin{macrocode}
        if={>{RR|}{line numbering}{justifications}}{% 
          proof tree rhif lefelau'/.register=line no shift,
          for proof tree camau={%
            if level>=1{%
              if={%
                >{OO<}{y}{!back.y}%
              }{%
                proof tree rhif lefelau'+=1,
                proof tree proof line no'/.register=proof tree rhif lefelau,
              }{%
                proof tree proof line no'/.register=proof tree rhif lefelau
              },
            }{},
          },
          proof tree inner proof midpoint/.min={%
            >{OOw2+d}{x}{min x}{##1+##2}%
          }{fake=root,descendants},
          proof tree inner proof width/.max={%
            >{OOw2+d}{x}{max x}{##1+##2}%
          }{fake=root,descendants},
          proof tree inner proof width-/.register=proof tree inner proof midpoint,
          proof tree inner proof midpoint+/.process={%
            Rw+d{proof tree inner proof width}{##1/2}%
          },
        }{},
%    \end{macrocode}
% Get the x position of line numbers and adjust the location and alignment of the proof statement.
%    \begin{macrocode}
        if line numbering={% 
          proof tree line no x/.min={>{OOw2+d}{x}{min x}{##1+##2}}{fake=root,descendants},
          if={%
            > Rd= {line no dist}{0pt}%
          }{%
            proof tree line no x-/.register=line no sep,
          }{%
            tempdima/.register=proof tree inner proof width,
            tempdima:=2,
            if={%
              > RR< {line no dist}{tempdima}%
            }{}{%
              proof tree line no x/.register=proof tree inner proof midpoint,
              proof tree line no x-/.register=line no dist,
            },
          },
          proof tree line no x-/.register=line no width,
          for root={%
            tempdimc/.option=x,
            x'+/.register=proof tree line no x,
            x'-/.option=min x,
          },
%    \end{macrocode}
% create line numbers on left 
%    \begin{macrocode}
          prepend={%
            [,
              proof tree line no,
%    \end{macrocode}
%  () to group are required here - otherwise, the -1 (or -2 or whatever) is silently ignored.
% Most are created in the wrong place but proof tree line no moves them later.
%    \begin{macrocode}
              repeat={((proof_tree_rhif_lefelau)-1)-(line_no_shift)}{% 
                delay n={proof_tree_lcount}{
                  append={[, proof tree line no]},
                },
              },
            ]%
          },
        }{},
%    \end{macrocode}
%  Get the x position of justifications and create the nodes which will hold the justification content, if required.
%    \begin{macrocode}
        if justifications={%
          proof tree justification x/.max={%
            >{OOw2+d}{x}{max x}{##1+##2}%
          }{fake=root,descendants},
          if={%
            > Rd= {just dist}{0pt}%
          }{%
            proof tree justification x+/.register=just sep,
          }{%
            tempdima/.register=proof tree inner proof width,
            tempdima:=2,
            if={%
              > RR< {just dist}{tempdima}%
            }{}{%
              proof tree justification x/.register=proof tree inner proof midpoint,
              proof tree justification x+/.register=just dist,
            },
          },
          append={%
            [,
              proof tree line justification,
%    \end{macrocode}
% Most are created in the wrong place but proof tree line justification moves them later.
%    \begin{macrocode}
              repeat={((proof_tree_rhif_lefelau)-1)-(line_no_shift)}{% 
                delay n={proof_tree_jcount}{%
                  append={[, proof tree line justification]},
                },
              }%
            ]%
          },
        }{},
      },
    }{%
      delay={%
%    \end{macrocode}
% Automatically group lines if not using single branches.
%    \begin{macrocode}
        if single branches={}{%
          if n children=1{%
            for children={%
              grouped,
            },
          }{},
        },
      },
%    \end{macrocode}
% Apply wff-specific highlighting and additional TikZ keys.
%    \begin{macrocode}
      proof tree before typesetting nodes={%
        process keylist register=wff format,
        if highlight wff={node options/.register=highlight format}{},
        node options/.option=wff options,
      },
    },
%    \end{macrocode}
% Processed before proof tree symud auto: adjusts the alignment of lines when some levels of the tree are grouped together either whenever the number of children is only 1 or by applying the grouped style to particular nodes when specifying the tree.
%    \begin{macrocode}
    proof tree ffurf={%
      if auto move={%
        if single branches={%
          where={%
            >{O! _O< O &&}{grouped}{2}{level}{proof tree rhifo}%
          }{%
            if={%
              >{_O= _O< &}{1}{!parent.n children}{1}{!parent,parent.n children}%
            }{%
              not tempboola,
              for root/.process={Ow1}{level}{%
                for level={##1}{%
                  if={%
                    >{_O< _O= &}{1}{!parent.n children}{1}{n}%
                  }{%
                    tempboola,
                  }{},
                },
              },
              if tempboola={%
                proof tree toing,
              }{},
            }{},
          }{},
        }{},
        where={%
          >{O _O< O &&}{grouped}{1}{level}{proof tree rhifo}%
%    \end{macrocode}
% This searches for certain kinds of structural asymmetry in the tree and attempts to move lines appropriately in such cases - the algorithm is intended to be relatively conservative (not in the sense of 'cautious' or 'safe' but in the sense of 'reflection of the overlapping consensus of reasonable users' / 'what would be rationally agreed behind the prooftrees veil of ignorance'; however, I should have realised I actually had 'the overlapping concensus of reasonable Beamer users' in mind rather than 'the overlapping consensus of reasonable users', so there is now an option to turn it off; apologies if this comment previously misclassified you as 'unreasonable'; apologies for the inconvenience if you are an unreasonable user).
%    \begin{macrocode}
        }{%
          not tempboola,
          for root/.process={Ow1}{level}{%
            for level={##1}{%
              if={%
                >{_O< _O= &}{1}{!parent.n children}{1}{n}%
              }{%
                tempboola,
              }{},
            },
%    \end{macrocode}
% Sašo:  \url{https://chat.stackexchange.com/transcript/message/27874731#27874731}, see also \url{https://chat.stackexchange.com/transcript/message/27874722#27874722}.
%    \begin{macrocode}
          },%
          if tempboola={%
            if n children=0{%
%    \end{macrocode}
% We're already moving the parent and the child will move with the parent, so we can just mark this and do nothing else.
%    \begin{macrocode}
              if={>{OO|}{!parent.proof tree toing}{!parent.proof tree toing with}}{%
                proof tree toing with,
              }{%
%    \end{macrocode}
% Don't move a terminal node even in case of asymmetry: instead, create a separate proof line for terminal nodes on this level which are only children, by moving children with siblings on this level down a proof line, without altering their physical location.
%    \begin{macrocode}
                for root/.process={Ow1}{level}{%
%    \end{macrocode}
% This makes the tree more compact and stops it looking silly.
%    \begin{macrocode}
                  for level={##1}{%
                    if={%
                      >{_O< _O= &}{1}{!parent.n children}{1}{n}%
                    }{%
%    \end{macrocode}
% This just serves to keep the levels nice for the sub-tree and ensure things align. We need this because we want to skip a level here to allow room for the terminal node in the other branch.
%    \begin{macrocode}
                      for parent={%
%    \end{macrocode}
% We mark the parent to avoid increasing the line number of its descendants more than once. 
%    \begin{macrocode}
                        if proof tree rhiant cymysg={}{%
                          proof tree rhiant cymysg,
                          for descendants={%
                            proof tree toing by'+=1,
                          },
                        },
                      },
                    }{},
                  },
%    \end{macrocode}
% Sašo:  \url{https://chat.stackexchange.com/transcript/message/27874731#27874731}, see also \url{https://chat.stackexchange.com/transcript/message/27874722#27874722}.
%    \begin{macrocode}
                },%
              },
              no edge,
            }{%
              if={%
                >{_O= _O< &}{1}{!parent.n children}{1}{!parent,parent.n children}%
%    \end{macrocode}
% Don't try to move if the node has more than 1 child or the grandparent has no more than that; otherwise, mark the node as one to move - we figure out where to move it later.
%    \begin{macrocode}
              }{%
                proof tree toing,
              }{no edge},
            },
          }{no edge},
        }{},
      }{},
    },
%    \end{macrocode}
% Processed before typesetting nodes: if \emph{this} could be done during packing, that would be very nice, even if the previous stuff can't be.
%    \begin{macrocode}
    proof tree symud awto={%
      if auto move={%
        proof tree aros'=0,
        for proof tree symud={%
%    \end{macrocode}
% This relies on an experimental feature of forest, which is anffodus. 
%    \begin{macrocode}
          if proof tree toing={%
            for nodewalk={fake=parent,fake=sibling,descendants}{do dynamics},
            delay n={\foresteregister{proof tree aros}}{%
              tempcounta/.max={%
                >{OOOOw4+n}{level}{proof tree toing by}{proof tree toooing}%
                {proof tree rhifo}{(##1+##2+##3)*##4}%
              }{parent,sibling,descendants},
              if tempcounta>=1{%
                if={%
                  >{Rw1+n OOw2+n >}{tempcounta}{##1+1}{level}{proof tree toing by}{##1+##2}%
                }{%
                  tempcounta-/.option=level,
                  tempcounta'+=1,
                  move by/.register=tempcounta,
                }{no edge},
              }{no edge},
            },
            proof tree aros'+=4,
          }{},
        },
      }{},
    },
%    \end{macrocode}
% Processed after proof tree creu nodiadau and before before drawing tree: creates annotation content which may include cross-references, applies highlighting and additional TikZ keys to line numbers, justifications and to wffs where specified for entire proof lines.
%    \begin{macrocode}
    proof tree nodiadau={%
%    \end{macrocode}
% Resolve cross-refs in closures. 
%    \begin{macrocode}
      where proof tree crefs={}{}{%
        split option={proof tree crefs}{,}{proof tree rhif llinell cau},
        if content={}{%
          content/.option=proof tree rhestr rhifau llinellau cau,
        }{%
          content+/.process={_O}{\ }{proof tree rhestr rhifau llinellau cau},
        },
        typeset node,
      },
%    \end{macrocode}
% Apply highlighting and additional TikZ keys to line numbers; initial alignment of numbers with proof lines.
%    \begin{macrocode}
      if line numbering={%
        for proof tree wffs={%
          if highlight line no={%
%    \end{macrocode}
% From Sašo's anti-pgfmath version - rhaid ddweud proof tree proof line no yn ddwywaith ?! dim yn bosibl i ailddefnyddio'r gyntaf ?! 
%    \begin{macrocode}
            for name/.process={Ow1OOOw3}{proof tree proof line no}{line no ##1}{proof tree proof line no}{line no options}{y}{%
              node options/.register=highlight format,
              ##2,
              y'=##3,
              proof tree proof line no'=##1,
              typeset node,
            }%
          }{%
            if line no options={}{%
              if proof tree phantom={}{%
                for name/.process={Ow1OOw2}{proof tree proof line no}{line no ##1}{proof tree proof line no}{y}{%
                  y'=##2,
                  proof tree proof line no'=##1,
                }%
              },
            }{%
              for name/.process={Ow1OOOw3}{proof tree proof line no}{line no ##1}{proof tree proof line no}{line no options}{y}{%
                ##2,
                y'=##3,
                proof tree proof line no'=##1,
                typeset node,
              }%
            },
          },
        },
      }{},
%    \end{macrocode}
% Initial alignment of justifications with proof lines, addition of content, resolution of cross-references and application of highlighting and additional TikZ keys.
%    \begin{macrocode}
      if justifications={%
        for proof tree wffs={%
          if just={}{%
            if proof tree phantom={}{%
%    \end{macrocode}
% From Sašo's anti-pgfmath version - rhaid ddweud proof tree proof line no yn ddwywaith ?! dim yn bosibl i ailddefnyddio'r gyntaf ?! 
%    \begin{macrocode}
              for name/.process={Ow1OOw2}{proof tree proof line no}{just ##1}{proof tree proof line no}{y}{%
                y'=##2,
                proof tree proof line no'=##1,
              }%
            },
          }{%
%    \end{macrocode}
% Puts the content of the justifications into the empty justification nodes on the right; because this is done late, the nodes need to be typeset again.
%    \begin{macrocode}
            if proof tree jrefs={}{}{%
%    \end{macrocode}
% Resolve cross-refs in justifications.
%    \begin{macrocode}
              split option={proof tree jrefs}{,}{proof tree rhif llinell},
              if just refs left={%
                +just/.process={O_}{proof tree rhestr rhifau llinellau}{\ },
              }{%
                just+/.process={_O}{\ }{proof tree rhestr rhifau llinellau},
              },
            },
%    \end{macrocode}
% Apply highlighting and additional TikZ keys to justifications, set content and merge any conflicting specifications, warning user if appropriate.
%    \begin{macrocode}
            if highlight just={%
%    \end{macrocode}
% From Sašo's anti-pgfmath version - rhaid ddweud proof tree proof line no yn ddwywaith ?! dim yn bosibl i ailddefnyddio'r gyntaf ?! 
%    \begin{macrocode}
              for name/.process={Ow1OOOOw4}{proof tree proof line no}{just ##1}{proof tree proof line no}{just}{just options}{y}{%
                if={%
                 >{O_= O_= |}{content}{}{content}{##2}%
%    \end{macrocode}
% Gweler isod - o gôd Sašo.
%    \begin{macrocode}
                }{%
                  content={##2},
%    \end{macrocode}
% \changes{v0.9.1}{2025-09-03}{Avoid merging tags for merged justifications.} 
% Avoid merging tags for merged justifications.
% We need this in four places: for merged and unmerged justifications with and without highlighting.
% This would have been easier with Peter Smith's preferred design \dots.
%    \begin{macrocode}
                }{%
                  content+'={\foresteregister{merge delimiter}##2},
                  TeX={\PackageWarning{prooftrees}{Merging conflicting justifications for line ##1! Please examine the output carefully and use "move by" to move lines later in the proof if required. Details of how to do this are included in the documentation.}},
%    \end{macrocode}
% Avoid merging tags for merged justifications.
%    \begin{macrocode}
                },
                node options/.register=highlight format,
                ##3,
                y'=##4,
                proof tree proof line no'=##1,
                typeset node,
              }%^^A do NOT put a comma here!
            }{%
%    \end{macrocode}
% From Sašo's anti-pgfmath version - rhaid ddweud proof tree proof line no yn ddwywaith ?! dim yn bosibl i ailddefnyddio'r gyntaf ?! 
%    \begin{macrocode}
              for name/.process={Ow1OOOOw4}{proof tree proof line no}{just ##1}{proof tree proof line no}{just}{just options}{y}{%
                if={%
%    \end{macrocode}
% From Sašo's anti-pgfmath version - I appreciate this is faster, but why is it \textbf{required}?! 
%    \begin{macrocode}
                 >{O_= O_= |}{content}{}{content}{##2}%
                }{%
                  content={##2},
%    \end{macrocode}
% Avoid merging tags for merged justifications.
%    \begin{macrocode}
                }{%
                  content+'={\foresteregister{merge delimiter}##2},
                  TeX={\PackageWarning{prooftrees}{Merging conflicting justifications for line ##1! Please examine the output carefully and use "move by" to move lines later in the proof if required. Details of how to do this are included in the documentation.}},
%    \end{macrocode}
% Avoid merging tags for merged justifications.
%    \begin{macrocode}
                },
                ##3,
                y'=##4,
                proof tree proof line no'=##1,
                typeset node,
              }%^^A do NOT put a comma here!
            }
          },
        },
      }{},
%    \end{macrocode}
% Apply highlighting and TikZ keys which are specified for whole proof lines to all applicable wffs.
%    \begin{macrocode}
      for proof tree wffs={%
        if proof tree phantom={}{%
          if highlight line={%
            for proof tree wffs/.process={OOw2}{proof tree proof line no}{line options}{%
              if proof tree proof line no={##1}{%
                node options/.register=highlight format,
                ##2,
              }{}%
            },
          }{%
            for proof tree wffs/.process={OOw2}{proof tree proof line no}{line options}{%
              if proof tree proof line no={##1}{##2}{},
            },
          },
          delay={typeset node},
        },
      },
    },
%    \end{macrocode}
% Initial alignment so we don't get proof line numbers incrementing due to varying height/depth of nodes, for example - when single branches is true and few nodes are grouped, this is also a reasonable first approximation.
%    \begin{macrocode}
    proof tree before packing={%
      for tree={%
        tier/.process={OOw2+nw1}{level}{proof tree toing by}{##1+##2}{tier ##1},
      },
%    \end{macrocode}
% If there's no proof statement, adjust the alignment of the proof relative to the surrounding text.
%    \begin{macrocode}
      for root={%
        if content={}{%
          !{n=1}.baseline,
        }{},
      },
    },
%    \end{macrocode}
% Adjust distance between levels for grouped nodes after tree is packed.
%    \begin{macrocode}
    proof tree before computing xy={%
      for tree={%
        if={%
         >{O _O< &}{grouped}{1}{level}%
%    \end{macrocode}
% Osgoi overlapping nodes, if posibl: cwestiwn \url{https://tex.stackexchange.com/q/456254/}.
%    \begin{macrocode}
       }{%
         not tempboola,
         tempcounta/.option=level,
         tempcountb/.option=proof tree toing,
         tempcountb+/.option=proof tree toooing,
         for nodewalk={fake=root, descendants}{if={> RO= On>  O! O! OOw2+nR= &&&&
             {tempcounta}{level} {!u.n children}{1} {proof tree arweinydd} {proof tree phantom} {proof tree toing by} {proof tree toooing}{##1+##2} {tempcountb}
           }{tempboola}{}},
         if tempboola={}{l'=\baselineskip},
       }{},
      },
    },
%    \end{macrocode}
% Set final alignment for proof lines which have been moved by effectively grouping lead nodes and moving their subtrees accordingly - this requires that each line number and justification be the child of the previous one and that if justifications are used at all, then justifications exist for all proof lines, even if empty.
%    \begin{macrocode}
    proof tree before drawing tree={%
%    \end{macrocode}
% Correct the alignment of move by lines when single branches is false - o fersiwn anti-pgfmath Sašo. 
%    \begin{macrocode} 
      if={>{RR|R!&}{line numbering}{justifications}{single branches}}{%
%    \end{macrocode}
% Track cumulative adjustments to line numbers and justifications 
%    \begin{macrocode} 
        tempdimc'=0pt,
        for proof tree cywiro symud={%
%    \end{macrocode}
% Only examine the lead nodes - their descendants need the same (cumulative) adjustments 
%    \begin{macrocode} 
          if proof tree arweinydd={%
            tempdima'/.option=y,
%    \end{macrocode}
% If there are line numbers, we use the previous line number's vertical position 
%    \begin{macrocode} 
            if line numbering={%
              for name/.process={Ow1+nw1}{proof tree proof line no}{##1-1}{line no ##1}{% arafach ?
                tempdimb'/.option=y,
              }%
%    \end{macrocode}
% If not, we use the previous justification's vertical position 
%    \begin{macrocode}
            }{%
              for name/.process={Ow1+nw1}{proof tree proof line no}{##1-1}{just ##1}{% arafach ?
                tempdimb'/.option=y,
              }%
            },
%    \end{macrocode}
% The parent (which will be a phantom) gets aligned with the previous line 
%    \begin{macrocode}
            for parent={%
              y'/.register=tempdimb,
            },
%    \end{macrocode}
% Adjust so we align this line below the previous one (assuming we're going down) 
%    \begin{macrocode}
            if tempdimb<={0pt}{%
              tempdimb'-=\baselineskip,
            }{%
              tempdimb'+=\baselineskip,
            },
%    \end{macrocode}
% How far are we moving? 
%    \begin{macrocode}
            tempdimb'-/.register=tempdima,
%    \end{macrocode}
% Adjust this node and all descendants 
%    \begin{macrocode}
            for tree={%
              y'+/.register=tempdimb,
            },
%    \end{macrocode}
% Deduct any tracked cumulative adjustments to line numbers and justifications
%    \begin{macrocode}
            tempdimb'-/.register=tempdimc,
%    \end{macrocode}
% Adjust the line numbers, if any 
%    \begin{macrocode}
            if line numbering={%
              for name/.process={Ow1}{proof tree proof line no}{line no ##1}{%
                for tree={%
                  y'+/.register=tempdimb,
                },
              }%
            }{},
%    \end{macrocode}
% Adjust the justifications, if any 
%    \begin{macrocode}
            if justifications={%
%    \end{macrocode}
% t. 60 manual 2.1 rc1 
%    \begin{macrocode}
              for name/.process={Ow1}{proof tree proof line no}{just ##1}{%
                for tree={%
                  y'+/.register=tempdimb,
                },
              }%
            }{},
%    \end{macrocode}
% Add the adjustment just implemented to the tracked cumulative adjustments for line numbers and/or justifications
%    \begin{macrocode}
            tempdimc'/.register=tempdimb,
          }{},
        },
      }{},
      if={%
        > RR| {auto move}{single branches}%
      }{}{%
        where proof tree arweinydd={%
          for nodewalk={%
            save append={proof tree walk}{%
              current,
              do until={%
                > O+t_+t=! {content}{}%
              }{parent}%
            }%
          }{},
        }{},
        where level>=1{%
          if grouped={%
            if in saved nodewalk={current}{proof tree walk}{}{%
              no edge,
            },
          }{},
        }{},
      },
    },
  },
%    \end{macrocode}
% This implements both the automated moves \pkg{prooftrees} finds necessary and any additional moves requested by the user - more accurately, it implements initial moves, which may get corrected later (e.g. to avoid skipping numbers or creating empty proof lines, which we assume aren't wanted).
%    \begin{macrocode}
  move by/.style={%
    if={
     >{_n<}{0}{#1}%
%    \end{macrocode}
% Only try to move the node if the target line number exceeds the one i.e. the line number is to be positively incremented. 
%    \begin{macrocode}
    }{%
      proof tree cadw toing by/.option=proof tree toing by,
      proof tree arweinydd,
      for tree={%
        if={%
         >{_n<}{1}{#1}%
%    \end{macrocode}
% Track skipped lines for which we won't be creating phantom nodes 
%    \begin{macrocode}
        }{%
          proof tree toing by+=#1-2,
          proof tree toooing'+=1,
        }{},
      },
%    \end{macrocode}
% Insert our first phantom 
%    \begin{macrocode}
      delay={%
        replace by={%
          [,
            if={%
             >{_n<}{1}{#1}%
            }{%
              child anchor=parent,
              parent anchor=parent,
            }{%
              child anchor=children,
              parent anchor=children,
            },
            proof tree phantom,
%    \end{macrocode}
% Sašo Živanović: \url{https://chat.stackexchange.com/transcript/message/27990955#27990955}.
%    \begin{macrocode}
            edge path/.option=!last dynamic node.edge path,
            edge/.option=!last dynamic node.edge,
            append,
            proof tree before drawing tree={%
              if={>{RR|}{line numbering}{justifications}}{%
                proof tree proof line no/.process={Ow1+n}{!parent.proof tree proof line no}{##1+1},
              }{},
            },
            if={%
             >{_n<}{1}{#1}%
%    \end{macrocode}
% If we are moving by more than 1, we insert a second phantom so that a node with siblings which is moved a long way will not get a unidirectional edge but an edge which looks similar to others in the tree (by default, sloping down a line or so and then plummeting straight down rather than a sharply-angled steep descent).
%    \begin{macrocode}
            }{%
              delay={%
                append={%
                  [,
                    child anchor=parent,
                    parent anchor=parent,
                    proof tree toing by=#1-2+proof_tree_cadw_toing_by,
                    proof tree phantom,
                    edge path/.option=!u.edge path,
                    edge/.option=!u.edge,
                    proof tree before drawing tree={%
                      if={>{RR|}{line numbering}{justifications}}{%
                        proof tree proof line no/.process={Ow1+n}{!n=1.proof tree proof line no}{##1-1},
                      }{},
                    },
                    append=!sibling,
                  ]%
                },
              },
            }{%
              if single branches={}{%
                delay={%
                  for children={%
                    no edge,
                  },
                },
              },
            },
           ]%
        },
      },
    }{%
      TeX/.process={Ow1}{name}{\PackageWarning{prooftrees}{Line not moved! I can only move things later in the proof. Please see the documentation for details. ##1}},
    },
  },
%    \end{macrocode}
% Get the names of nodes cross-referenced in closure annotations for use later 
%    \begin{macrocode}
  proof tree cref/.style={%
    proof tree crefs+/.option=#1.name,
  },
%    \end{macrocode}
% Get the proof line numbers of the cross-referenced nodes in closure annotations, using the list of names created earlier.
%    \begin{macrocode}
  proof tree rhif llinell cau/.style={%
    if proof tree rhestr rhifau llinellau cau={}{}{%
      proof tree rhestr rhifau llinellau cau+={,\,},
    },
    proof tree rhestr rhifau llinellau cau+/.option=#1.proof tree proof line no,
  },
%    \end{macrocode}
% Get the names of nodes cross-referenced in justifications for use later. 
%    \begin{macrocode}
  proof tree jref/.style={%
    proof tree jrefs+/.option=#1.name,
  },
%    \end{macrocode}
% Get the proof line numbers of the cross-referenced nodes in justifications, using the list of names created earlier.
%    \begin{macrocode}
  proof tree rhif llinell/.style={%
    if proof tree rhestr rhifau llinellau={}{}{%
      proof tree rhestr rhifau llinellau+={,\,},
    },
%    \end{macrocode}
% works according to Sašo's anti-pgfmath version 
%    \begin{macrocode}
    proof tree rhestr rhifau llinellau+/.option=#1.proof tree proof line no,
  },
%    \end{macrocode}
% 2018-02-19 ateb \url{https://tex.stackexchange.com/a/416037/} 
%    \begin{macrocode}
  line no override/.style={%
    proof tree before drawing tree={
      for name/.process={Ow}{proof tree proof line no}{line no ##1}{
        content=\linenumberstyle{#1},
        typeset node,
      },
    },
  },
%    \end{macrocode}
% 2018-02-19 gweler uchod 
%    \begin{macrocode}
  no line no/.style={%
    proof tree before drawing tree={
      for name/.process={Ow}{proof tree proof line no}{line no ##1}{
        content=,
        typeset node,
      },
    },
  },
%    \end{macrocode}
% \changes{v0.9.1}{2025-08-30}{Add \texttt{nodewalk node+}, \texttt{nodewalk node\textquotesingle}, \texttt{+nodewalk node}, \texttt{nodewalk node} and \texttt{nodewalk to node}.}
% Styles to make facilitate drawing around nodewalks.
%    \begin{macrocode}
  prooftrees@nodewalk@node/.style={inner sep=0pt},
  nodewalk node+/.code={%
    \pgfqkeys{/forest}{prooftrees@nodewalk@node/.append style={#1}}%
  },
  +nodewalk node/.code={%
    \pgfqkeys{/forest}{prooftrees@nodewalk@node/.prepend style={#1}}%
  },
  nodewalk node'/.code={%
    \pgfqkeys{/forest}{prooftrees@nodewalk@node/.style={#1}}%
  },
  nodewalk node/.forward to=/forest/nodewalk node+,
  nodewalk to node/.style 2 args={%
    proof tree before drawing tree={%
      tikz+={%
        \node [fit to={#2},/forest/prooftrees@nodewalk@node] (#1) {};
      },
    },
  },
%    \end{macrocode}
% ^^A dadfygio <<<
% Two styles for debugging.
% Despite the names, these are available in the non-debug package for largely historical reasons, but also because they probably do not cost much.
%
% Style for use in debugging moves which displays information about nodes in the tree.
%    \begin{macrocode}
  proof tree dadfygio/.style={%
    proof tree before packing={%
      for tree={%
        label/.process={OOOw3}{level}{proof tree toing by}{id}{%
          [red,font=\tiny,inner sep=0pt,outer sep=0pt, anchor=south]below:##1/##2/##3%
        },
      },
    },
    proof tree before drawing tree={%
      for tree={%
        delay={%
          tikz+/.process={Ow1}{proof tree proof line no}{%
            \node [anchor=west, font=\tiny, text=blue, inner sep=0pt] at (.east) {##1};
          },
        },
      },
    },
  },
%    \end{macrocode}
% Debugging / dangos dimension stuff.
%    \begin{macrocode}
  proof tree alino/.style={%
    proof tree before drawing tree={%
      tikz+/.process={%
        RRRRw4{proof tree inner proof midpoint}{line no width}{line no dist}{just dist}
        {
          \begin{scope}[densely dashed]
            \draw [darkgray] (##1,0) coordinate (a) -- (a |- current bounding box.south);
            \draw [green] (current bounding box.west) -- ++(##2,0) coordinate (b);
            \draw [blue] (b) -- ++(##3,0) coordinate (c);
            \draw [magenta] (c) -- ++(##4,0);
          \end{scope}
        }%
      },
    },
  },
%    \end{macrocode}
% ^^A dadfygio >>> 
% ^^A ttableau yn cynnwys dadfygio tagging <<< 
% \iffalse
%</!debug>
% \fi
% \changes{v0.9.1}{2025-08-25}{Add ttableau style for experiments with tagging.}
% \texttt{debug tagging} is more expensive, so split this out.
%
% ANGEN: dw i ddim yn meddwl bod crefs yn cynnwys explicit closures?
%    \begin{macrocode}
  ttableau/.style={%
%    \end{macrocode}
% \iffalse
%<*tag>
% \fi
%    \begin{macrocode}
    if={>R{tag}}{%
      proof tree copy content={%
%    \end{macrocode}
%    \begin{macrocode}
%<debug>        debug tagging=Copying node contents,
%    \end{macrocode}
%    \begin{macrocode}
        where content={}{}{%
%    \end{macrocode}
%    \begin{macrocode}
%<debug>          debug tagging=Copying node content to ttoks,
%    \end{macrocode}
%    \begin{macrocode}
          ttoks+/.process={Ow{content}{\ensuremath{##1}}},
%    \end{macrocode}
%    \begin{macrocode}
%<debug>          debug tagging/.process={Ow{ttoks}{ttoks is ##1}},
%    \end{macrocode}
%    \begin{macrocode}
        },
      },
      proof tree make tags={%
%    \end{macrocode}
%    \begin{macrocode}
%<debug>  debug tagging=Making tags,
%    \end{macrocode}
%    \begin{macrocode}
        for unique={proof tree wffs}{%
          if={>OO!&{proof tree rhifo}{proof tree phantom}}
          {%
            if line numbering={%
              +ttoks={\ },
              +ttoks/.option=proof tree proof line no,
            }{},
            if justifications={%
%<debug>      debug tagging={Looking for a justification ...},
%    \end{macrocode}
% Avoid merged justifications when tagging; duplicate shared justifications where possible.
%    \begin{macrocode}
              if just={}{%
                if={> O_= {!u.n children}{2}}{%
                  if={>O_={!s.just}{}}{}{just/.option=!s.just,},
%<debug>          debug tagging/.process={Ow{just}{from sibling just is ##1}},
                }{%
                  temptoksa=,
                  for nodewalk={%
                    while nodewalk valid={u}{%
                      u,
                      if proof tree phantom={}{%
                        if n children=2{%
                          back=1,
                          s,
                          temptoksa/.option=just%
                        }{},
                        break,
                      }%
                    }%
                  }{},
                  just/.register=temptoksa,
%<debug>          debug tagging/.process={Ow{just}{from ancestor sibling just is ##1}},
                },
              }{},
              if just={}{}{%
                ttoks+/.process={%
                  Ow{just}{\ ##1\ }%
                },
% ^^A                Ow+pw {proof tree proof line no}{%
% ^^A                  O{!{name=just ##1}.content}%
% ^^A                }{\ ##1\ }%
              },
%<debug>      debug tagging/.process={Ow{ttoks}{ttoks is now ##1}},
            }{},
%    \end{macrocode}
%    \begin{macrocode}
%<debug>    debug tagging/.process={Ow{ttoks}{ttoks is now ##1}},
%    \end{macrocode}
%    \begin{macrocode}
            proof tree get tags={%
%    \end{macrocode}
%    \begin{macrocode}
%<debug>      debug tagging=Get tag from wff,
%<debug>      debug tagging/.process={Ow{ttoks}{ttoks is now ##1}},
%    \end{macrocode}
%    \begin{macrocode}
              pick up tag/.option=ttoks,
            },
          }{%
            if n children=0{%
              delay={%
%<debug>        debug tagging=Leaf node,
%<debug>        debug tagging=Get closure status,
                if={> O_=! O_=! | {proof tree crefs}{} {!uu.proof tree close}{}}
                {%
%<debug>          debug tagging=Branch is closed,
%<debug>          debug tagging/.process={Ow{proof tree crefs}{crefs: ##1}},
%<debug>          debug tagging/.process={Ow{!uu.proof tree close}{!uu.proof tree close: ##1}},
%<debug>          debug tagging/.process={Ow{content}{content: ##1}},
                  !uu.ttoks+/.process={ORw2{content}{tag close with}{\ ##2\ ##1\ }},
%<debug>          debug tagging/.process={Ow{!uu.ttoks}{!uu.ttoks is now ##1}},
                }{%
%<debug>          debug tagging=Branch is open,
                },
              },
            }{},
          },
        },
      },
%    \end{macrocode}
% \changes{v0.9.1}{2025-08-25}{Try to tag tableau.}
% Note that this method would not work for many \pkg{forest} trees and may fail for some tableaux, but should work for most proofs, I think.
%    \begin{macrocode}
      tag tableau/.style={
%    \end{macrocode}
%    \begin{macrocode}
%<debug>        debug tagging=Tag tableau,
%    \end{macrocode}
%    \begin{macrocode}
        tempdima/.max={>OOw2+d{x}{max x}{####1+####2}}{tree},
        tempdima-/.min={>OOw2+d{x}{min x}{####1+####2}}{tree},
        tempdimb/.max={>OOw2+d{y}{max y}{####1+####2}}{tree},
        tempdimb-/.min={>OOw2+d{y}{min y}{####1+####2}}{tree},
        TeX/.process={%
          RRRw3{plug}{tempdima}{tempdimb}{\prooftrees@ttableau{####1}{####2}{####3}}%
        },
      },
    }{},
%    \end{macrocode}
% \iffalse
%</tag>
% \fi
%    \begin{macrocode}
  },
%    \end{macrocode}
% \changes{v0.9.1}{2025-08-25}{\texttt{tag tableau stage} following \pkg{forest} pattern and noop default style.}
%    \begin{macrocode}
%<!debug>  tag tableau stage/.style={for root'=tag tableau,},
%<!debug>  tag tableau/.style={},
%    \end{macrocode}
% \changes{v0.9.1}{2025-08-25}{Experimental \texttt{alt} plug for tagging.}
% Note this is not just default.
% It is the \textbf{only} option even vaguely compatible with tagging.
%    \begin{macrocode}
%<tag>  alt/.style={%
%<tag>    plug=alt,
%<debug&tag>    debug tagging=Using plug alt,
%<tag>    pick up tag/.code={%
%<tag>      \toksapp\prooftrees@tableau@toks{##1 }%
%<debug&tag>      \if@ttableau@dadfygio
%<debug&tag>        \typeout{[Tag tableau debug]:: Appending toks ##1.}%
%<debug&tag>      \fi
%<tag>    },
%<tag>  },
%<tag>  alt,
%<debug>  debug tagging/.code={},
% ^^A dadfygio >>>
}
%<!debug>\bracketset{action character=@}
%    \end{macrocode}
% \begin{environment}{prooftree}
% \begin{environment}{tableau}
% ^^A <<<
% \cs{forest}/\cs{endforest} from egreg's answer at \url{https://tex.stackexchange.com/a/229608/} 
%    \begin{macrocode}
%<!debug>\NewDocumentEnvironment{\prooftrees@enw}{ m +b }
%<debug>\RenewDocumentEnvironment{\prooftrees@enw}{ m +b }
{%
  \global\advance\prooftrees@tableau@id by 1
  \prooftrees@ttableau@init
  \forest
    (%
%    \end{macrocode}
% Customised definition of stages - we don't use any custom stages, but we do use several custom keylists, where the processing order of these is critical.
%    \begin{macrocode}
      stages={%
%    \end{macrocode}
% Nothing is removed from the standard forest definition - we only change it by adding to it. 
%    \begin{macrocode}
        for root'={%
          process keylist register=default preamble,
          process keylist register=preamble,
        },
        process keylist=given options,
%    \end{macrocode}
% \changes{v0.9.1}{2025-08-23}{Adjust stage processing for new keylists.}
% \texttt{proof tree before typesetting nodes}, \texttt{proof tree after copying content}, \texttt{proof tree before packing}, \texttt{proof tree before computing xy} and \texttt{proof tree before drawing tree} just avoid polluting \pkg{forest}'s keylists so they can be used to customise the tableau.
% \texttt{proof tree copy content} is used only for tagging.
% These are internal lists.
% They should not generally be redefined or customised by users, as doing so may render the tree structure invalid or cause unexpected results.
%
% In addition to the keylists provided by \pkg{forest}, \texttt{before copying content}, \texttt{before making annotations}, \texttt{before annotating}, \texttt{before making tags} and \texttt{before getting tags} are intended for users to customise the tableau at these points, if required.
%    \begin{macrocode}
        process keylist=before copying content,
%<tag>        process keylist=proof tree copy content,
        process keylist=proof tree after copying content,
        process keylist=proof tree before typesetting nodes,
        process keylist=before typesetting nodes,
%    \end{macrocode}
%    \begin{macrocode}
%    \end{macrocode}
% First two structural additions: process two custom keylists after before typesetting nodes and before typesetting nodes to shape the tree.
%    \begin{macrocode}
        process keylist=proof tree ffurf,
        process keylist=proof tree symud awto,
        typeset nodes stage,
        process keylist=proof tree before packing,
        process keylist=before packing,
        pack stage,
        process keylist=proof tree before computing xy,
        process keylist=before computing xy,
        compute xy stage,
%    \end{macrocode}
% Second two structural/content additions: process two custom keylists after computing xy and before before drawing tree to create and attach the annotations.
%    \begin{macrocode}
        process keylist=before making annotations,
        process keylist=proof tree creu nodiadau,
        process keylist=before annotating,
        process keylist=proof tree nodiadau,
%    \end{macrocode}
% Standardish
%    \begin{macrocode}
        process keylist=proof tree before drawing tree,
        process keylist=before drawing tree,
%    \end{macrocode}
% Hopefully for doing something useful for tagging.
% \texttt{proof tree make tags} and \texttt{proof tree get tags} currently do nothing, but will hopefully eventually be used to collect information for tagging the tableau.
% The ‘public’ keylists are described above.
%    \begin{macrocode}
        process keylist=before making tags,
%<tag>        process keylist=proof tree make tags,
        process keylist=before getting tags,
%<tag>        process keylist=proof tree get tags,
%    \end{macrocode}
%    \begin{macrocode}
%<debug&tag>        TeX={%
%<debug&tag>          \if@ttableau@dadfygio
%<debug&tag>            \typeout{[Tag tableau debug]:: Accumulated toks:}%
%<debug&tag>            \ExpandArgs {o} \typeout{\the\prooftrees@tableau@toks}%
%<debug&tag>          \fi
%<debug&tag>        },
%    \end{macrocode}
% Try to produce some kind of useful stuff for tagging, if active.
% Does nothing right now.
%    \begin{macrocode}
%<tag>        tag tableau stage,
%    \end{macrocode}
% Standard.
%    \begin{macrocode}
        draw tree stage,
      },
    )%
%    \end{macrocode}
% Apply the proof tree style, which sets keylists from both forest's defaults and our custom additions.
%    \begin{macrocode}
    proof tree,
%    \end{macrocode}
% \changes{v0.9.1}{2025-08-25}{Experimental tagging style, \texttt{ttableau}.}
% Isolate (partly) for now.
%    \begin{macrocode}
%<tag>    ttableau,
%    \end{macrocode}
% Insert user's preamble, empty or otherwise - this allows the user both to override our defaults (e.g.~by setting a non-empty proof statement or a custom format for line numbers) and to customise the tree using forest's facilities in the usual way - BUT customisations of the latter kind may or may not be effective, may or may not have undesirable - not to say chaotic - consequences, and may or may not cause compilation failures (structural changes, in particular, should be avoided completely).
%    \begin{macrocode}
    #1,
    [, name=proof statement @#2]%
  \endforest
}{}
%    \end{macrocode}
% ^^A >>>
% \end{environment}
% \end{environment}
%    \begin{macrocode}
\ExplSyntaxOn
%    \end{macrocode}
% \iffalse
%<*!debug>
% \fi
% \changes{v0.9}{}{Add support for \pkg{memoize} and utilise for documentation.}
% \begin{macro}{\__prooftrees_memoize:n}
% \begin{macro}{\__prooftrees_memoize:V}
% ^^A memoize <<<
%   Internal macro so we don't memoize \pkg{bussproofs}'s \texttt{prooftree} by mistake.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \__prooftrees_memoize:n #1
{
  \mmzset{
    auto = { #1 } { memoize },
  }
}
\cs_generate_variant:Nn \__prooftrees_memoize:n { V }
%    \end{macrocode}
% ^^A memoize >>>
% \end{macro}
% \end{macro}
% \iffalse
%</!debug>
% \fi
% ^^A delay to begindocument/before <<<
% Paid â memoize \pkg{bussproofs} \texttt{prooftree} \dots. 
%    \begin{macrocode}
\hook_gput_code:nnn { begindocument / before } { . }
{%
  \@ifpackageloaded{memoize}{
%<!debug>    \__prooftrees_memoize:V \prooftrees@enw
%    \end{macrocode}
% \changes{v0.9.1}{2025-08-25}{Adapt \pkg{memoize} config if tagging or provide conditional.}
%    \begin{macrocode}
%<tag>    \tag_if_active:T
%<tag>    {
%<tag>      \mmzset{direct~ccmemo~input=true,}
%<tag>    }
  }{
%<!debug>    \newif\ifmemoizing\memoizingfalse
  }
%    \end{macrocode}
% \iffalse
%<*tag>
% \fi
% \begin{macro}{\__tableau_property_ref_orig:nn}
% \begin{macro}{\__tableau_property_ref_orig:ee}
% \mbox{}
% \changes{v0.9.1}{2025-08-25}{Use \pkg{mmzx-ext} stuff if loaded, but don't require for now, anyway.}
%    \begin{macrocode}
  \@ifpackageloaded{memoize-ext}{
    \cs_new_eq:NN \__tableau_property_ref_orig:nn \__mmzx_property_ref_orig:nn
    \cs_new_eq:NN \c__tableau_nexpl_at_cctab  \c__mmzx_nexpl_at_cctab 
  }{
    \cs_new_eq:NN \__tableau_property_ref_orig:nn \property_ref:nn
%    \end{macrocode}
% Otherwise \dots
%
% \begin{macro}{\c__tableau_nexpl_at_cctab}
% \changes{v0.9.1}{2025-08-25}{Add \ecs{c__tableau_nexpl_at_cctab}.}
%   Not a macro but a constant.
%   Allow \texttt{@} and \pkg{expl3} syntax in memos, but don't change cat codes of spaces or newlines.
%    \begin{macrocode}
    \cctab_const:Nn \c__tableau_nexpl_at_cctab {
      \cctab_select:N \c_code_cctab 
      \makeatletter
      \int_set:Nn \tex_endlinechar:D { 13 }
      \char_set_catcode_space:n      { 9 }
      \char_set_catcode_space:n      { 32 }
      \char_set_catcode_active:n     { 126 } % tilde
    }
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
  }
  \cs_generate_variant:Nn \__tableau_property_ref_orig:nn {ee}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \iffalse
%</tag>
%<*!debug>
% \fi
% \changes{v0.9.1}{2025-08-27}{Use \pkg{unicode-math} rather than \pkg{amssymb} and \pkg{amstext} on Unicode engines, but, in any case, only load what's needed.}
%    \begin{macrocode}
  \cs_if_exist:NF \checkmark
  {
    \sys_if_engine_opentype:TF
    {
      \RequirePackage{unicode-math}
    }{
      \RequirePackage{amssymb}
    }
  }
  \cs_if_exist:NF \text
  {
    \sys_if_engine_opentype:TF
    {
      \RequirePackage{unicode-math}
    }{
      \RequirePackage{amstext}
    }
  }
%    \end{macrocode}
% \iffalse
%</!debug>
%<*tag>
% \fi
% \begin{macro}{\toksapp}
%   \changes{v0.9.1}{2025-08-28}{Add \cs{toksapp} using format definition of \cs{addto@hook}, in case this is not primitive/already defined.}
%   Copy of \LaTeX{}'s \cs{addto@hook}.
%   Not used if Lua\TeX{} is used, which defines it as a primitive, or if \pkg{collargs} is loaded (e.g.~for \pkg{memoize}), which provides a more complicated version.
%   David Carlisle: \url{https://chat.stackexchange.com/transcript/message/68194858#68194858}.
%    \begin{macrocode}
  \cs_if_free:NT \toksapp
  {
    \cs_new:Npn \toksapp#1#2{#1\expandafter{\the #1#2}}
  }
%    \end{macrocode}
% \end{macro}
% \iffalse
%</tag>
% \fi
%    \begin{macrocode}
}
%    \end{macrocode}
% ^^A delay to begindocument/before >>>
% \begin{macro}{\prooftrees@tableau@id}
%   \changes{v0.9.1}{2025-08-25}{Add \cs{prooftrees@tableau@id}.}
%   Not a macro, but no idea how to mark it in \pkg{ltxdoc} correctly. 
%    \begin{macrocode}
\newcount\prooftrees@tableau@id
%    \end{macrocode}
% \end{macro}
% \iffalse
%<*tag>
% \fi
% ^^A tagsupport <<<
% \begin{macro}{\if@ttableau@dadfygio}
%   \changes{v0.9.1}{2025-08-25}{Add \cs{if@ttableau@dadfygio}.}
%   for debugging tagging
%    \begin{macrocode}
\newif\if@ttableau@dadfygio
\@ttableau@dadfygiofalse
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\l__tableau_toks_tl}
%   \changes{v0.9.1}{2025-08-25}{Add \ecs{l__tableau_toks_tl}.}
%   Variable because I can't work out how to pass the toks directly.
%    \begin{macrocode}
\tl_new:N \l__tableau_toks_tl
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\prooftrees@tableau@toks}
%   \changes{v0.9.1}{2025-08-25}{Add \cs{prooftrees@tableau@toks}.}
%   Not a macro, but no idea how to mark it in \pkg{ltxdoc} correctly. 
%    \begin{macrocode}
\newtoks \prooftrees@tableau@toks
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\__tableau_pgftikz_tag_bbox:nnn}
% \begin{macro}{\__tableau_pgftikz_tag_bbox:enn}
% \mbox{}
%    \begin{macrocode}
\cs_new_nopar:Npn \__tableau_pgftikz_tag_bbox:nnn #1#2#3
{
  \__tableau_pgftikz_tag_bbox_aux:eenn
  {
    \__tableau_property_ref_orig:ee {#1}{xpos}
  }
  {
    \__tableau_property_ref_orig:ee {#1}{ypos}
  }
  {#2}{#3}
}
\cs_generate_variant:Nn \__tableau_pgftikz_tag_bbox:nnn {enn}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \begin{macro}{\__tableau_pgftikz_tag_bbox_aux:nnnn}
% \begin{macro}{\__tableau_pgftikz_tag_bbox_aux:eenn}
% \mbox{}
%    \begin{macrocode}
\cs_new_nopar:Npn \__tableau_pgftikz_tag_bbox_aux:nnnn #1#2#3#4
{
  \dim_to_decimal_in_bp:n {#1sp}
  \c_space_tl
  \dim_to_decimal_in_bp:n {#2sp}
  \c_space_tl
  \dim_to_decimal_in_bp:n {#1sp+#3}
  \c_space_tl
  \dim_to_decimal_in_bp:n {#2sp+#4}
}
\cs_generate_variant:Nn \__tableau_pgftikz_tag_bbox_aux:nnnn {eenn}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% Sockets. 
% No idea how to index.
% 
% I am not sure \texttt{init} does anything at all useful which couldn't be done better with a macro?
%    \begin{macrocode}
\socket_new:nn {tableaux/tagsupport/tableau/init}{0}
\socket_new:nn {tableaux/tagsupport/tableau}{2}
\socket_new:nn {tableaux/tagsupport/tableau/mmzx}{2}
\socket_new_plug:nnn {tableaux/tagsupport/tableau/init}{tag}
{
%    \end{macrocode}
% Can't use noop due to collection of mcs even if tagging suspended;
% \texttt{artifact} gets rid of these.
% I think some combination of:
%   \ecs{tag_suspend:n} \{\cs{tableau}\}
%   \ecs{tag_resume:n} \{\cs{tableau}\}
%   \ecs{luamml_ignore:}
% should work, but I have no idea how to get it right.
% I also suspect I'm not \emph{meant} to get rid of mcs, but the result is so horribly chaotic otherwise.
%
% Assigning these \pkg{labex-lab} plugs prevents the chaos of errors produced by the defaults.
% Basically, if the tableau will involve $n$ \texttt{tikzpicture} environments, we have to completely ignore the first $n-1$, even though this means we also lose all marked content.
%    \begin{macrocode}
  \socket_assign_plug:nn {tagsupport/tikz/picture/begin}{artifact}
  \socket_assign_plug:nn {tagsupport/tikz/picture/end}{artifact}
}
%    \end{macrocode}
% Shamelessly copied from \pkg{latex-lab}.
%    \begin{macrocode}
\socket_new_plug:nnn {tableaux/tagsupport/tableau}{alt}
{
  \tag_mc_end_push:
  \tag_struct_begin:n
  {
    tag=Figure,
    alt=\l__tableau_toks_tl
  }
%    \end{macrocode}
% \begin{macro}{\prooftrees@tableau@mark@pos@\the\prooftrees@tableau@id}
%   Modified version of the \pkg{latex-lab} code as we can't use \pkg{pgf} \texttt{remember picture} etc.
%    \begin{macrocode}
  \cs_new:cpe {prooftrees@tableau@mark@pos@\the\prooftrees@tableau@id}
  {
    \__tableau_pgftikz_tag_bbox:enn {prooftrees-tableau-id\the\prooftrees@tableau@id}
    {#1}{#2}
  }
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
  \tag_struct_gput:ene
  {\tag_get:n {struct_num}}
  {attribute}
  {
    /O /Layout /BBox~
    [
      \use:c
      {prooftrees@tableau@mark@pos@\the\prooftrees@tableau@id}
    ]
  }
  \tag_struct_end:
  \tag_mc_begin_pop:n{}
}
%    \end{macrocode}
% A version of the above which appends to the context memo rather than executing the code.
% For \texttt{alt}, externalisation seems to work at least somewhat with tagging.
% (Also \texttt{actualtext}.
% That seems a bad choice for a tableau, but could be provided if required.)
% But it changes the structure, so I'm not at all sure here.
% 
% This requires modifying the cat code regime inside the context memo (or providing 2e-style names for all the cases where these aren't available, including ones internal to \pkg{prooftrees}.
%
% Somewhere, the memoization code introduces extra space when tagging, but since it doesn't work properly anyway, I find myself lacking the will to pin it down.
% Not even the non-memoized version works, for that matter, so worrying about this version is for the birds' birds, indeed.
%    \begin{macrocode}
\socket_new_plug:nnn {tableaux/tagsupport/tableau/mmzx}{alt}
{
  \gtoksapp\mmzCCMemo{
    \csname cctab_begin:c\endcsname {c__tableau_nexpl_at_cctab}
    \global\advance\prooftrees@tableau@id~by~1\relax
    \tex_savepos:D
    \property_record:ee {prooftrees-tableau-id\the\prooftrees@tableau@id}
    {xpos,ypos}
    \tex_savepos:D
    \tag_mc_end_push:
    \tag_struct_begin:n
  }
  \xtoksapp\mmzCCMemo{
    \c_left_brace_str
    tag=Figure,
    alt=
    \c_left_brace_str
  }
  \exp_args:NNV \gtoksapp\mmzCCMemo \l__tableau_toks_tl
  \xtoksapp\mmzCCMemo{
    \c_right_brace_str
    \c_right_brace_str
  }
  \gtoksapp\mmzCCMemo{
    \cs_new:cpe {prooftrees@tableau@mark@pos@\the\prooftrees@tableau@id}
    {
      \__tableau_pgftikz_tag_bbox:enn {prooftrees-tableau-id\the\prooftrees@tableau@id}
      {#1}{#2}
    }
    \tag_struct_gput:ene
    {\tag_get:n {struct_num}}
    {attribute}
    {
      /O /Layout /BBox~
      [
        \use:c
        {prooftrees@tableau@mark@pos@\the\prooftrees@tableau@id}
      ]
    }
    \tag_struct_end:
    \tag_mc_begin_pop:n{}
    \cctab_end:
  }
}
%    \end{macrocode}
% \begin{macro}{\prooftrees@ttableau@init}
% \begin{macro}{\__tableau_ttableau_init:}
% \changes{v0.9.1}{2025-08-25}{Added \ecs{__tableau_ttableau_init:}.}
%   I think I don't really get the ‘plug’ concept.
%   It is surely pointless to assign and immediately use one in a package which defines the relevant socket?
%   That is, wouldn't a macro or just the code do equally well but faster?
% \iffalse
%</tag>
% \fi
%    \begin{macrocode}
%<!debug>\cs_new_nopar:Npn \__tableau_ttableau_init: 
%<debug>\cs_set_nopar:Npn \__tableau_ttableau_init: 
{
%    \end{macrocode}
% \iffalse
%<*!debug>
% \fi
%    \begin{macrocode}
  \tag_if_active:T{
    \PackageError{prooftrees}{Prooftrees~is~currently~incompatible~with~
      tagging.~
      The~safest~approach~is~to~compile~tableaux~standalone~and~include~
      as~images~with~detailed~alt~text.
    }{Since~you~insist,~you~can~enable~basic~tagging~support~by~loading~
      prooftrees-debug~after~prooftrees.~
      The~code~certainly~requires~LuaLaTeX~and~probably~produces~an~
      invalid~structure,~but~verapdf~validates~it~and~the~code~produces~
      alt~text~automatically.~
      I~do~not~know~how~to~make~the~structure~valid.~
      For~a~logic~package,~this~is~doubly~unfortunate.
    }
    \def\forest##1\endforest{Tableau~\the\prooftrees@tableau@id}
  }
%    \end{macrocode}
% \iffalse
%</!debug>
%<*tag>
% \fi
%    \begin{macrocode}
  \tag_if_active:TF{
    \forestset{tag=1}
    \global\prooftrees@tableau@toks{}
%<debug>    \if@ttableau@dadfygio 
%<debug>      \typeout{Tagging~is~active.}
%<debug>      \forestset{
%<debug>        debug~tagging/.code={
%<debug>          \typeout{[Tag~tableau~debug]::~##1}
%<debug>        },
%<debug>      }
%<debug>      \typeout{Assigning~and~using~tag~plug~to~socket~
%<debug>        tableaux/tagsupport/tableau/init.
%<debug>      }
%<debug>    \fi
    \socket_assign_plug:nn {tableaux/tagsupport/tableau/init}{tag}
    \socket_use:n {tableaux/tagsupport/tableau/init}
    \def\pgfsys@begin@text{}
    \def\pgfsys@end@text{}
  }{
    \forestset{tag=0}
%<debug>    \if@ttableau@dadfygio 
%<debug>      \typeout{Tagging~is~not~active.}
%<debug>    \fi
  }
%    \end{macrocode}
% \iffalse
%</tag>
% \fi
%    \begin{macrocode}
}
%<!debug>\cs_new_eq:NN \prooftrees@ttableau@init \__tableau_ttableau_init:
%<debug>\cs_set_eq:NN \prooftrees@ttableau@init \__tableau_ttableau_init:
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \begin{macro}{\prooftrees@ttableau}
% \begin{macro}{\__tableau_ttableau:nnn}
% \changes{v0.9.1}{2025-08-25}{Added \ecs{__tableau_ttableau:nnn}, \cs{prooftrees@ttableau}.}
% \mbox{}
%    \begin{macrocode}
%<!debug> \cs_new_nopar:Npn \__tableau_ttableau:nnn #1#2#3
%<debug&tag>  \cs_set_nopar:Npn \__tableau_ttableau:nnn #1#2#3
{
%    \end{macrocode}
% \iffalse
%<*tag>
% \fi
%    \begin{macrocode}
% ^^A \tag_resume:n {\tableau}
  \tex_savepos:D
  \property_record:ee {prooftrees-tableau-id\the\prooftrees@tableau@id}
  {xpos,ypos}
  \tex_savepos:D
  \tl_set:No \l__tableau_toks_tl {\the\prooftrees@tableau@toks}
  \socket_assign_plug:nn {tableaux/tagsupport/tableau}{#1}
  \ifmemoizing
    \socket_assign_plug:nn {tableaux/tagsupport/tableau/mmzx}{#1}
  \fi
  \socket_use:nnn {tableaux/tagsupport/tableau} {#2}{#3}
  \socket_use:nnn {tableaux/tagsupport/tableau/mmzx} {#2}{#3}
% ^^A  \tag_suspend:n {\tableau}
%    \end{macrocode}
% \iffalse
%</tag>
% \fi
%    \begin{macrocode}
}
%<!debug> \cs_new_eq:NN \prooftrees@ttableau \__tableau_ttableau:nnn
%<debug&tag>  \cs_set_eq:NN \prooftrees@ttableau \__tableau_ttableau:nnn
%    \end{macrocode}
% \end{macro}
% \end{macro}
% ^^A tagsupport >>>
% \iffalse
% \fi
%    \begin{macrocode}
\ExplSyntaxOff
%    \end{macrocode}
% \iffalse
%</sty>
% \fi
%^^A sty guards >>>
% 
%^^A doc guards <<<
% \iffalse
%<*doc>
\RequirePackage{svn-prov}
\def\GetFileBaseName#1-#2\nil{#1}
\edef\MyFileBaseName{\expandafter\GetFileBaseName\jobname\nil}
\ProvidesFileSVN[\MyFileBaseName-doc]{$Id: prooftrees.dtx 11204 2025-09-04 03:23:15Z cfrees $}[v0.9 \revinfo]
\DefineFileInfoSVN
\AddToHook{begindocument}{\OnlyDescription}
% ^^A \expandafter\newif\csname ifprooftreescodetoo\endcsname
% ^^A \prooftreescodetoofalse
\input{\MyFileBaseName.dtx}
%</doc>
% \fi
%^^A doc guards >>>
% 
%^^A doc-code guards <<<
% \iffalse
%<*doc-code>
\RequirePackage{svn-prov}
\def\GetFileBaseName#1-#2\nil{#1}
\edef\MyFileBaseName{\expandafter\GetFileBaseName\jobname\nil}
\ProvidesFileSVN[\MyFileBaseName-code]{$Id: prooftrees.dtx 11204 2025-09-04 03:23:15Z cfrees $}[v0.9 \revinfo]
\DefineFileInfoSVN
\AddToHook{begindocument}{\AlsoImplementation}
% ^^A \expandafter\newif\csname ifprooftreescodetoo\endcsname
% ^^A \prooftreescodetootrue
\input{\MyFileBaseName.dtx}
%</doc-code>
% \fi
%^^A doc-code guards >>>
% 
% \loadgeometry{safonol}%
% \fancyheadoffset[lh]{0pt}%
% 
%\Finale
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%^^A vim: et:tw=0:sw=2:ts=2:foldmethod=marker:fmr=<<<,>>>:
