% \CheckSum{2502}
% \iffalse meta-comment
%
% Copyright 1993, 1994, 1995, 1996 Alan Jeffrey,
% hacked and maintained 1997, 1998 Sebastian Rahtz,
% copyright 1998, 1999, 2000 the fontinst maintenance team and any 
% individual authors listed elsewhere in this file.  All rights reserved.
% 
% This file is part of the fontinst system version 1.9.
% -----------------------------------------------------
% 
% It may be distributed under the terms of the LaTeX Project Public
% License, as described in lppl.txt in the base LaTeX distribution.
% Either version 1.1 or, at your option, any later version.
% 
%%% From file: ficonv.dtx
%
%<*driver>
\documentclass{ltxdoc}
\usepackage{fisource}
\title{The \package{fontinst} utility}
\author{Alan Jeffrey, Sebastian Rahtz, Ulrik Vieth, Lars Hellstr\"om}
\begin{document}
\maketitle
\tableofcontents
\DocInput{ficonv.dtx}
\end{document}
%</driver>
% \fi
%
% \StopEventually{}
%
% \section{Basic file format conversions}
% \label{Sec:Conv. input}
% \changes{1.902}{1999/05/01}{Collected the material in Section 
%    \thesection\space and moved it to \texttt{ficonv.dtx}. (LH)}
% \changes{1.926}{2003/07/12}{Added some missing \textasciitilde's
%     at ends of lines. (LH)}
%
% \subsection{Converting an ENC file to an ETX file}
%
% \DescribeMacro{\enctoetx}
% The macro
% \begin{quote}
%    |\enctoetx|\marg{encfile}\marg{etxfile}
% \end{quote}
% reads \meta{encfile}|.enc| and writes the same information to 
% \meta{etxfile}|.etx|, in a format \TeX{} can read more easily.
%
%
%    \begin{macrocode}
%<*misc>
\newif\ifmissingslots
\x_cs\def{o-.notdef}#1{\global\missingslotstrue}
%    \end{macrocode}
%
% \begin{macro}{\enctoetx}
%   For every |/|\meta{glyph} command, the command |\o-|\meta{glyph} 
%   gets passed code which writes the corresponding 
%   |\setslot|\marg{glyph} \textellipsis\ |\endslot| statement.
%   Normally that constrol sequence is undefined, hence equivalent to 
%   |\relax|, and thus the code gets executed. However |\o-.notdef| will 
%   instead gobble this argument and set |missingslots| to true.
%    \begin{macrocode}
{
   \catcode`\/=\active
   \catcode`\]=\active
   \gdef\enctoetx#1#2{{
      \catcode`\/=\active
      \catcode`\]=\active
      \def/##1[{
         \encname_to_etx ##1~{#1}{#2}
         \a_count=0
         \global\missingslotsfalse
         \let/=\encslot_to_etx
      }
      \def]~def{}
      \make_etx{#1}{#2}
   }}
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\encname_to_etx}
%   This macro recieves the encoding vector name, the ENC file name, 
%   and the ETX file name when converting an ENC file to an ETX file. 
%   The call syntax is
%   \begin{quote}
%     |\encname_to_etx|\meta{vectorname}\textvisiblespace
%     \marg{enc}\marg{etx}
%   \end{quote}
%   (making the first argument space-delimited but the second 
%   undelimited is a trick to gobble any space that may be present at 
%   the end of that which the caller thinks is the vector name).
%   
%   The command outputs a |\declarepsencoding| command to the 
%   generated ETX file.
%   \changes{1.931}{2005/05/13}{Macro added, to support caching 
%      original ENC names in autogenerated ETX files. (LH) 
%      Thanks to Alexej Kryukov for the inspiration for this.}
%    \begin{macrocode}
\def\encname_to_etx#1~#2#3{
   \out_line{\percent_char\space REMOVE~THE~FOLLOWING~LINE~IF~
      THIS~FILE~IS~MODIFIED~OR~RENAMED.}
   \out_line{\string\declarepsencoding{#3}{#1}{\string\download{#2.enc}}}
   \out_line{}
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\encslot_to_etx}
%   This macro grabs everything up to the next space and writes a 
%   |\setslot| entry with the grabbed material as glyph name. It is 
%   used as the definition of |/| (active character) when parsing 
%   elements of an encoding vector.
%   \changes{1.931}{2005/05/13}{Macro added (separated from 
%      \cs{enctoetx}). (LH)}
%    \begin{macrocode}
\def\encslot_to_etx#1~{
   \csname o-#1\endcsname{
      \ifmissingslots
         \out_line{\string\nextslot{\the\a_count}}
      \fi
      \global\missingslotsfalse
      \out_line{\string\setslot{#1}}
      \out_line{\string\endsetslot}
      \out_line{}
   }
   \advance\a_count by 1
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\make_etx}
%   |\make_etx| does the stuff that |\enctoetx| does not; it handles 
%   writing the preamble and postamble of the ETX file, but also does 
%   the actual |\input| of the ENC file to convert.
%   \changes{1.931}{2005/05/13}{Now requiring a particular 
%      \package{fontdoc} version. (LH)}
%    \begin{macrocode}
\def\make_etx#1#2{
   \open_out{\temp_prefix#2.etx}
   \out_line{\percent_char~Filename:~#2.etx}
   \out_line{\percent_char~Created~by:~tex~\jobname}
   \out_line{\percent_char~Created~using:~\string\enctoetx{#1}{#2}}
   \out_line{}
   \out_line{\percent_char~This~file~contains~the~
      information~of~#1.enc~in~a~form}
   \out_line{\percent_char~more~easily~read~by~TeX.~
      It~is~used~by~the~fontinst~package.}
   \out_line{}
   \out_line{\percent_char~THIS~FILE~CAN~BE~DELETED.}
   \out_line{}
   \out_line{\string\relax}
   \out_line{}
   \out_line{\string\documentclass[twocolumn]{article}}
   \out_line{\string\usepackage{fontdoc}[2005/05/13]}
   \out_line{}
   \out_line{\string\begin{document}}
   \out_line{}
   \out_line{This~document~describes~the~#1~encoding.}
   \out_line{It~was~automatically~generated~by~the}
   \out_line{\string\texttt{fontinst}~package.}
   \out_line{}
   \out_line{\string\encoding}
   \out_line{}
   \out_line{\string\needsfontinstversion{\fontinstversion}}
   \out_line{}
   \primitiveinput #1.enc\x_relax
   \out_line{}
   \out_line{\string\end encoding}
   \out_line{}
   \out_line{\string\end{document}}
   \close_out{Encoding}
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Converting an ETX file to an ENC file}
% \changes{1.911}{1999/11/21}{ETX to ENC converter added. (LH)}
% 
% \DescribeMacro{\etxtoenc}
% The command
% \begin{quote}
%    |\etxtoenc|\marg{etxfile}\marg{encfile}
% \end{quote}
% reads \meta{etxfile}|.etx| and generates a postscript encoding file 
% \meta{encfile}|.enc| that specifies the same encoding vector.
% 
% 
% \begin{macro}{\notdef_name}
%   This macro holds the name of the \texttt{.notdef} glyph, which must 
%   be put in all encoding positions where there is no other glyph.
%    \begin{macrocode}
\def\notdef_name{.notdef}
%    \end{macrocode}
% \end{macro}
% 
% 
% \begin{macro}{\etxtoenc}
%   The conversion has three steps. First the \texttt{.notdef} glyph is 
%   assigned to every slot in the encoding, then the ETX file is read 
%   and the assignments are changed for the slots which are not 
%   unassigned in the encoding, and finally the ENC file is written. 
%   The first two steps are carried out by |\etxtoenc|, but the final 
%   step is handled by |\make_enc|.
%   \changes{1.927}{2004/07/12}{Made the \meta{etxfile} argument a 
%     comma-separated list of ETX files. Changed \cs{do_slot} definition 
%     to get set rather than reset semantics. (LH) Feature requested 
%     by Werner Lemberg.}
%    \begin{macrocode}
\def\etxtoenc#1#2{\begingroup
   \a_count=\z@
   \loop
      \x_cs\let{name-\the\a_count}=\notdef_name
   \ifnum \@cclv>\a_count
      \advance \a_count \@ne
   \repeat
   \def\do_slot{
      \x_cs\ifx{name-\the\slot_number}\notdef_name
         \x_cs\edef{name-\the\slot_number}{\slot_name}
      \fi
   }
   \process_csep_list\inputetx #1,\process_csep_list,
   \make_enc{#1}{#2}
\endgroup}
%    \end{macrocode}
% \end{macro}
% 
% 
% \begin{macro}{\make_enc}
%    The command
%    \begin{quote}
%      |\make_enc|\marg{etxfiles}\marg{encfile}
%    \end{quote}
%    creates the file \meta{encfile}|.enc| and writes to that file the 
%    definition of the postscript encoding vector which corresponds to 
%    the encoding currently stored in the |\name-|\meta{slot} family of 
%    macros. That encoding is assumed to be defined by the files listed
%    in the \meta{etxfiles}.
%    
%    \changes{1.911}{1999/12/02}{Storing encoding name in string 
%       \texttt{encodingname}, thus allowing the ETX file to override 
%       the default. (LH)}
%    \changes{1.912}{2000/02/12}{Also calling \cs{declarepsencoding} 
%       once the encoding file has been written. (LH)}
%    \changes{1.914}{2000/05/14}{Not writing an \texttt{address} entry 
%       if that string isn't set. (LH)}
%    \changes{1.919}{2001/08/02}{Added DSC comments. (LH)}
%    \changes{1.927}{2004/07/12}{Modified to handle a comma-separated 
%      list of ETX files. (LH)}
%     \begin{macrocode}
\def\make_enc#1#2{
   \setstr{encodingname}{fontinst-autoenc-#1}
   \def\a_macro##1{
      \add_to\b_macro{##1.etx}
      \def\a_macro####1{
         \add_to\b_macro{,~####1.etx}
      }
   }
   \let\b_macro\empty_command
   \process_csep_list\a_macro #1,\process_csep_list,
   \open_out{#2.enc}
   \out_line{\percent_char !PS-Adobe-3.0~Resource-Encoding}
   \out_line{\percent_char\space @psencodingfile\left_brace_char}
   \ref_to_sourcefile{author}\b_macro
   \ref_to_sourcefile{version}\b_macro
   \out_line{\percent_char\four_spaces date~=~"generated~
      \the\year/
      \ifnum10>\month0\fi\the\month/
      \ifnum10>\day0\fi\the\day",}
   \out_line{\percent_char\four_spaces filename~=~"\out_filename",}
   \ref_to_sourcefile{email}\b_macro
   \ifisstr{address}\then
      \out_line{\percent_char\four_spaces address~=~\str{address}}
   \fi
   \out_line{\percent_char\four_spaces codetable~=~"ISO/ASCII",}
   \out_line{\percent_char\four_spaces checksum~=~"",}
   \out_line{\percent_char\four_spaces abstract~=~"
      This~is~a~postscript~encoding~file,~automatically~
      generated~by~fontinst~from~\b_macro."}
   \out_line{\percent_char\space\right_brace_char}
   \out_line{}
   \out_line{\percent_char\space Created~by:~tex~\jobname}
   \out_line{\percent_char\space Created~using:~
      \string\etxtoenc{#1}{#2}}
   \out_line{}
   \out_line{\percent_char\space This~file~should~be~installed~
      somewhere~that~your~DVI}
   \out_line{\percent_char\space to~postscript~driver~looks~for~files.~
      It~is~needed~for}
   \out_line{\percent_char\space reencoding~some~font~you~have~
      transformed.}
   \out_line{}
   \out_line{\percent_char\space After~installing~this~file,~you~
      should~add~the~following}
   \out_line{\percent_char\space line~(minus~\percent_char)~
      to~your~finstmsc.rc~file:}
   \out_line{\percent_char\space\string\declarepsencoding
      {#1}{\str{encodingname}}{\string\download{\out_filename}}}
   \edef\a_macro{
      \noexpand\declarepsencoding{#1}{\str{encodingname}}
         {\noexpand\download{\out_filename}}
   }
   \a_macro
   \out_line{}
   \out_line{\percent_char\percent_char BeginResource:~
      encoding~\str{encodingname}}
   \out_line{/\str{encodingname}\space[}
   \b_count=8
   \a_count=\z@
   \loop
      \ifnum 8=\b_count
         \b_count=\z@
         \out_line{\percent_char\space\the\a_count}
      \fi
      \out_line{/\csname name-\the\a_count \endcsname}
   \ifnum \@cclv>\a_count
      \advance \a_count \@ne
      \advance \b_count \@ne
   \repeat
   \out_line{]~def}
   \out_line{\percent_char\percent_char EndResource}
   \out_line{}
   \out_line{\percent_char\space End~of~file~\out_filename.}
   \close_out{Encoding~vector}
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\ref_to_sourcefile}
%   The command
%   \begin{quote}
%     |\ref_to_sourcefile|\marg{field}\marg{sourcefile}
%   \end{quote}
%   writes a \meta{field} field of a \BibTeX-style header to the 
%   current main output file. If the string named \meta{field} is set 
%   then the value for this field will be that string, and if it isn't 
%   set then the value will be the string \texttt{"See file }^^A
%   \meta{sourcefile}\texttt{"}. Note that the string \#1 is not 
%   quoted, so it must contain the quotes if it isn't simply an integer.
%    \begin{macrocode}
\def\ref_to_sourcefile#1#2{
   \ifisstr{#1}\then
      \out_line{\percent_char\four_spaces #1~=~\str{#1},}
   \else
      \out_line{\percent_char\four_spaces #1~=~"See~file~#2",}
   \fi
}
%    \end{macrocode}
% \end{macro}
%
% 
% \subsection{Converting an ETX file to CMAP file}
% \changes{1.928}{2004/11/28}{ETX to CMAP converter added. (LH)}
% 
% \DescribeMacro{\etxtocmap}
% The command
% \begin{quote}
%    |\etxtocmap|\marg{etxfile}\marg{cmapfile}
% \end{quote}
% reads \meta{etxfile}|.etx| and generates a ToUnicode CMap file 
% \meta{cmapfile}|.cmap| that maps slots to Unicode strings as 
% specified by the \meta{etxfile}.
% 
% \begin{macro}{\write_cmap_body}
%    The |\write_cmap_body| command writes the actual CMap 
%    data\footnote{As opposed to silly stuff that is requested by the 
%    file format specification but probably isn't of any use for 
%    anything, which is written by \cs{ref_to_sourcefile}.} to the 
%    current output file. The syntax is
%    \begin{quote}
%      |\write_cmap_body|\marg{etxfile}
%    \end{quote}
%    
%    More precisely, what this command writes is the codespace range 
%    specification and the mappings. The latter are all encoded using 
%    \texttt{bfchar} operators. 
%     \begin{macrocode}
\def\write_cmap_body#1{
   \out_line{1~begincodespacerange~<00>~<FF>~endcodespacerange}
   \let\do_slot=\_a_true
   \def\Unicode##1##2{\cmap_charseq{\cmap_codepoint{##1}{##2}}}
   \let\charseq=\cmap_charseq
   \inputetx{#1}
}
%    \end{macrocode}
% \end{macro}
% 
% 
% \begin{macro}{\cmap_codepoint}
%   This is what |\Unicode| is inside a |\charseq|. It appends a 
%   UTF-16BE character in hexadecimal notation (either four hex 
%   digits for a character in the BMP, or eight hex digits for 
%   a surrogate pair) to |\a_macro|, and also appends a space for 
%   grouping the digits for easier reading.
%   \changes{1.928}{2004/12/05}{Added \cs{uppercase} to ensure case 
%     independence. (LH)}
%    \begin{macrocode}
\def\cmap_codepoint#1#2{
   \uppercase{\a_count="#1\x_relax}
   \ifnum "10000>\a_count
      \format_hex\b_macro{\a_count}{4}
      \edef\a_macro{\a_macro \b_macro \space}
   \else
      \advance \a_count -"10000
      \d_count=\a_count
      \divide \a_count "400
      \b_count=\a_count
      \multiply \b_count "400
      \advance \d_count -\b_count
      \advance \a_count "D800
      \advance \d_count "DC00~
      \format_hex\b_macro{\a_count}{4}
      \format_hex\c_macro{\d_count}{4}
      \edef\a_macro{\a_macro \b_macro \c_macro \space}
   \fi
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\cmap_charseq}
%   This macro is what |\charseq| is when generating a CMap; all 
%   writing of CMap entries is routed through it. Only the first 
%   character equivalent of each slot should get written to file, so 
%   the |_a_| switch is used for keeping track of whether this would be 
%   the first.
%   
%    \begin{macrocode}
\def\cmap_charseq#1{%
   \if_a_
      \bgroup
         \let\Unicode=\cmap_codepoint
         \let\a_macro=\empty_command
         #1
         \format_hex\b_macro{\slot_number}{2}
         \out_line{1~beginbfchar~<\b_macro>~<~\a_macro>~endbfchar}
      \egroup
      \_a_false
   \fi
}
%    \end{macrocode}
% \end{macro}
% 
% 
% 
% 
% \begin{macro}{\etxtocmap}
%   As usual for macros with this kind of name, this is the user 
%   level command to call to generate a CMAP from an ETX. The 
%   arguments are file names (not including extensions).
%    \begin{macrocode}
\def\etxtocmap#1#2{\begingroup
   \inputetx{#1}
   \open_out{#2.cmap}
   \out_line{\percent_char !PS-Adobe-3.0~Resource-CMap}
   \out_line{\percent_char\percent_char
     DocumentNeededResources:~procset~CIDInit}
   \out_line{\percent_char\percent_char
     IncludeResource:~procset~CIDInit}
%    \end{macrocode}
%   Here comes the first problem: the CMap must have a name. If the ETX 
%   file sets the string variable \texttt{cmapname} then that is used 
%   as name, but otherwise |fontinst-|\meta{cmapfile} is used as name. 
%   Note that this is different from the pattern in |\etxtoenc|, which 
%   instead uses the \meta{etxname}.
%    \begin{macrocode}
   \setstr{cmapname}{fontinst-#2}
   \out_line{\percent_char\percent_char
     BeginResource:~CMap~\str{cmapname}}
%    \end{macrocode}
%   The next problem is whether one should bother with the quite 
%   extensive version control junk that Adobe has specified. I prefer 
%   not to, because it is very much geared towards using CMaps with 
%   CIDFonts, which is not the case here.
%   
%   Thus it is time for the actual PS code.
%    \begin{macrocode}
   \out_line{/CIDInit~/ProcSet~findresource~begin}
   \out_line{7~dict~begin}
   \out_line{begincmap}
   \out_line{/CMapName~/\str{cmapname}~def}
   \out_line{/CMapType~2~def}
   \write_cmap_body{#1}
   \out_line{endcmap}
   \out_line{CMapName~currentdict~/CMap~defineresource~pop}
   \out_line{end}
   \out_line{end}
   \out_line{\percent_char\percent_char EndResource}
   \out_line{\percent_char\percent_char EOF}
   \close_out{ToUnicode~CMap}
\endgroup}
%</misc>
%    \end{macrocode}
% \end{macro}
% 
% 
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \subsection{Converting an AFM file to an MTX file}
%
% \DescribeMacro{\afmtomtx}
% The macro
% \begin{quote}
%    |\afmtomtx|\marg{afmfile}\marg{mtxfile}
% \end{quote}
% reads \meta{afmfile}|.afm|, and writes the same information out to 
% \meta{mtxfile}|.mtx|.
%
% \begin{macro}{\afmtomtx}
%   \changes{1.911}{1999/11/18}{Changed setting of \cs{raw_font_name} 
%      to \cs{edef} and added setting of \cs{source_font_name}. (LH)}
%   \changes{1.917}{2001/03/13}{Added resetting of 
%      \cs{setsomething_global}---assignments made here must be 
%      local. (LH)}
%    \begin{macrocode}
%<*pkg>
\def\afmtomtx#1#2{{
   \let\setsomething_global=\x_relax
   \open_out{\temp_prefix#2.mtx}
   \edef\raw_font_name{#2}
   \edef\source_font_name{#1}
   \x_resetint{italicslant}{0}
   \let\italcorr_expression=\uprightitalcorr
   \x_setint{minimumkern}{0}
   \minimum_kern=\int{minimumkern}
   \out_line{\percent_char~Filename:~#2.mtx}
   \out_line{\percent_char~Created~by:~tex~\jobname}
   \out_line{\percent_char~Created~using:~\string\afmtomtx{#1}{#2}}
   \out_line{}
   \out_line{\percent_char~This~file~contains~the~
      information~of~#1.afm~in~a~form}
   \out_line{\percent_char~more~easily~read~by~TeX.~
      It~is~used~by~the~fontinst~package.}
   \out_line{}
   \out_line{\percent_char~THIS~FILE~CAN~BE~DELETED.}
   \out_line{}
   \out_line{\string\relax}
   \out_line{\string\metrics}
   \out_line{}
   \out_line{\string\needsfontinstversion{\fontinstversion}}
   \out_line{}
   \catcode`\^^M=12
   \catcode`\ =10
   \expandafter\afm_line\primitiveinput #1.afm\x_relax
   \out_line{}
   \out_line{\endmetrics_text}
   \close_out{Metrics}
}}
%    \end{macrocode}
% \end{macro}
%
% Kerns below this value are ignored.
%
%    \begin{macrocode}
\newcount\minimum_kern
%    \end{macrocode}
%
% 
% \begin{macro}{\afm_length}
%   \changes{1.900}{1998/12/28}{Macro added, other macros modified to 
%     use it. (LH)}
% \begin{macro}{\afm_unit_dimen}
%   The call |\afm_length|\meta{count}\marg{real} 
%   interprets the \meta{real} as a real number, rounds it to the 
%   nearest integer, and sets the \meta{count} (a |\count| register) 
%   to that integer. In this process, |\a_dimen| is used as a temporary 
%   storage.
%    \begin{macrocode}
\def\afm_length#1#2{
   \a_dimen=#2\afm_unit_dimen
   #1=\a_dimen
   \divide #1 by \afm_unit_dimen
   \advance \a_dimen by -#1\afm_unit_dimen
   \ifdim \a_dimen>0.5\afm_unit_dimen
      \advance #1 by 1
   \else \ifdim \a_dimen<-0.5\afm_unit_dimen
      \advance #1 by -1
   \fi\fi
   \x_relax
}
%    \end{macrocode}
%   The dimen |\afm_unit_dimen| is used to keep track of how long an AFM 
%   unit is interpreted as being in this routine. Lowering its value 
%   makes |\afm_length| capable of handling greater lengths but looses 
%   some very slight precision in the rounding, increasing the value 
%   has the opposite effects. The current value of 1000\thinspace sp 
%   means it reads lengths with three decimals accuracy (not very much 
%   use for them though as the number is rounded to zero decimals 
%   accuracy anyway, but it does make a difference when deciding how 
%   a \meta{real} like |0.502| should be rounded) and can handle lengths 
%   of an absolute value of a good million AFM units. This should be 
%   adequate in most cases. It is, by the way, probably wisest to keep 
%   it a power of ten scaled points in all cases, as this should reduce 
%   the rounding errors caused by various base conversions.
%    \begin{macrocode}
\newdimen\afm_unit_dimen
\afm_unit_dimen=1000sp
%    \end{macrocode}
% \end{macro}\end{macro}
% 
%
% The command |\afm_line| reads to the end of the line, calls
% |\afm_command| on that line, then calls |\afm_line| again.
%
%    \begin{macrocode}
{\catcode`\^^M=12 \gdef\afm_line#1
{\afm_command#1~\end_of_line\afm_line}}
%    \end{macrocode}
%
% The command |\afm_command| reads the first word \meta{FOO}, and 
% calls |\afm-|\meta{FOO}\describecsfamily{afm-\meta{key}}.  If this 
% does not exist, then |\gobble_one_line| will
% eat up the rest of the line.
%
%    \begin{macrocode}
\def\afm_command#1~{\csname~afm-#1\endcsname\gobble_one_line}
\def\gobble_one_line#1\end_of_line{}
%    \end{macrocode}
%
% This all stops when we reach the command |EndFontMetrics|.
%
%    \begin{macrocode}
\x_cs\def{afm-EndFontMetrics}#1\afm_line{\endinput}
%    \end{macrocode}
%
% \begin{macro}{\afm_def}
%   To define an AFM command, you say |\afm_def|\marg{command}^^A
%   \parg{pattern}\marg{result}
%   \begin{macrocode}
\def\afm_def#1(#2)#3{
   \x_cs\def{afm-#1}\gobble_one_line#2\end_of_line{#3}
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\afm_let}
%   Saying |\afm_let|\marg{dest-command}\marg{source-command} copies 
%   the definition of one AFM command to another.
%    \begin{macrocode}
\def\afm_let#1#2{
   \expandafter\let \csname afm-#1\expandafter\endcsname
      \csname afm-#2\endcsname
}
%    \end{macrocode}
% \end{macro}
%
% For example, we can define the following AFM commands:
% \changes{1.6}{1997/02/07}{AFM commands fixed, to get fontdimens 
%    comparable to EC fonts. (Thierry Bouche)}
% ^^A (Fixed by Thierry Bouche 
% ^^A 1997/02/07, to get fontdimens comparable to EC fonts.)
% \changes{1.912}{2000/02/20}{AFM command \texttt{StdVW} now 
%    interpreted: generates \cs{setint} for integer 
%    \texttt{verticalstem}. (LH)}
%
%    \begin{macrocode}
\afm_def{CharWidth}(#1){\afm_length\char_x_width{#1}}
\afm_def{ItalicAngle}(#1~){\calculate_it_slant{#1}}
\afm_def{XHeight}(#1){
   \afm_length\a_count{#1}
   \out_line{\string\setint{xheight}{\the\a_count}}}
\afm_def{CapHeight}(#1){
   \afm_length\a_count{#1}
   \out_line{\string\setint{capheight}{\the\a_count}}}
\afm_def{Ascender}(#1){
   \afm_length\a_count{#1}
   \out_line{\string\setint{ascender}{\the\a_count}}}
\afm_def{Descender}(#1){
   \afm_length\a_count{#1}
   \out_line{\string\setint{descender_neg}{\the\a_count}}}
\afm_def{UnderlineThickness}(#1){
   \afm_length\a_count{#1}
   \out_line{\string\setint{underlinethickness}{\the\a_count}}}
\afm_def{FontBBox}(#1~#2~#3~#4){
   \afm_length\a_count{#4}
   \out_line{\string\setint{maxheight}{\the\a_count}}
   \afm_length\a_count{#2}
   \out_line{\string\setint{maxdepth_neg}{\the\a_count}}}
\afm_def{StdVW}(#1){
   \afm_length\a_count{#1}
   \out_line{\string\setint{verticalstem}{\the\a_count}}}
\afm_def{IsFixedPitch}(#1){
   \if\first_char#1=f
   \else\out_line{\string\setint{monowidth}{1}}
   \fi
}
%    \end{macrocode}
% 
% \multchanges{\cs{afm_font_name}}{1.901}{1999/03/06}{Macro added. (LH)}
% \multchanges{\cs{afm_font_name}}{1.911}{1999/11/18}{Macro removed, 
%    since no longer needed. (LH)}
% 
% \begin{macro}{\afm-FontName}
%   The |FontName| of a font is needed for the |\storemapdata| command, 
%   so it is when that is encountered that this is written. This 
%   information is of no use when making TFMs and VFs, but it is likely 
%   to be of use for generation of map files, so it will be included in 
%   a file of recorded transforms, if such a file is being generated.
%    \begin{macrocode}
\afm_def{FontName}(#1~){
   \record_transform{\raw_font_name}
      {\string\fromafm{\source_font_name}{#1}}{}\iftrue
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\afm-KPX}
% \begin{macro}{\afm-KP}
%   Processing kern pairs.  If one of the glyph name starts with
%   a dot as in |.notdef| or |.null| the kern pair is ignored. 
%   The pair is also ignored if the absolute value of the kern 
%   amount is |\minimum_kern| or less.
%   
%   That \texttt{KPX} can have the same definition as \texttt{KP} is 
%   due to an edge case in the processing of AFM lines: |\afm_line| 
%   inserts an extra space at the end of a line. For \texttt{KPX} 
%   which really only has three arguments this extra space matches 
%   the space in |#3~#4|, whereas for \texttt{KP} which has four 
%   arguments this extra space appears at the end of |#4|.
%
%    \begin{macrocode}
\afm_def{KP}(#1~#2~#3~#4){
   \if\first_char#1=.\else
   \if\first_char#2=.\else
      \afm_length\a_count{#3}
      \ifnum \a_count>\minimum_kern
         \afm_write_setkern{#1}{#2}{\the\a_count}
      \else\ifnum \a_count<-\minimum_kern
         \afm_write_setkern{#1}{#2}{\the\a_count}
      \fi\fi
   \fi\fi
}
\afm_let{KPX}{KP}
%    \end{macrocode}
% \end{macro}\end{macro}
% 
% \begin{macro}{\afm_write_setkern}
%   This macro is a hook for the auto-aliasing mechanism to redefine. 
%   In this plain form, it just outputs a |\setkern| command with the 
%   given three arguments.
%   \changes{1.933}{2007/01/23}{Macro added. (LH)}
%    \begin{macrocode}
\def\afm_write_setkern#1#2#3{\out_line{\string\setkern{#1}{#2}{#3}}}
%    \end{macrocode}
% \end{macro}
%
% Processing char metrics.
%
%    \begin{macrocode}
\afm_def{C}(#1~;#2){\init_afm{#1}\do_list[#2]\afm_char}
%    \end{macrocode}
%    
% \begin{macro}{\afm-CH}
%   The |CH| keyword is like |C|, but signals that the following 
%   character code is given in hexadecimal.
%   \changes{1.933}{2007/01/22}{Proper definition, that parses the 
%      following hexadecimal value. (LH) Since noone has complained 
%      about this before, it's probably not very common.}
%    \begin{macrocode}
\afm_def{CH}(<#1>~;#2){\uppercase{\init_afm{"#1}}\do_list[#2]\afm_char}
%    \end{macrocode}
% \end{macro}
%
% Processing composite chars.
%
%    \begin{macrocode}
\afm_def{CC}(#1~#2~;#3){\init_cc{#1}\do_list[#3]\cc_char}
%    \end{macrocode}
%
% When parsing a character, we set the values of the following
% variables:
%
%    \begin{macrocode}
\newcount\char_slot
\newcount\char_x_width
\newcount\x_width
\newcount\bbox_llx
\newcount\bbox_lly
\newcount\bbox_urx
\newcount\bbox_ury
\let\char_name=\empty_command
%    \end{macrocode}
%
% \begin{macro}{\init_afm}
%   |\init_afm| initializes the variables the AFM character list 
%   writes to.
%    \begin{macrocode}
\def\init_afm#1{
   \char_slot=#1\x_relax
   \x_width=\char_x_width
   \bbox_llx=0
   \bbox_lly=0
   \bbox_urx=0
   \bbox_ury=0
   \let\char_name=\empty_command
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\afm_char}
%   This command is executed at the end of processing a \texttt{C} 
%   (or \texttt{CH}) line. It outputs the corresponding 
%   |\setrawglyph| or |\setnotglyph| command, based on information 
%   stored into registers when processing that line.
%   \changes{1.933}{2007/01/23}{Negating \cs{bbox_lly} using 
%      \cs{number} instead of an assignment to \cs{a_count}. (LH)}
%    \begin{macrocode}
\def\afm_char{
   \eval_expr{
      \italcorr_expression\x_width\bbox_llx\bbox_urx\bbox_lly\bbox_ury
   }
   \out_line{
      \ifnum -1<\char_slot
         \string\setrawglyph
      \else
         \string\setnotglyph
      \fi
      {\char_name}
      {\raw_font_name}
      {10pt}
      {\the\char_slot}
      {\the\x_width}
      {\the\bbox_ury}
      {\number -\bbox_lly}
      {\the\result}
   }
}
%    \end{macrocode}
% \end{macro}
%
% |\init_cc| and |\cc_char| write out a composite character glyph.
%
%    \begin{macrocode}
\def\init_cc#1{%
   \out_line{\string\setglyph{#1}}
   \def\char_name{#1}
}
\def\cc_char{%
   \out_lline{\string\samesize{\char_name-not}}
   \out_line{\string\endsetglyph}
}
%    \end{macrocode}
%
% 
% \changes{1.900}{1998/12/28}{Method of computing italic corrections 
%   changed to using an integer expression. (LH)}
% \DescribeMacro{\italcorr_expression}
% The way the italic correction is computed has been changed 
% quite a bit, although the computed values are still the same. 
% The point is that it is much simpler to modify the formula according 
% to which the value is computed using this method than using the 
% previous method.
% 
% The call
% \begin{quote}
%   |\italcorr_expression|\marg{width}\marg{left}^^A
%   \marg{right}\marg{bottom}\marg{top},
% \end{quote}
% where the arguments are \TeX\ \meta{number}s, should expand to an 
% integer expression. The value of that expression will be taken as the 
% italic correction of the current character.
% 
% \meta{width} is the width of the character. \meta{left}, 
% \meta{right}, \meta{bottom}, and \meta{top} are the respective 
% coordinates of the sides of the bounding box of the character. A 
% quantity which is not given as an argument, but which nontheless 
% might be of interest for a calculation of italic correction, is the 
% italic slant of the font. This quantity can be found in the fontinst 
% integer \texttt{italicslant}. (The MTX file written will also set 
% the integer \texttt{italicslant} to this value.)
% 
% \begin{macro}{\uprightitalcorr}
% \begin{macro}{\slanteditalcorr}
%   These two commands are what |\italcorr_expression| will get set 
%   to---the slanted version is used if the italic slant is positive and 
%   the upright version is used otherwise. The default definitions 
%   compute the same values as in fontinst v\,1.8, but the definitions 
%   can easily be modified using |\resetcommand|.
%    \begin{macrocode}
\def\uprightitalcorr#1#2#3#4#5{0}
\def\slanteditalcorr#1#2#3#4#5{\max{\sub{#3}{#1}}{0}}
%    \end{macrocode}
% \end{macro}\end{macro}
% 
% 
% \begin{macro}{\calculate_it_slant}
%   To set the italic angle, we need to calculate the tangent of the
%   angle that the |.afm| file contains.  This is done with David
%   Carlisle's \package{trig} macros.  Note that the \package{trig} 
%   macros don't like a space at the end of their argument.
%   
%   \changes{1.911}{1999/11/18}{Stripping off the space in 
%      \cs{afm-ItalicAngle}. (LH)}
% ^^A\question{\cs{afm_line} always inserts a space at the end of the line.} 
% ^^ACould we therefore save us a bit of trouble by simply changing the 
% ^^Apattern for |\ItalicAngle| to |(#1~)|? /LH
%
%    \begin{macrocode}
\def\calculate_it_slant#1{
   \edef\theangle{#1}
   \CalculateTan{\theangle}
   \a_dimen=-\one_thousand sp
   \a_dimen=\UseTan{\theangle}\a_dimen
   \a_count=\a_dimen
   \out_line{\string\setint{italicslant}{\the\a_count}}
   \x_resetint{italicslant}{\a_count}
   \ifnum 0<\a_count
      \let\italcorr_expression=\slanteditalcorr
   \else
      \let\italcorr_expression=\uprightitalcorr
   \fi
}
%    \end{macrocode}
%    \begin{macrocode}
% \def\strip_spaces#1~#2\end_strip_spaces{#1}
%    \end{macrocode}
% \end{macro}
%
% To process a list of commands separated by semi-colons, we call
% |\do_list[LIST]|.  This works in a similar way to |\afm_line|, but 
% the control sequence family used for decoding is 
% \describecsfamily{list-\meta{key}}|\list-|\meta{keyword} rather 
% than |\afm-|\meta{keyword}.
%
%    \begin{macrocode}
\def\do_list[~#1~#2;~#3]{
   \csname~list-#1\endcsname\gobble_one_semi#2;
   \ifx\x_relax#3\x_relax\expandafter\gobble_one
   \else\expandafter\identity_one\fi
   {\do_list[~#3]}
}
\def\gobble_one_semi#1;{}
%    \end{macrocode}
%
% There is an analagous |\list_def| for defining commands to be used
% inside lists.
%
%    \begin{macrocode}
\def\list_def#1(#2)#3{\x_cs\def{list-#1}\gobble_one_semi#2~;{#3}}
%    \end{macrocode}
%
% For example, these are the commands that are used in giving
% character metrics:
%
%    \begin{macrocode}
\list_def{W}(#1~#2){\afm_length\x_width{#1}}
\list_def{WX}(#1){\afm_length\x_width{#1}}
\list_def{WY}(#1){}
\list_def{N}(#1){\def\char_name{#1}}
\list_def{B}(#1~#2~#3~#4){
   \afm_length\bbox_llx{#1}
   \afm_length\bbox_lly{#2}
   \afm_length\bbox_urx{#3}
   \afm_length\bbox_ury{#4}
}
\list_def{PCC}(#1~#2~#3){
   \afm_length\a_count{#2}
   \afm_length\b_count{#3}
   \out_lline{\string\glyphpcc{#1}{\the\a_count}{\the\b_count}}
}
%    \end{macrocode}
% 
% \begin{macro}{\definealias}
%   The |\definealias| command can be used to define a glyph name 
%   alias, for generation of |\aliased| clauses in glyph names. The 
%   syntax is
%   \begin{quote}
%     |\definealias|\marg{alias name}\marg{font's name}\marg{int}
%   \end{quote}
%   where \meta{font's name} is the glyph name that if found in an 
%   AFM file should be converted to an |\aliased| clause using the 
%   \meta{alias name}. The \meta{int} is the name of an integer which 
%   will be incremented every time this alias applies to a glyph 
%   definition; this mechanism is meant to help higher level code 
%   pick an ETX file that fits the font's glyph names.
%   
%   \changes{1.933}{2007/01/22}{Command added. (LH)}
%   
%   Defined aliases are stored in the 
%   \describecsfamily{GN-\meta{font's name}}|\GN-|\meta{font's name} 
%   family of control sequences. These control sequences are defined 
%   to be macros expanding to the two tokens
%   \begin{quote}
%     |\g-|\meta{alias name}\,|\i-|\meta{int}
%   \end{quote}
%   In the case of |\g-|\meta{alias name}, this is purely a trick to 
%   save memory (it is very likely that these control sequences will 
%   anyway occur during the fontmaking part of the processing).
%    \begin{macrocode}
\def\definealias#1#2#3{
   \expandafter\def \csname GN-#1 \expandafter\endcsname
      \expandafter{ \csname g-#2 \expandafter\endcsname
      \csname i-#3\endcsname}
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\glyph_alias}
% \begin{macro}{\glyph_alias_i}
%   The |\glyph_alias| macro has the syntax
%   \begin{quote}
%     |\glyph_alias|\marg{font's name}
%   \end{quote}
%   It expands to the \meta{alias name} corresponding to the 
%   \meta{font's name}, that had previously been set up using 
%   |\definealias|. Where this macro is used, it must already have 
%   been checked that |\GN-|\meta{font's name} is defined.
%    \begin{macrocode}
\def\glyph_alias#1{
   \expandafter\expandafter \expandafter\glyph_alias_i
      \csname GN-#1\endcsname
}
\def\glyph_alias_i#1#2{
   \expandafter\gobble_three \string#1
}
%    \end{macrocode}
% \end{macro}\end{macro}
% 
%    \begin{macrocode}
\let\charnameprefix\empty
\def\charnamealias#1{
   \if_defined{GN-\charnameprefix#1}\then
      \glyph_alias{\charnameprefix#1}
   \else\if_defined{GN-#1}\then
      \glyph_alias{#1}
   \else
      #1
   \fi\fi
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def\alias_incr#1{
   \expandafter\expandafter \expandafter\alias_incr_i
      \csname GN-#1\endcsname
}
\def\alias_incr_i#1#2{
   \ifx#2\x_relax
      \mathchardef#2=\@ne
   \else
      \a_count=#2
      \advance\a_count\@ne
      \mathchardef#2=\a_count
   \fi
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def\alias_char_name#1{
   \if_defined{GN-\charnameprefix#1}\then
      \edef\char_name{
         \string\aliased{#1}{\glyph_alias{\charnameprefix#1}}
      }
      \alias_incr{\charnameprefix#1}
   \else\if_defined{GN-#1}\then
      \edef\char_name{
         \string\aliased{#1}{\glyph_alias{#1}}
      }
      \alias_incr{#1}
   \else
      \edef\char_name{#1}
   \fi\fi
}
\def\autoaliasafm{
   \begingroup
   \list_def{N}(##1){\alias_char_name{##1}}
   \def\afm_write_setkern##1##2##3{
      \out_line{
         \string\setkern{\charnamealias{##1}}{\charnamealias{##2}}{##3}
      }
   }
   \def\init_cc##1{%
      \edef\char_name{\charnamealias{##1}}
      \out_line{\string\setglyph{\char_name}}
   }
   \list_def{PCC}(##1~##2~##3){
      \afm_length\a_count{##2}
      \afm_length\b_count{##3}
      \out_lline{\string\glyphpcc
        {\charnamealias{##1}}{\the\a_count}{\the\b_count}}
   }
}
\def\endautoaliasafm{\endgroup}
%    \end{macrocode}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \subsection{Converting a PL file to an MTX file}
%
% \DescribeMacro{\generalpltomtx}The macro
% \begin{quote}
%   |\generalpltomtx|\marg{plfile}\marg{mtxfile}\marg{plsuffix}\relax
%   \marg{opt-enc}
% \end{quote}
% reads \meta{plfile}|.|\meta{plsuffix}, interprets it as having the 
% encoding specified by the file \meta{opt-enc}|.etx|, and writes the 
% same metric information out to \meta{mtxfile}|.mtx|. In case 
% \meta{opt-enc} is empty, the encoding will be determined using the 
% |CODINGSCHEME| property of the file being read. 
% \DescribeMacro{\pltomtx}The macro
% \begin{quote}
%    |\pltomtx|\marg{plfile}\marg{mtxfile}
% \end{quote}
% reads \meta{plfile}|.pl|, uses the |CODINGSCHEME| property in that 
% file to determine its encoding, and writes the same metric information 
% out to \meta{mtxfile}|.mtx|.
% 
% None of these commands can cope with |SKIP| properties in the (V)PL 
% file.
%
% \begin{macro}{\generalpltomtx}
%   \changes{1.902}{1999/05/01}{Command added, removed 
%     \cs{pltomtxgivenetx}. (LH)}
%   \changes{1.910}{1999/11/01}{Made this command the standard one, 
%      which \cs{pltomtx} calls. (UV\&LH)}
%   \changes{1.917}{2001/03/13}{Added resetting of 
%      \cs{setsomething_global}---assignments made here must be 
%      local. (LH)}
%   \changes{1.923}{2002/12/03}{Changed test of fourth argument to 
%      instead of \cs{ifx} use \cs{if}. This is more versatile. (LH)}
%    \begin{macrocode}
\def\generalpltomtx#1#2#3#4{{
   \let\setsomething_global=\x_relax
   \let\setfontdimen=\pl_setfontdimen
   \if _#4_ \else
      \def\do_slot{\x_cs\let{name-\the\slot_number}\slot_name}
      \def\do_boundary{\x_cs\let{name-BOUNDARYCHAR}\slot_name}
      \inputetx{#4}
      \let\CODINGSCHEME=\ignore_parens
   \fi
   \pl_to_mtx{#1}{#2}{#3}{\string\generalpltomtx{#1}{#2}{#3}{#4}}
}}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\pltomtx}
%    \begin{macrocode}
\def\pltomtx#1#2{\generalpltomtx{#1}{#2}{pl}{}}
%    \end{macrocode}
% \end{macro}
%
% 
% \begin{macro}{\pl_to_mtx}
%   \changes{1.911}{1999/11/19}{\cs{edef}ing \cs{raw_font_name}. (LH)}
%   The |\pl_to_mtx| macro contains all code that was common to 
%   |\pltomtx| and |\general|\-|pltomtx| before the former was redefined 
%   to a call of the latter. The structure of a call of |\pl_to_mtx| is
%   \begin{quote}
%     |\pl_to_mtx|\marg{plfile}\marg{mtxfile}\marg{plsuffix}\marg{call}
%   \end{quote}
%   \meta{call} is what should be written in the ``Created using:'' 
%   comment at the top of the MTX file written.
%   \changes{1.921}{2002/07/27}{\cs{fromvpl} in \cs{storemapdata} does
%     not have an argument. Fixed a bug that produced such an argument 
%     anyway. (LH)}
%    \begin{macrocode}
\def\pl_to_mtx#1#2#3#4{
   \edef\raw_font_name{#1}
   \open_out{\temp_prefix#2.mtx}
   \out_line{\percent_char~Filename:~#2.mtx}
   \out_line{\percent_char~Created~by:~tex~\jobname}
   \out_line{\percent_char~Created~using:~#4}
   \out_line{}
   \out_line{\percent_char~This~file~contains~the~
      information~of~#1.#3~in~a~form}
   \out_line{\percent_char~more~easily~read~by~TeX.~
      It~is~used~by~the~fontinst~package.}
   \out_line{}
   \out_line{\percent_char~THIS~FILE~CAN~BE~DELETED.}
   \out_line{}
   \out_line{\string\relax}
   \out_line{\string\metrics}
   \out_line{}
   \out_line{\string\needsfontinstversion{\fontinstversion}}
   \out_line{}
   \lowercase{
      \record_transform{#2}{
         \string\from#3 \x_cs\ifx{from#3}\frompl {#1} \fi
      }{}\iftrue
   }
   \out_line{}
   \catcode`\(=0 \catcode`\)=9
   \let\/=\ignore_parens
   \let\do_pl_glyph=\x_relax
   \primitiveinput #1.#3\x_relax
   \do_pl_glyph
   \out_line{}
   \ifisint{\percent_char boundarychar}\then
      \f_count=\int{\percent_char boundarychar}
      \x_cs\ifx{name-\the\f_count}\x_relax \else
         \out_line{\string\setstr{rightboundary}
            {\csname name-\the\f_count\endcsname}
         }
         \out_line{}
      \fi
   \fi
   \out_line{\endmetrics_text}
   \close_out{Metrics}
}
%    \end{macrocode}
% \end{macro}
% 
% To parse a |.pl| file, we first make |(| the escape character, make |)|
% ignored, then define the various PL commands as \TeX\ control sequences. 
% We can ignore a parenthesis matched string by making |(| and |)| the
% group delimiters, then gobbling them up.
%
%    \begin{macrocode}
\def\ignore_parens{\bgroup\catcode`(=1 \catcode`)=2 \x_relax
   \expandafter\expandafter\expandafter\gobble_parens
      \iftrue\expandafter{\else}\fi}
\def\gobble_parens#1{\egroup}
%    \end{macrocode}
%
% \begin{macro}{\pl_real}
% \begin{macro}{\pl_realer}
%   Convert a PL real to an AFM unit, assuming it contains a decimal point.
%    \begin{macrocode}
\def\pl_real#1{\pl_realer(#1000)}
\def\pl_realer(#1.#2#3#4#5){#1#2#3#4}
%    \end{macrocode}
%   \cs{pl_real} only works if the \texttt{DESIGNUNITS} 
%   setting is at the default value 1. Luckily, this is what 
%   \package{TFtoPL} and \package{VFtoVP} use in all (V)PL files they 
%   create, so you can always get a (V)PL file that will work by 
%   converting first to TFM (+\,VF) and then back again. As of v\,1.913, 
%   that is also the value \package{fontinst} uses for all VPL files it 
%   generates, so the problem isn't particularly important.
% \end{macro}\end{macro}
%
% \begin{macro}{\pl_rounded_real}
%   \changes{1.921}{2002/07/26}{Macro added and is used instead of 
%     \cs{pl_real}. (LH)}
%   The |\pl_rounded_real| macro is like |\pl_realer| in that it converts 
%   a PL unit containing a decimal point to an AFM unit. The difference 
%   is (i) that it rounds the number rather than truncating it and (ii) 
%   that it stores the result in |\result| rather than expanding to it. 
%   Note that the actual real (character string) to convert must be 
%   followed by at least four zeros for the conversion to work 
%   correctly in all cases.
%    \begin{macrocode}
\def\pl_rounded_real(#1.#2#3#4#5){
   \global\result=#1#2#3#4\relax
   \ifnum \first_char#5= >4
      \global\advance \result 
        \if - \first_char#1= \m@ne \else \@ne \fi
   \fi
}
%    \end{macrocode}
% \end{macro}
% 
% 
% \begin{macro}{\pl_int}
%   Convert a PL int to a \TeX{} int, assuming it's prefixed
%   by |C|, |D|, |O|, or |H|.
%    \begin{macrocode}
\def\pl_int#1#2{
   \ifx#1C `#2
   \else\ifx#1D #2
   \else\ifx#1O '#2
   \else\ifx#1H "#2
   \else -1\errmessage{Unknown~PL~number~prefix~`#1'}
   \fi\fi\fi\fi
}
%    \end{macrocode}
% \end{macro}
%
% Many of the PL commands are ignored, and I'm assuming the |R|s are in
% the places \texttt{tftopl} puts them, which is a bit naughty of me.
% 
% \begin{PLproperty}{FAMILY}
% \begin{PLproperty}{FACE}
% \begin{PLproperty}{CHECKSUM}
% \begin{PLproperty}{HEADER}
% \begin{PLproperty}{SEVENBITSAFEFLAG}
%    \begin{macrocode}
\let\FAMILY=\ignore_parens
\let\FACE=\ignore_parens
\let\CHECKSUM=\ignore_parens
\def\HEADER~#1~#2~#3~#4~{}
\def\SEVENBITSAFEFLAG~#1~{}
%    \end{macrocode}
% \end{PLproperty}\end{PLproperty}\end{PLproperty}\end{PLproperty}
% \end{PLproperty}
% 
% \begin{PLproperty}{COMMENT}
% \begin{PLproperty}{LIG}
% \begin{PLproperty}{NEXTLARGER}
% \begin{PLproperty}{VARCHAR}
%    \begin{macrocode}
\let\COMMENT=\ignore_parens
\let\LIG=\ignore_parens
\let\NEXTLARGER=\ignore_parens
\let\VARCHAR=\ignore_parens
%    \end{macrocode}
% \end{PLproperty}\end{PLproperty}\end{PLproperty}\end{PLproperty}
% 
% 
% \begin{PLproperty}{VTITLE}
% \begin{PLproperty}{MAPFONT}
% \begin{PLproperty}{MAP}
%   \begin{flushleft}
%     ^^A Flushed left since the paragraph is so hard to break 
%     ^^A correctly.
%     \changes{1.900}{1998/12/04}{VPL-specific properties added to 
%       those which are ignored by \cs{pltomtx}. (LH)}
%     The properties which are unique for VPL files---|VTITLE|, 
%     |MAPFONT|, |MAP|, |FONTNAME|, |FONTAREA|, |FONTCHECKSUM|, 
%     |FONTAT|, |FONTDSIZE|, |SELECTFONT|, |SETCHAR|, |SETRULE|, 
%     |MOVERIGHT|, |MOVELEFT|, |MOVEUP|, |MOVEDOWN|, |PUSH|, |POP|, 
%     |SPECIAL|, and |SPECIALHEX|---should also be ignored, but it is 
%     actually sufficient to ignore the first three since the others 
%     are only allowed inside |MAP| or |MAPFONT| property lists.
%   \end{flushleft}
%   
%    \begin{macrocode}
\let\VTITLE=\ignore_parens
\let\MAPFONT=\ignore_parens
\let\MAP=\ignore_parens
%    \end{macrocode}
% \end{PLproperty}\end{PLproperty}\end{PLproperty}
% 
%
% \begin{PLproperty}{CODINGSCHEME}
% \begin{macro}{\CODINGSCHEME_cont}
%   When we reach a |CODINGSCHEME| instruction, we read the coding string,
%   and read in the corresponding \meta{encoding}|.etx| file.
% 
%   The corresponding \meta{encoding} is specified by |\declareencoding|
%   statements (see below).  Each |\declare_encoding| defines a macro
%   |\enc-|\meta{codingscheme} which expands to \meta{encoding}.
% 
%   If the PL file is converted using the |\generalpltomtx| command with 
%   a nonempty \meta{opt-enc} argument then the |CODINGSCHEME| instruction 
%   is ignored since an encoding file has already been read in.
% 
%    \begin{macrocode}
\def\CODINGSCHEME{\bgroup\catcode`\)=12\x_relax\CODINGSCHEME_cont}
\def\CODINGSCHEME_cont#1){
   \egroup
   \if_undefined{enc-#1}\then
      \errhelp{The~encoding~for~`#1'~has~not~been~declared.^^J
         You~should~declare~it~with~
         \string\declareencoding{#1}{ETXFILE}.^^J
         Press~<RETURN>~to~carry~on~with~fingers~crossed,^^J
         or~X~<RETURN>~to~exit.}
      \errmessage{Undeclared~encoding~`#1'}
   \else
      \def\do_slot{\x_cs\let{name-\the\slot_number}\slot_name}
      \def\do_boundary{\x_cs\let{name-BOUNDARYCHAR}\slot_name}
      \catcode`\(=12 \catcode`\)=12
      \x_cs\inputetx{enc-#1}\x_relax
      \catcode`\(=0 \catcode`\)=9
   \fi
}
%    \end{macrocode}
% \end{macro}\end{PLproperty}
% 
% \begin{PLproperty}{DESIGNSIZE}
%   The |DESIGNSIZE| is needed because the |FONTDSIZE| specified in a 
%   |MAPFONT| property list has to be the same as the |DESIGNSIZE| of 
%   the corresponding base font.
%    \begin{macrocode}
\def\DESIGNSIZE~#1~#2~{
   \a_dimen=#2pt
   \out_line{\string\setdim{designsize}{\the\a_dimen}}
}
%    \end{macrocode}
% \end{PLproperty}
% 
% \begin{PLproperty}{DESIGNUNITS}
%   \changes{1.905}{1999/06/30}{Error message added. (LH)}
%   \changes{1.912}{2000/02/20}{Store designunits value in 
%      \cs{b_dimen} rather than \cs{a_dimen}. \cs{a_dimen} holds the 
%      design size throughout PL-to-MTX. (LH)}
%   The PL to MTX converter assumes that the (V)PL files to convert 
%   look like the ones created by \texttt{TFtoPL}\slash\texttt{VFtoVP}, 
%   and the interpretation of the \texttt{DESIGNUNITS} property is one 
%   thing specifically affected by this. The TFM file format does not 
%   store the \texttt{DESIGNUNITS} value used, so the two above 
%   programs always generate (V)PL files with the default setting of 
%   design unit equal to the design size. Hence any occurence of the 
%   \texttt{DESIGNUNITS} property with a nondefault value is an 
%   indication of an error.
%   
%   The incorrect metrics can be corrected by scaling by a suitable 
%   amount (1000 divided by the \texttt{designunits} dimen), but it is 
%   much simpler to convert the PL to a TFM and then convert it back, 
%   that will also fix the units.
%   
%    \begin{macrocode}
\def\DESIGNUNITS~#1~#2~{
   \b_dimen=#2pt\x_relax
   \ifdim 1pt=\b_dimen \else
      \fontinsterror{PL-to-MTX}{Nondefault~unit~used~in~PL~file}
         {You~may~continue,~but~the~metrics~for~this~font~will~be~wrong.}
   \fi
   \out_line{\string\setdim{designunits}{\the\b_dimen}}
}
%    \end{macrocode}
% \end{PLproperty}
% 
% \begin{PLproperty}{BOUNDARYCHAR}
%    \begin{macrocode}
\def\BOUNDARYCHAR~#1~#2~{
   \x_setint{\percent_char boundarychar}{\pl_int{#1}{#2}}
}
%    \end{macrocode}
% \end{PLproperty}
%
% \changes{1.917}{2001/03/16}{Rewrote the fontdimen part of the 
%    (V)PL-to-MTX converter so that the ETX can specify the 
%    fontdimens. (LH)}
% 
% Declared fontdimens are converted to |\setint| commands in the MTX 
% file. A fontdimen declaration for fontdimen $n$ is stored in the 
% control sequence \describecsfamily{fdimen-\meta{n}}|\fdimen-|$n$; if 
% this control sequence is undefined then the fontdimen is not declared 
% and if it is set then it is a macro which expands to the name of the 
% corresponding integer variable.
% 
% \begin{macro}{\pl_setfontdimen}
%   Fontdimens are declared by the |\pl_setfontdimen| macro, which is a 
%   definition of |\setfontdimen| that is used during (V)PL-to-MTX 
%   conversion.
%    \begin{macrocode}
\def\pl_setfontdimen#1#2{\x_cs\def{fdimen-#1}{#2}}
%    \end{macrocode}
% \end{macro}
% 
% \begin{PLproperty}{PARAMETER}
%   The |PARAMETER| property is the generic specifier of fontdimens in 
%   (V)PL files. It takes two arguments: the fontdimen number (integer) 
%   and value (real).
%    \begin{macrocode}
\def\PARAMETER~#1~#2~R~#3~{
   \f_count=\pl_int{#1}{#2}\x_relax
   \if_defined{fdimen-\the\f_count}\then
      \pl_rounded_real(#3 0000)
      \out_line{\string\setint{\csname fdimen-\the\f_count\endcsname}
         {\the\result}}
   \fi
}
%    \end{macrocode}
% \end{PLproperty}
% 
% \begin{PLproperty}{FONTDIMEN}
%   No special processing is required for the |FONTDIMEN| property. 
%    \begin{macrocode}
\let\FONTDIMEN=\x_relax
%    \end{macrocode}
% \end{PLproperty}
% 
% \begin{PLproperty}{SLANT}
% \begin{PLproperty}{SPACE}
% \begin{PLproperty}{STRETCH}
% \begin{PLproperty}{SHRINK}
% \begin{PLproperty}{XHEIGHT}
% \begin{PLproperty}{QUAD}
% \begin{PLproperty}{EXTRASPACE}
%   The properties for the seven mandatory fontdimens are converted 
%   to the corresponding |PARAMETER| properties but their meanings are 
%   predeclared. The effect of these predeclarations is that even ETX 
%   files that don't use |\setfontdimen| to set the fontdimens have 
%   these fontdimens converted to |\setint|s.
%   
%   A scan shows that the current (2001/03/17) MTX and ETX files aren't 
%   using the integers \texttt{stretchword}, \texttt{shrinkword},
%   \texttt{quad}, and \texttt{extraspace}. They probably should.
%    \begin{macrocode}
\def\SLANT{\PARAMETER D~1~}
\pl_setfontdimen{1}{italicslant}
\def\SPACE{\PARAMETER D~2~}
\pl_setfontdimen{2}{interword}
\def\STRETCH{\PARAMETER D~3~}
\pl_setfontdimen{3}{stretchword}
\def\SHRINK{\PARAMETER D~4~}
\pl_setfontdimen{4}{shrinkword}
\def\XHEIGHT{\PARAMETER D~5~}
\pl_setfontdimen{5}{xheight}
\def\QUAD{\PARAMETER D~6~}
\pl_setfontdimen{6}{quad}
\def\EXTRASPACE{\PARAMETER D~7~}
\pl_setfontdimen{7}{extraspace}
%    \end{macrocode}
% \end{PLproperty}\end{PLproperty}\end{PLproperty}\end{PLproperty}
% \end{PLproperty}\end{PLproperty}\end{PLproperty}
% 
% \begin{numPLproperty}{NUM}{1,2,3}
% \begin{numPLproperty}{DENOM}{1,2}
%   The |NUM|$*$ and |DENOM|$*$ properties are for fontdimens 8--10 
%   and 11--12. They have to do with positioning numerator and 
%   denominator in fractions.
%    \begin{macrocode}
\def\NUM#1~#2~#3~{
   \ifcase #1\or
      \PARAMETER D~8~#2~#3~
   \or
      \PARAMETER D~9~#2~#3~
   \or
      \PARAMETER D~10~#2~#3~
   \fi
}
\def\DENOM#1~#2~#3~{
   \ifcase #1\or
      \PARAMETER D~11~#2~#3~
   \or
      \PARAMETER D~12~#2~#3~
   \fi
}
%    \end{macrocode}
% \end{numPLproperty}\end{numPLproperty}
% 
% \begin{numPLproperty}{SUP}{1,2,3}
% \begin{numPLproperty}{SUB}{1,2}
%   The |SUP|$*$ and |SUB|$*$ properties are for fontdimens 13--15 
%   and 16--17. They have to do with positioning superscripts and 
%   subscripts.
%    \begin{macrocode}
\def\SUP#1~#2~#3~{
   \ifcase #1\or
      \PARAMETER D~13~#2~#3~
   \or
      \PARAMETER D~14~#2~#3~
   \or
      \PARAMETER D~15~#2~#3~
   \fi
}
\def\SUB#1~#2~#3~{
   \ifcase #1\or
      \PARAMETER D~16~#2~#3~
   \or
      \PARAMETER D~17~#2~#3~
   \fi
}
%    \end{macrocode}
% \end{numPLproperty}\end{numPLproperty}
% 
% \begin{PLproperty}{SUPDROP}
% \begin{PLproperty}{SUBDROP}
% \begin{PLproperty}{AXISHEIGHT}
%   These are fontdimens 18, 19, and 22.
%    \begin{macrocode}
\def\SUPDROP{\PARAMETER D~18~}
\def\SUBDROP{\PARAMETER D~19~}
\def\AXISHEIGHT{\PARAMETER D~22~}
%    \end{macrocode}
% \end{PLproperty}\end{PLproperty}\end{PLproperty}
% 
% \begin{numPLproperty}{DELIM}{1,2}
%   The |DELIM|$*$ fondimens have number 20 and 21. They have to do with 
%   the size of delimiters put around a generalised fraction.
%    \begin{macrocode}
\def\DELIM#1~#2~#3~{
   \ifcase #1\or
      \PARAMETER D~20~#2~#3~
   \or
      \PARAMETER D~21~#2~#3~
   \fi
}
%    \end{macrocode}
% \end{numPLproperty}
% 
% \begin{PLproperty}{DEFAULTRULETHICKNESS}
% \begin{numPLproperty}{BIGOPSPACING}{1,2,3,4,5}
%   The fontdimen properties that are special for math extension fonts 
%   are |DEFAULT|\-|RULE|\-|THICKNESS| and the various 
%   |BIG|\-|OP|\-|SPACING|$*$.
%    \begin{macrocode}
\def\DEFAULTRULETHICKNESS{\PARAMETER D~8~}
\def\BIGOPSPACING#1~#2~#3~{
   \ifcase #1\or
      \PARAMETER D~9~#2~#3~
   \or
      \PARAMETER D~10~#2~#3~
   \or
      \PARAMETER D~11~#2~#3~
   \or
      \PARAMETER D~12~#2~#3~
   \or
      \PARAMETER D~13~#2~#3~
   \fi
}
%    \end{macrocode}
%   This is the old definition of |\DEFAULTRULETHICKNESS| for historical 
%   references (since its behaviour has changed).
%    \begin{macrocode}
% \def\DEFAULTRULETHICKNESS~R~#1~{
%    \out_line{\string\setint{underlinethickness}{\pl_real{#1}}}
% }
%    \end{macrocode}
% \end{numPLproperty}\end{PLproperty}
%
%
% \begin{PLproperty}{LABEL}
% \begin{macro}{\LABEL_slot}
% \begin{macro}{\LABEL_boundarychar}
% \begin{macro}{\do_if_defined}
%   The most complicated part of the processing of the |LIGTABLE| 
%   property list is that it has to keep track of which glyphs the 
%   current ligature\slash kerning program applies to. This stored as 
%   a |\do|\marg{glyph} list in |\a_macro| and building this list 
%   is the job of the |LABEL| property.
%   
%   It is assumed that |\do| is |\never_do| whenever some element is 
%   added to |\a_macro|.
%    \begin{macrocode}
\def\LABEL~#1{\ifx #1B
      \expandafter\LABEL_boundarychar
   \else
      \expandafter\LABEL_slot \expandafter#1
   \fi
}
\def\LABEL_slot #1~#2~{
   \f_count=\pl_int{#1}{#2}
   \edef\a_macro{\a_macro
      \x_cs\do_if_defined{name-\the\f_count}
   }
}
\def\LABEL_boundarychar OUNDARYCHAR{
   \edef\a_macro{\a_macro
      \x_cs\do_if_defined{name-BOUNDARYCHAR}
   }
}
\def\do_if_defined#1{\ifx #1\x_relax \else \do{#1} \fi}
%    \end{macrocode}
% \end{macro}\end{macro}\end{macro}\end{PLproperty}
% 
% 
% \begin{PLproperty}{LIGTABLE}
% \begin{PLproperty}{STOP}
% \begin{PLproperty}{SKIP}
%   The |LIGTABLE|, |STOP|, and |SKIP| properties are the remaining 
%   properties involved in managing the |\a_macro| list. |SKIP| 
%   properties are \emph{not} processed.
%    \begin{macrocode}
\def\LIGTABLE{\let\do=\never_do\let\a_macro\empty_command}
\def\STOP{\let\a_macro\empty_command}
\def\SKIP~#1~#2~{\immediate\write16{Warning:~SKIP~instruction~ignored.}}
%    \end{macrocode}
% \end{PLproperty}\end{PLproperty}\end{PLproperty}
%
% \begin{PLproperty}{KRN}
% \begin{macro}{\write_pl_krn}
%   |KRN| properties are converted to |\setkern| instructions.
%    \begin{macrocode}
\def\KRN~#1~#2~R~#3~{
   \pl_rounded_real(#3 0000)
   \edef\do{\noexpand\write_pl_krn{\pl_int{#1}{#2}}{\the\result}}
   \a_macro
   \let\do=\never_do
}
\def\write_pl_krn#1#2#3{
   \f_count=#1\x_relax
   \x_cs\ifx{name-\the\f_count}\x_relax \else
      \out_line{\string\setkern{#3}
         {\csname name-\the\f_count\endcsname}{#2}
      }
   \fi
}
%    \end{macrocode}
% \end{macro}\end{PLproperty}
%
% \begin{PLproperty}{CHARACTER}
% \begin{PLproperty}{CHARWD}
% \begin{PLproperty}{CHARHT}
% \begin{PLproperty}{CHARDP}
% \begin{PLproperty}{CHARIC}
%   The character metrics that are processed are |CHARWD|, |CHARHT|, 
%   |CHARDP|, and |CHARIC|. The |CHARACTER| property takes care of 
%   writing the information to the MTX file, but note that each new 
%   |CHARACTER| property writes the information from the preceeding 
%   |CHARACTER| property.
%    \begin{macrocode}
\def\CHARWD~R~#1~{\pl_rounded_real(#1 0000) \b_count=\result}
\def\CHARHT~R~#1~{\pl_rounded_real(#1 0000) \c_count=\result}
\def\CHARDP~R~#1~{\pl_rounded_real(#1 0000) \d_count=\result}
\def\CHARIC~R~#1~{\pl_rounded_real(#1 0000) \e_count=\result}
\def\CHARACTER~#1~#2~{
   \do_pl_glyph
   \a_count=\pl_int{#1}{#2}
   \b_count=0
   \c_count=0
   \d_count=0
   \e_count=0
   \let\do_pl_glyph=\write_pl_glyph
}
%    \end{macrocode}
% \end{PLproperty}\end{PLproperty}\end{PLproperty}\end{PLproperty}
% \end{PLproperty}
%
% \begin{macro}{\write_pl_glyph}
%   The |\write_pl_glyph| actually writes the information contained in 
%   a |CHARACTER| property list to the MTX file as a |\setrawglyph| 
%   command.
%    \begin{macrocode}
\def\write_pl_glyph{
      \x_cs\ifx{name-\the\a_count}\x_relax\else
         \out_line{\string\setrawglyph
            {\csname~name-\the\a_count\endcsname}
            {\raw_font_name}
            {\the\a_dimen}
            {\the\a_count}
            {\the\b_count}
            {\the\c_count}
            {\the\d_count}
            {\the\e_count}}
      \fi
   }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Converting an MTX file to a PL file}
%
% \DescribeMacro{\mtxtopl}
% The macro
% \begin{quote}
%    |\mtxtopl|\marg{mtxfile}\marg{plfile}
% \end{quote}
% writes a font from the |\setrawglyph| instructions in \meta{mtxfile}
% to \meta{plfile}.  It ignores any font dimensions and kerning, so the
% resulting font is only useful for generating virtual fonts from.
% (This macro is called by |\transformfont|.)
%
% \begin{macro}{\mtxtopl}
%   \changes{1.911}{1999/11/19}{Added `ligless' to one of the comment 
%      lines. (LH) Clarification requested by Walter Schmidt.}
%   \changes{1.917}{2001/03/13}{Added resetting of 
%      \cs{setsomething_global}---assignments made here must be 
%      local. (LH)}
%   \changes{1.929}{2005/02/05}{Corrected `\texttt{pltotf}' in 
%      comment. (LH)}
%    \begin{macrocode}
\def\mtxtopl#1#2{{
   \let\setsomething_global=\x_relax
   \open_out{#2.pl}
   \top_of_pl_hook
   \out_line{(COMMENT~raw~font~#2~created~by~fontinst~
      v\fontinstversion)}
   \out_line{}
   \out_line{(COMMENT~Filename:~#2.pl)}
   \out_line{(COMMENT~Created~by:~tex~\jobname)}
   \out_line{(COMMENT~Created~using:~\string\mtxtopl{#1}{#2})}
   \out_line{}
   \out_line{(COMMENT~This~file~can~be~turned~into~
      a~ligless~TeX~font~with)}
   \out_line{(COMMENT~pltotf~#2.pl~#2.tfm)}
   \out_line{}
   \out_line{(COMMENT~THIS~FILE~CAN~THEN~BE~DELETED.)}
   \out_line{}
   \out_line{(DESIGNSIZE~R~10.0)}
   \out_line{}
   \let\setglyph=\iffalse
   \let\endsetglyph=\fi
   \let\setkern=\gobble_three
   \let\setscaledrawglyph=\first_pl_raw_glyph
   \def\setscalednotglyph##1##2##3##4##5##6##7##8##9{}
   \inputmtx{#1}
   \out_line{}
   \out_line{(COMMENT~END~OF~FILE~#2.pl)}
   \close_out{Raw~font}
}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\first_pl_raw_glyph}
%   The |\first_pl_raw_glyph| writes the \texttt{DESIGNUNITS} property 
%   for the font when the first |\setscaledrawglyph| is encountered. 
%   This is to undo the scaling that has already been applied to the 
%   metrics, so that the metrics will match the actual font.
%    \begin{macrocode}
\def\first_pl_raw_glyph#1#2#3#4{
   \out_line{(DESIGNUNITS~R~\make_factor{#4})}
   \let\setscaledrawglyph=\pl_raw_glyph
   \pl_raw_glyph{#1}{#2}{#3}{#4}
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\pl_raw_glyph}
%    \begin{macrocode}
\def\pl_raw_glyph#1#2#3#4#5#6#7#8#9{
   \out_line{(CHARACTER~D~\number#5~\space(COMMENT~#1)}
   \out_lline{(CHARWD~R~\make_factor{#6})}
   \out_lline{(CHARHT~R~\make_factor{#7})}
   \out_lline{(CHARDP~R~\make_factor{#8})}
   \out_lline{(CHARIC~R~\make_factor{#9})}
   \out_lline{)}
}
%    \end{macrocode}
% \end{macro}
%
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \section{Font transformations}
% \label{Sec:Font.trans}
% \changes{1.902}{1999/05/01}{Moved Section \thesection\space to 
%    \texttt{ficonv.dtx}. (LH)}
%
% \subsection{Transformable metric files}
% \label{Ssec:TransMTX}
% 
% \changes{1.901}{1999/02/28}{Definition of transformable metric file 
%    added. (LH)}
% \changes{1.913}{2000/03/10}{Definition of transformable metric file 
%    changed to include the \cs{setscaledrawglyph} and 
%    \cs{setscalednotglyph} commands. (LH)}
% \changes{1.915}{2000/09/09}{Added description of \cs{aliased} macro 
%    to the definition of transformable metric files. (LH)}
% A \emph{transformable metric file} is a metric file 
% which complies with certain restrictions in its syntax. The only 
% metric commands allowed are
% \begin{isyntax}
%   |\setscaledrawglyph|\marg{glyph}\marg{font}\marg{size}^^A
%      \marg{scale}\marg{slot}\marg{width}\penalty0
%      \marg{height}\penalty0\marg{depth}\penalty0\marg{italic}\\
%   |\setrawglyph|\marg{glyph}\marg{font}\marg{size}\marg{slot}^^A
%      \marg{width}\marg{height}\penalty0\marg{depth}\penalty0
%      \marg{italic}\\
%   |\setscalednotglyph|\marg{glyph}\marg{font}\marg{size}^^A
%      \marg{scale}\marg{slot}\marg{width}\penalty0
%      \marg{height}\penalty0\marg{depth}\penalty0\marg{italic}\\
%   |\setnotglyph|\marg{glyph}\marg{font}\marg{size}\marg{slot}^^A
%      \marg{width}\marg{height}\penalty0\marg{depth}\penalty0
%      \marg{italic}\\
%   |\setkern|\marg{glyph1}\marg{glyph2}\marg{amount}\\
%   |\setglyph|\marg{glyph} \meta{glyph commands} |\endsetglyph|
% \end{isyntax}
% where \meta{glyph}, \meta{glyph1}, \meta{glyph2}, and \meta{font} are 
% strings without any variable references (no |\str| or |\strint| are 
% allowed), \meta{scale}, \meta{slot}, \meta{width}, \meta{height}, 
% \meta{depth}, \meta{italic}, and \meta{amount} are \TeX\ numbers, and 
% \meta{size} is a \TeX\ dimen. (More accurately, all dimens in a 
% transformable metric file should be on the form \meta{optional 
% signs}\penalty0 \meta{decimal constant}\penalty0 \meta{physical unit}, 
% but that's at the ``dangerous bend'' level.) The \meta{glyph}s may be 
% of the form
% \begin{quote}
%   |\aliased|\marg{font's name}\marg{alias name}
% \end{quote}
% Such \meta{glyph}s are interpreted as \meta{alias name} for all 
% purposes except reencoding, when they are interpreted as \meta{font's 
% name}. \meta{glyph}s of this form are furthermore copied as they are 
% to MTX files created by |\transform|\-|font| (|\mtxtomtx|).
% 
% The only \meta{glyph commands} allowed are
% \begin{quote}
%   |\samesize|\marg{glyph}\\
%   |\glyphpcc|\marg{glyph}\marg{xoffset}\marg{yoffset}
% \end{quote}
% where \meta{glyph} is as above, and \meta{xoffset} and \meta{yoffset} 
% are \TeX\ numbers.
% 
% The only general commands allowed are
% \begin{quote}
%   |\needsfontinstversion|\marg{version}\\
%   |\setint|\marg{name}\marg{number}\\
%   |\setdim|\marg{name}\marg{dimen}\\
%   |\setstr|\marg{name}\marg{string}\\
%   |\storemapdata|\marg{font}\marg{source}\marg{transformations}
% \end{quote}
% where \meta{name} and \meta{string} are strings without variable 
% references, \meta{number} is a \TeX\ number, and \meta{dimen} is a 
% \TeX\ dimen. The arguments of |\needs|\-|fontinst|\-|version| and 
% |\store|\-|map|\-|data| are as usual, but these commands do not get 
% copied in a font transformation.
% 
% The metric files produced by |\afmtomtx| and |\generalpltomtx| are 
% meant to be transformable. If they are not then there is a bug 
% somewhere.
% 
% The name of the integer in |\setint| commands is interpreted. This 
% name is used to determine how the number should be transformed, see 
% the implementation of |\mtxtomtx_setint| below.
% 
% 
% \subsection{Making font transformations}
% 
% \changes{1.911}{1999/11/19}{Recording of transformations moved to the 
%    macros that actually write the MTX files. (LH)}
% \changes{1.911}{1999/11/19}{Flag for that source font wasn't found 
%    changed to \texttt{afm-name}. \texttt{transform-source} string 
%    completely removed. (LH)}
% \changes{1.913}{2000/03/11}{New implementation of \cs{scalefont} and 
%    \cs{yscalefont}, using the new \cs{setscaledrawglyph} and 
%    \cs{setscalednotglyph} commands. (LH)}
% \changes{1.913}{2000/03/12}{Using \cs{slots-}\meta{glyph} control 
%    sequences for storing encoding positions of glyphs in reencoded 
%    fonts. (LH)}
% 
% \DescribeMacro{\transformfont}
% The macro:
% \begin{quote}
%    |\transformfont|\marg{font-name}\marg{transformed font}
% \end{quote}
% transforms the metrics of a raw font. As far as \TeX\ is concerned, 
% \meta{font-name} will be a new font. Actually doing the 
% transformation and providing the transformed font (as opposed to the 
% metrics of the transformed font) is for most transforms up to some 
% other piece of software, in most cases the DVI driver, but 
% \package{fontinst} will handle isotropic scaling itself.
% 
% The easiest way to find out which transformations need to be carried 
% out is to generate a map file for the \texttt{debug} ``driver'' (see 
% Section~\ref{Sec:Mapfiles}). Of course, if \package{fontinst} can 
% generate a mapfile for the target driver then you probably don't need 
% to find out which transformations were necessary\,\textellipsis
% \spacefactor=\sfcode`\.\space\space
% In any case, the arguments of |\storemapdata| in the MTX file 
% generated will tell which transformations of this |\transformfont| 
% command that must be performed by some other software.
% 
% \DescribeMacro{\fromafm}
% \DescribeMacro{\frommtx}
% \DescribeMacro{\frompl}
% \DescribeMacro{\scalefont}
% \DescribeMacro{\xscalefont}
% \DescribeMacro{\yscalefont}
% \DescribeMacro{\slantfont}
% \DescribeMacro{\reencodefont}
% The \meta{transformed font} commands are:
% \begin{quote}
%    |\fromafm|\marg{AFM file}\\
%    |\frompl|\marg{PL file}\\
%    |\fromplgivenetx|\marg{PL file}\marg{etx}\\
%    |\frommtx|\marg{MTX file}\\
%    |\fromany|\marg{file}\\
%    |\scalefont|\marg{integer expression}\marg{transformed font}\\
%    |\xscalefont|\marg{integer expression}\marg{transformed font}\\
%    |\yscalefont|\marg{integer expression}\marg{transformed font}\\
%    |\slantfont|\marg{integer expression}\marg{transformed font}\\
%    |\reencodefont|\marg{etx}\marg{transformed font}
% \end{quote}
%
% Each |\transformfont| command generates an |.mtx| file for 
% \meta{font-name} and a corresponding raw |.pl| file, which is written 
% out by |\mtxtopl|.
%
% Each |\fromafm|, |\frompl|, or |\fromplgivenetx| command also generates 
% an |.mtx| file for the source font, which is written out by |\afmtomtx| 
% or |\generalpltomtx|.  In addition, |\fromafm| also uses |\mtxtopl| 
% to generate a corresponding raw |.pl| file.
% 
% |\fromany| reads an MTX, PL, AFM, or VPL file depending on what it can 
% find. It tries them in the order first MTX, then PL, then AFM, and 
% last VPL.
% 
% \begin{macro}{\transformfont}
%   \changes{1.912}{2000/01/15}{Added local resetting of 
%      \cs{setsomething_global} to \cs{relax}, since \cs{transformfont} 
%      assumes such assignments are local. (LH)}
%    \begin{macrocode}
\def\transformfont#1#2{{
   \let\setsomething_global=\x_relax
   \unsetstr{afm-name}
   \unsetstr{etx-name}
   \x_resetint{x-scale}{\one_thousand}
   \x_resetint{y-scale}{\one_thousand}
   \x_resetint{slant-scale}{0}
   #2
%    \end{macrocode}
%   \changes{1.903}{1999/06/01}{Added behaviour for the case source file 
%     not found. (LH)}
%   \changes{1.921}{2002/07/31}{Corrected an error message that tried 
%     to use a variable that wasn't set! (LH)}
%    \begin{macrocode}
   \ifisstr{afm-name}\then
      \mtxtomtx{\str{afm-name}}{#1}
      \mtxtopl{#1}{#1}
   \else
      \fontinsterror{Transformfont}{
         Failed~to~make~transformed~font~#1;\messagebreak
         source~font~metrics~file~not~found
      }\error_help_a
   \fi
}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fromafm}
%   \changes{1.904}{1999/06/17}{Added call of \cs{record_transform}. (LH)}
%   \changes{1.911}{1999/11/19}{Added test for file existence. (LH)}
%    \begin{macrocode}
\def\fromafm#1{
   \if_file_exists{#1.afm}\then
      \x_setstr{afm-name}{#1}
      \afmtomtx{#1}{#1}
      \mtxtopl{#1}{#1}
   \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\frommtx}
%   \changes{1.911}{1999/11/19}{Added test for file existence. (LH)}
%    \begin{macrocode}
\def\frommtx#1{
   \if_file_exists{#1.mtx}\then \x_setstr{afm-name}{#1} \fi
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\frompl}
%   \changes{1.904}{1999/06/17}{Added call of \cs{record_transform}. (LH)}
%   \changes{1.911}{1999/11/19}{Added test for file existence. (LH)}
% \begin{macro}{\fromplgivenetx} 
%   \changes{1.902}{1999/05/02}{Command added. (LH)}
%   \changes{1.904}{1999/06/17}{Added call of \cs{record_transform}. (LH)}
%   \changes{1.911}{1999/11/19}{Added test for file existence. (LH)}
%    \begin{macrocode}
\def\frompl#1{
   \if_file_exists{#1.pl}\then
      \x_setstr{afm-name}{#1}
      \generalpltomtx{#1}{#1}{pl}{}
   \fi
}
%    \end{macrocode}
%    \begin{macrocode}
\def\fromplgivenetx#1#2{
   \if_file_exists{#1.pl}\then
      \x_setstr{afm-name}{#1}
      \generalpltomtx{#1}{#1}{pl}{#2}
   \fi
}
%    \end{macrocode}
% \end{macro} \end{macro}
% 
% \multchanges{\cs{fromvpl}\cs{fromvplgivenetx}}{1.902}{1999/05/02}
%    {Commands added. (LH)}
% \multchanges{\cs{fromvpl}\cs{fromvplgivenetx}}{1.904}{1999/06/16}
%    {Commands removed. (LH)}
% Regarding \cs{fromvpl} and \cs{fromvplgivenetx}: I realized that 
% there isn't any point in reading metrics for a font that is to be 
% transformed from a VPL file, since no driver I know of can transform 
% virtual fonts. If someone has a problem with this then I suppose he 
% or she should send word about it. /LH
% 
%
% \begin{macro}{\fromany}
%   \changes{1.903}{1999/05/20}{Command added. (LH) Based on a 
%      suggestion by Vladimir Volovich.}
%   \changes{1.903}{1999/06/01}{Added behaviour for AFM not found case. 
%      (LH)}
%   \changes{1.904}{1999/06/16}{Added search for VPL file and calls to 
%     \cs{record_transform}. (LH)}
%   \changes{1.923}{2002/12/03}{Added \cs{pl_encoding}. (LH)}
%   \changes{1.926}{2003/07/10}{Removed \cs{pl_encoding}; it is better 
%      to provide that functionality in a separate macro. (LH)}
%   \changes{1.926}{2003/07/10}{Has to reset the \texttt{afm-name} 
%      string, since \cs{input_mtx_file} now uses the value. (LH)}
%   The |\fromany| transformed font command searches for font metrics 
%   for \#1 by looking for, in turn, the files \#1|.mtx|, \#1|.pl|, 
%   \#1|.afm|, and \#1|.vpl|. If an MTX file doesn't exist, it is 
%   generated, and if the MTX is generated from an AFM then a 
%   corresponding (non-ligful) PL file is generated as well. |\fromany| 
%   also sets the fontinst string \texttt{afm-name} according 
%   to what kind of font it found. If none of the fonts existed then 
%   |afm-name| is unset.
%    \begin{macrocode}
\def\fromany#1{
   \x_cs\edef{s-afm-name}{#1}
   \if_file_exists{#1.mtx}\then\else
%    \end{macrocode}
%   
%   \changes{1.6}{1997/01/15}{Search order changed to PL before AFM. 
%      (SPQR) The code wasn't in \cs{fromany} back then, though.}
%   1997/01/15 SPQR changed the below search order to |.pl| before |.afm|  
%   because of the |cmr*.afm| files found in the |TEXMF|\slash
%   |fonts|\slash|afm| hierarchy.
%    \begin{macrocode}
      \if_file_exists{#1.pl}\then
         \generalpltomtx{#1}{#1}{pl}{}
      \else
         \if_file_exists{#1.afm}\then
            \afmtomtx{#1}{#1}
            \mtxtopl{#1}{#1}
         \else
            \if_file_exists{#1.vpl}\then
               \generalpltomtx{#1}{#1}{vpl}{}
            \else
               \unsetstr{afm-name}
   \fi\fi\fi\fi
}
%    \end{macrocode}
% \end{macro}
%
% 
% \subsubsection*{The mathematical basis for the metric font transformations}
% 
% Mathematically, all the metric font transformations (|\scale|\-|font|, 
% |\xscale|\-|font|, |\yscale|\-|font|, and |\slant|\-|font|) are linear 
% mappings of the real plane onto itself. All quantities in a 
% transformable metric file are interpreted as being determined by some 
% point in this plane and hence their transformation depends on how that 
% point would be moved by the metric font transformations performed. 
% This is usually simpler than it sounds, since all quantities except 
% |italicslant| are interpreted as either the $x$- or the $y$-coordinate 
% of some point. |italicslant| is interpreted as the quotient 
% $\frac{x}{y}$ for a point.
% 
% The best way to describe a linear mapping of the real plane to itself 
% is by a \(2 \times 2\) matrix whose components are real numbers. Since 
% true real numbers are not available in \TeX, integers are used instead, 
% with the convention that they are in units of thousandths. In a 
% concrete form this means that $0$ represents $0$, $500$ represents 
% $\frac{1}{2}$, $1000$ represents $1$, etc. This works just as for the 
% scaling factors used in |\scale|. It also means that the matrix
% $$
%   \left(\begin{array}{cc} 1000 & 0 \\ 0 & 1000 \end{array}\right)
% $$
% represents the identity mapping (the mapping taking everything to 
% itself).
% 
% Thinking of points as column vectors (\(2 \times 1\) matrices) with 
% the $x$-coordinate in the first component and the $y$-coordinate in 
% the second, the respective elementary metric font transformations 
% correspond to the following matrices:
% \begin{eqnarray*}
%   \mbox{\cs{scalefont}\marg{n}} & \mbox{is} &
%     \left( \begin{array}{cc}
%        \mbox{\meta{n}}& 0 \\
%        0 & \mbox{\meta{n}}
%     \end{array} \right) \\
%   \mbox{\cs{xscalefont}\marg{n}} & \mbox{is} &
%     \left( \begin{array}{cc}
%        \mbox{\meta{n}}& 0 \\
%        0 & 1000
%     \end{array} \right) \\
%   \mbox{\cs{yscalefont}\marg{n}} & \mbox{is} &
%     \left( \begin{array}{cc}
%        1000 & 0 \\
%        0 & \mbox{\meta{n}}
%     \end{array} \right) \\
%   \mbox{\cs{slantfont}\marg{n}} & \mbox{is} &
%     \left( \begin{array}{cc}
%        1000 & \mbox{\meta{n}} \\
%        0 & 1000
%     \end{array} \right)
% \end{eqnarray*}
% Since all these matrices are upper triangular, all products of such 
% matrices (corresponding to compositions of the linear mappings) will be 
% upper triangular as well. It is therefore unnecessary to store the 
% subdiagonal component anywhere (it is always zero), and hence 
% \package{fontinst} represents an arbitrary metric transform by the 
% matrix
% $$
%   \left( \begin{array}{cc}
%      \mbox{\texttt{x-scale}} & \mbox{\texttt{slant-scale}} \\
%      0 & \mbox{\texttt{y-scale}}
%   \end{array} \right)
% $$
% where \texttt{x-scale}, \texttt{y-scale}, and \texttt{slant-scale} 
% are fontinst integers.
% 
% The reason there is a representation of arbitrary metric transforms 
% is that all the elementary metric transforms listed in the second 
% argument of |\transformfont| are concatenated before the actual font 
% file conversion is made. This reduces the amount of calculations 
% performed in case there are many transformations of the font.
% 
% Why do we only consider transformations that correspond to upper 
% triangular matrices? Well, a transformation corresponds to an upper 
% triangular matrix if and only if it leaves horizontal lines horizontal. 
% Since in particular the baseline must always be horizontal in \TeX, 
% there is no point in considering other linear transformations.
% 
% \begin{macro}{\scalefont}
% \begin{macro}{\xscalefont}
% \begin{macro}{\yscalefont}
% \begin{macro}{\slantfont}
% \begin{macro}{\reencodefont}
%    \begin{macrocode}
\def\scalefont#1#2{
   \eval_expr_to\d_count{#1}
   \x_resetint{x-scale}{\scale{\d_count}{\int{x-scale}}}
   \x_resetint{y-scale}{\scale{\d_count}{\int{y-scale}}}
   \x_resetint{slant-scale}{\scale{\d_count}{\int{slant-scale}}}
   #2
}
\def\xscalefont#1#2{
   \x_resetint{x-scale}{\scale{#1}{\int{x-scale}}}
   #2
}
\def\yscalefont#1#2{
   \eval_expr_to\d_count{#1}
   \x_resetint{y-scale}{\scale{\d_count}{\int{y-scale}}}
   \x_resetint{slant-scale}{\scale{\d_count}{\int{slant-scale}}}
   #2
}
\def\slantfont#1#2{
   \x_resetint{slant-scale}{
      \add{\scale{#1}{\int{x-scale}}}{\int{slant-scale}}
   }
   #2
}
\def\reencodefont#1#2{
   #2
   \resetstr{etx-name}{#1}
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% 
% That's only half the story, however. It is true that the transformation 
% matrix, as computed by |\scalefont|, |\slantfont|, |\xscalefont|, and 
% |\yscalefont| above, is used for transforming the font metrics, but it 
% is not directly used for transforming the font itself. Instead it is 
% factorized as
% $$
%   \left( \begin{array}{cc}
%     x & s \\ 0 & y
%   \end{array} \right) =
%   y \left( \begin{array}{cc}
%     x/y & s/y \\ 0 & 1
%   \end{array} \right)
% $$
% Here the scalar factor $y$ will be used to scale the \meta{scale} 
% argument of |\set|\-|scaled|\-|raw|\-|glyph| and 
% |\set|\-|scaled|\-|not|\-|glyph| commands, whereas the matrix 
% factor will be put in the third argument of |\store|\-|map|\-|data| 
% in the MTX file written. Thus \package{fontinst} will handle the 
% scalar factor of the transformation itself, but leave the matrix 
% factor for some other software to take care of.
% 
% \bigskip
% 
% 
% \DescribeMacro{\mtxtomtx}
% The macro:
% \begin{quote}
%    |\mtxtomtx|\marg{source MTX}\marg{destination MTX}
% \end{quote}
% converts the first |.mtx| file to the second, using the current values
% of |\int{x-scale}|, |\int{y-scale}|, |\int{slant-scale}|, and 
% |\str{etx-name}|.
%
% NOTE: this doesn't convert arbitrary |.mtx| files, just the 
% transformable ones.
%
% \begin{macro}{\mtxtomtx}
%   \changes{1.911}{1999/11/19}{\cs{edef}ing \cs{raw_font_name}. (LH)}
%   \changes{1.915}{2000/09/09}{Locally redefining \cs{aliased}. (LH)}
%   \changes{1.924}{2003/02/08}{Added \cs{directfalse}. (LH)}
%   \changes{1.931}{2005/05/13}{Placed ETX processing after 
%      \cs{needsfontinstversion} had been written, so that ETX commands 
%      can write data directly to the output MTX file. (LH)}
%   \changes{1.931}{2005/05/13}{Copying \cs{declarepsencoding} data to 
%      generated MTX file as a \cs{setpsencoding} command. (LH)}
%    \begin{macrocode}
\def\mtxtomtx#1#2{{
   \let\a_macro=\empty_command
   \_a_true
   \ifnum \int{x-scale}=\int{y-scale}
      \ifnum \int{slant-scale}=\z@
            \_a_false
   \fi \fi
   \if_a_
      \a_count=\int{x-scale}
      \l_inv_scale\a_count{\int{y-scale}}
      \b_count=\int{slant-scale}
      \l_inv_scale\b_count{\int{y-scale}}
      \edef\a_macro{\a_macro
         \string\transformfont{\the\a_count}{\the\b_count}
      }
   \fi
   \open_out{\temp_prefix#2.mtx}
   \edef\raw_font_name{#2}
   \out_line{\percent_char~Filename:~#2.mtx}
   \out_line{\percent_char~Created~by:~tex~\jobname}
   \out_line{\percent_char~Created~using:~\string\mtxtomtx{#1}{#2}}
   \out_line{}
   \out_line{\percent_char~This~file~is~used~by~the~fontinst~package.}
   \out_line{}
   \out_line{\percent_char~THIS~FILE~CAN~BE~DELETED.}
   \out_line{}
   \out_line{\string\relax}
   \out_line{\string\metrics}
   \out_line{}
   \out_line{\string\needsfontinstversion{\fontinstversion}}
   \out_line{}
   \ifisstr{etx-name}\then
      \def\do_slot{\x_cs\edef{slots-\slot_name}{\the\slot_number}}
      \def\declarepsencoding##1##2##3{
         \a_toks={{##1}{##2}{##3}}
         \out_line{\string\providepsencoding\the\a_toks}
         \ifnum \transform_record_file=\closed_stream \else
            \pout_line\transform_record_file
              {\string\providepsencoding\the\a_toks}
         \fi
      }
      \directfalse
      \inputetx{\str{etx-name}}
      \edef\a_macro{\a_macro\string\reencodefont{\str{etx-name}}}
   \fi
   \record_transform{#2}{\string\frommtx{#1}}{\a_macro}\iftrue
   \out_line{}
   \mtxtomtx_redefinitions
   \inputmtx{#1}
   \out_line{}
   \out_line{\endmetrics_text}
   \close_out{Transformed~metrics}
}}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\mtxtomtx_redefinitions}
%   This macro serves as a hook. One can make additional commands 
%   transformable by appending suitable redefenitions of them to this 
%   macro.
%   \changes{1.927}{2003/12/08}{Macro added. The code used to be in 
%     \cs{mtxtomtx}. (LH)}
%    \begin{macrocode}
\def\mtxtomtx_redefinitions{
   \let\setint=\mtxtomtx_setint
   \let\setdim=\mtxtomtx_setdim
   \let\setstr=\mtxtomtx_setstr
   \let\setscaledrawglyph=\mtxtomtx_setscaledrawglyph
   \let\setscalednotglyph=\mtxtomtx_setscaledrawglyph
   \let\setkern=\mtxtomtx_setkern
   \let\setglyph=\mtxtomtx_setglyph
   \let\glyphpcc=\mtxtomtx_glyphpcc
   \let\samesize=\mtxtomtx_samesize
   \let\endsetglyph=\mtxtomtx_endsetglyph
   \def\aliased{\string\aliased}
}
%</pkg>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\aliased}
%   \changes{1.915}{2000/09/09}{Macro added. (LH)}
%   The |\aliased| macro has the syntax
%   \begin{quote}
%     |\aliased|\marg{font's name}\marg{alias name}
%   \end{quote}
%   This normally expands to \meta{alias name}, but in |\mtxtomtx| it 
%   normally expands to
%   \begin{quote}
%     |\string\aliased|\marg{font's name}\marg{alias name}
%   \end{quote}
%   and when |\mtxtomtx_setscaledrawglyph| is reencoding it uses 
%   \meta{font's name} to determine the new slot position.
%    \begin{macrocode}
%<pkg|misc>\let\aliased=\second_of_two
%<doc>\let\aliased=\@secondoftwo
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\mtxtomtx_setint}
%   \changes{1.917}{2001/03/24}{Redefined to allow an extensible list 
%      \cs{width_ints_list} of integers that should be transformed as 
%      widths. (LH)}
% \begin{macro}{\italicslant_name}
% \begin{macro}{\width_ints_list}
%   \changes{1.917}{2001/03/24}{Macro added. \cs{verticalstem_name} 
%      removed. (LH)}
%   Most integers are transformed as if they are the $y$-coordinates of 
%   some points, but |italicslant| and the integers in the 
%   |\width_ints_list| are treated differently. |italicslant| is 
%   interpreted as the quotient $\frac{x}{y}$ for a point $(x,y)$, but 
%   represented as a real number (i.e., the \TeX\ number is really a 
%   thousand times the actual quotient). The integers in the 
%   |\width_ints_list| are transformed as if they are the 
%   $x$-coordinates of some points on the baseline.
%   
%   The |\width_ints_list| macro is an ordinary |\do|-type list where 
%   each |\do| has precisely one argument. These arguments are the names 
%   of the integers which should be transformed as widths. Elements can 
%   be added to the list using the |\add_to| macro.
%   
%   The test for whether a specific integer is in the |\width_ints_list| 
%   exploits that |\if_true| and |\if_false| only matter in |\if|--|\fi| 
%   matching after they have been expanded, whereas 
%   |\gobble_one|\,|\iftrue| only matters before it is expanded.
%    \begin{macrocode}
%<*pkg>
\def\mtxtomtx_setint#1#2{
   \def\a_macro{#1}
   \ifx \a_macro\italicslant_name
      \eval_expr{#2}
      \global\multiply \result \int{x-scale}
      \a_count=\int{slant-scale}
      \multiply \a_count \one_thousand
      \advance \a_count \result
      \divide \a_count \int{y-scale}\x_relax
   \else
      \def\do##1{
         \def\b_macro{##1}
         \ifx \a_macro\b_macro \expandafter\if_false \fi
      }
      \gobble_one\iftrue \width_ints_list \if_true
         \eval_expr_to\a_count{\scale{#2}{\int{y-scale}}}
      \else
         \eval_expr_to\a_count{\scale{#2}{\int{x-scale}}}
      \fi
   \fi
   \out_line{\string\setint{#1}{\the\a_count}}
}
\def\italicslant_name{italicslant}
\def\width_ints_list{
   \do{interword}\do{stretchword}\do{shrinkword}\do{quad}
   \do{extraspace}\do{digitwidth}\do{verticalstem}
}
%    \end{macrocode}
% \end{macro}\end{macro}\end{macro}
% 
% \begin{macro}{\mtxtomtx_setdim}
% \begin{macro}{\mtxtomtx_setstr}
%   Strings and dimens are not affected by the |\mtxtomtx| transforms.
%    \begin{macrocode}
\def\mtxtomtx_setdim#1#2{
   \out_line{\string\setdim{#1}{#2}}
}
%    \end{macrocode}
%    \begin{macrocode}
\def\mtxtomtx_setstr#1#2{
   \out_line{\string\setstr{#1}{#2}}
}
%    \end{macrocode}
% \end{macro} \end{macro}
% 
% \begin{macro}{\mtxtomtx_setscaledrawglyph}
%   \changes{1.915}{2000/09/09}{Added local redefinition of 
%      \cs{aliased}. (LH)}
%   |#6| (the width) is transformed as the $x$-coordinate of a point on 
%   the baseline. |#7| and |#8| (the height and depth respectively) are 
%   transformed as $y$-coordinates. The depth should probably really have 
%   been transformed as the negative of a $y$-coordinate, but it comes 
%   out the same in the end anyway. |#9| (the italic correction) is 
%   transformed as the $x$-coordinate of a point whose $y$-coordinate 
%   equals the height of the character. |#4| (the scaling) is 
%   transformed as a $y$-coordinate.
%   
%   If the italic slant of the font is negative then the italic 
%   correction should possibly be transformed as the $x$-coordinate of 
%   a point whose $y$-coordinate equals the negative of the depth 
%   instead (as that is the part of the box that is sticking out to the 
%   right), but it is hard to say for sure how that case should be 
%   treated.
%   
%    \begin{macrocode}
\def\mtxtomtx_setscaledrawglyph#1#2#3#4#5#6#7#8#9{
   \eval_expr_to\a_count{\scale{#6}{\int{x-scale}}}
   \eval_expr_to\b_count{\scale{#7}{\int{y-scale}}}
   \eval_expr_to\c_count{\scale{#8}{\int{y-scale}}}
   \eval_expr_to\d_count{#9} \eval_expr{#7}
   \multiply \d_count \int{x-scale}
   \global\multiply \result \int{slant-scale}
   \global\advance \result \d_count
   \rounded_thousandths
   \d_count=\result
   \eval_expr{\scale{#4}{\int{y-scale}}}
   \ifisstr{etx-name}\then
      \bgroup
      \let\aliased=\first_of_two
      \if_undefined{slots-#1}\then
         \egroup \e_count=\m@ne
      \else
         \expandafter\egroup \expandafter\e_count 
            \csname slots-#1\endcsname
      \fi
   \else
      \e_count=#5
   \fi
   \out_line{
      \ifnum \e_count>\m@ne
         \string\setscaledrawglyph
      \else
         \string\setscalednotglyph
      \fi
         {#1}{\raw_font_name}{#3}{\the\result}{\the\e_count}
         {\the\a_count}{\the\b_count}{\the\c_count}{\the\d_count}
   }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\mtxtomtx_setkern}
%   Kerns are transformed as the $x$-coordinate of a point on the 
%   baseline.
%   
%    \begin{macrocode}
\def\mtxtomtx_setkern#1#2#3{
   \eval_expr{\scale{\int{x-scale}}{#3}}
   \out_line{\string\setkern{#1}{#2}{\the\result}}
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\mtxtomtx_setglyph}
% \begin{macro}{\mtxtomtx_samesize}
% \begin{macro}{\mtxtomtx_endsetglyph}
%    \begin{macrocode}
\def\mtxtomtx_setglyph#1{\out_line{\string\setglyph{#1}}}
\def\mtxtomtx_samesize#1{\out_lline{\string\samesize{#1}}}
\def\mtxtomtx_endsetglyph{\out_line{\string\endsetglyph}}
%    \end{macrocode}
% \end{macro} \end{macro} \end{macro}
%
% \begin{macro}{\mtxtomtx_glyphpcc}
%   |#2| is transformed as the $x$-coordinate and |#3| is transformed 
%   as the $y$-coordinate of a point---the same point for both 
%   parameters.
%   
%    \begin{macrocode}
\def\mtxtomtx_glyphpcc#1#2#3{
   \eval_expr_to\b_count{\scale{\int{y-scale}}{#3}}
   \eval_expr_to\a_count{#2} \eval_expr{#3}
   \multiply \a_count \int{x-scale}
   \global\multiply \result \int{slant-scale}
   \global\advance \result \a_count
   \rounded_thousandths
   \out_lline{\string\glyphpcc{#1}{\the\result}{\the\b_count}}
}
%    \end{macrocode}
% \end{macro}
% 
% 
% \subsection{Changing glyph names}
% \label{Ssec:Reglyph}
% 
% \package{fontinst} uses names to identify glyphs, and if for example 
% the font in question is a postscript font, then names will also be used 
% to identify glyphs in the printer. Between those two points however, 
% and in particular inside \TeX\ itself, glyphs are represented with 
% numbers (slots). Therefore there is no real need for the glyph names 
% used within \package{fontinst} and the glyph names used in the printer 
% (the names gotten from the AFM file) to be equal, but they usually are. 
% There are some cases though where the glyph names of a font are 
% unsuitable for use with \package{fontinst}---mainly because 
% \package{fontinst} can mix glyphs from different printer fonts---and 
% therefore \package{fontinst} also offers the ability to automatically 
% change the names of glyphs in transformable metric files.
% 
% \begin{macro}{\reglyphfonts}
%   \changes{1.912}{2000/01/15}{Added local resetting of 
%      \cs{setsomething_global} to \cs{relax}. It shouldn't be needed, 
%      since \cs{reglyphfonts} should not occur between \cs{installfonts} 
%      and \cs{endinstallfonts}, but I bet someone will try. (LH)}
% \begin{macro}{\endreglyphfonts}
%   \begin{quote}
%     |\reglyphfonts| \meta{reglyphing commands} |\endreglyphfonts|
%   \end{quote}
%    \begin{macrocode}
\def\reglyphfonts{
   \begingroup
   \let\setsomething_global=\x_relax
   \x_setint{renameweight}{1}
   \x_setint{killweight}{-10}
   \setcommand\iftokeep##1\then{\ifnum -1<##1}
}
\def\endreglyphfonts{\endgroup}
%    \end{macrocode}
% \end{macro} \end{macro}
% 
% 
% The \meta{reglyphing commands} are
% \begin{quote}
%   |\renameglyph|\marg{to}\marg{from}\\
%   |\renameglyphweighted|\marg{to}\marg{from}\marg{weight}\\
%   |\killglyph|\marg{glyph}\\
%   |\killglyphweighted|\marg{glyph}\marg{weight}\\
%   |\offmtxcommand|\marg{command}\\
%   |\onmtxcommand|\marg{command}\\
%   |\reglyphfont|\marg{destination font}\marg{source font}
% \end{quote}
% The only reglyphing command that actually convert the names of any 
% glyphs is \DescribeMacro{\reglyphfont}|\reglyph|\-|font|; it reads a font 
% \meta{source font} (which may be of type MTX, PL, AFM, or VPL) and 
% writes another font \meta{destination font} in which the names of 
% glyphs have been converted. All the other commands control \emph{how} 
% this conversion should be made, and these settings get cleared at the 
% closing |\endreglyphfonts|.
% 
% The conversion works in two ways. First of all, the names of the 
% glyphs can be changed. This works as a general mapping and is 
% controlled by the \DescribeMacro{\renameglyph}|\renameglyph| and 
% \DescribeMacro{\renameglyphweighted}|\renameglyphweighted| 
% commands. Any mensioning of the glyph \meta{from} in a command will be 
% converted to a mensioning of the glyph \meta{to}, if that command 
% survives the conversion. The other way the conversion works is that it 
% can selectively kill---refrain from including in \meta{destination 
% font}---commands in the metric file. This part weighs in several 
% factors.
% 
% For one thing, one can specify that all metric commands of a certain 
% type should be killed, and this is done with the 
% \DescribeMacro{\offmtxcommand}|\offmtxcommand| command. For example, 
% one can see to that all kerning commands are killed by
% \begin{quote}
%   |\offmtxcommand{\setkern}|
% \end{quote}
% The effect is the same as that of saying
% \begin{quote}
%   |offkern,|\meta{destination font}|,onkern|
% \end{quote}
% rather than just \meta{destination font} in the second argument to 
% |\installfont|, but it is somewhat faster since less text is written 
% to and subsequently read from the \meta{destination font}|.mtx| file. 
% The effect of a previous |\offmtxcommand| can be canceled by a call to 
% \DescribeMacro{\onmtxcommand}|\onmtxcommand|, just like with 
% |\offcommand| and |\oncommand|.
% 
% The survivance of a command is also affected by the glyphs it refers to. 
% Each glyph has a \emph{weight} associated with it and the sum of the 
% weights for all glyphs mensioned by a command is also used to decide 
% whether that command should survive. The test here is performed by the 
% macro \DescribeMacro{\iftokeep}|\iftokeep|, whose parameter text 
% must be |#1\then|, where |#1| will be a |\count| register. This 
% macro must eventually expand to an if of some sort and that if 
% evaluating to true is interpreted as that the command should be kept. 
% The default replacement text is |\ifnum -1<#1|, which causes a command 
% to be killed (not kept) iff the sum of weights for it is negative.
% 
% The weight of a glyph is set by |\rename|\-|glyph|, 
% |\rename|\-|glyph|\-|weighted|, 
% \DescribeMacro{\killglyph}|\kill|\-|glyph|, and 
% \DescribeMacro{\killglyphweighted}|\kill|\-|glyph|\-|weighted|. The 
% |\rename|\textellipsis\ commands also set a new name for the glyph if 
% it survives, whereas the |\kill|\textellipsis\ commands will keep the 
% old name. Since the standard settings are that a 
% |\rename|\textellipsis\ weight is small and positive and a 
% |\kill|\textellipsis\ weight is large and negative, glyphs for which 
% a |\kill|\textellipsis\ has been done will usually not survive.
% 
% Any one of |\rename|\-|glyph|, |\rename|\-|glyph|\-|weighted|, 
% |\kill|\-|glyph|, and |\kill|\-|glyph|\-|weighted| for a glyph will 
% override all previous settings 
% by any of these four commands for that glyph. The equivalent of the 
% neutral state for a glyph (no settings by any of these commands have 
% been made for that glyph) is achieved by the command
% \begin{quote}
%   |\killglyphweighted|\marg{glyph}|{0}|
% \end{quote}
% 
% 
% \begin{macro}{\offmtxcommand}
% \begin{macro}{\onmtxcommand}
%   These two are just special forms of |\offcommand| and |\oncommand|.
%    \begin{macrocode}
\def\offmtxcommand#1{
   \x_cs\offcommand{reglyph_\expandafter\gobble_one\string#1}
}
\def\onmtxcommand#1{
   \x_cs\oncommand{reglyph_\expandafter\gobble_one\string#1}
}
%    \end{macrocode}
% \end{macro} \end{macro}
% 
% 
% \describecsfamily{slots-\meta{glyph}}Inside a |\reglyphfonts| 
% \textellipsis\ |\endreglyphfonts| block, the family 
% |\slots-|\meta{glyph} of control sequences is used to store the 
% information about how glyph \meta{glyph} should be converted. These 
% control sequences are either undefined or parameterless macros 
% whose replacement texts are of one of the forms
% \begin{quote}
%   |\rename_glyph|\marg{to}\marg{weight}\\ 
%   |\rename_glyph|\marg{to}|\i-renameweight|\\ 
%   |\kill_glyph|\marg{weight}\\ 
%   |\kill_glyph\i-killweight|
% \end{quote}
% \meta{to} is what the glyph will be renamed to and \meta{weight} is 
% the associated weight. These four different forms are generated by 
% the four different commands |\renameglyphweighted|, |\renameglyph|, 
% |\killglyphweighted|, and |\killglyph| respectively.
% 
% \begin{macro}{\renameglyph}
% \begin{macro}{\renameglyphweighted}
%   The difference between the commands |\renameglyphweighted| and 
%   |\renameglyph| is that the former lets one specify the weight exactly 
%   while the latter will use the value of the integer |renameweight| 
%   \emph{at the time of conversion}. By changing the value of 
%   |renameweight| between two conversions, one changes the weights 
%   used for all glyph renamings declared using |\renameglyph|.
%    \begin{macrocode}
\begingroup
   \catcode`\-=11
   \gdef\renameglyph#1#2{
      \x_cs\edef{slots-#2}{
         \noexpand\rename_glyph{#1}\noexpand\i-renameweight
      }
   }
\endgroup
%    \end{macrocode}
%    \begin{macrocode}
\def\renameglyphweighted#1#2#3{
   \eval_expr{#3}
   \x_cs\edef{slots-#2}{\noexpand\rename_glyph{#1}{\the\result}}
}
%    \end{macrocode}
% \end{macro} \end{macro}
% 
% \begin{macro}{\killglyph}
% \begin{macro}{\killglyphweighted}
%   The difference between the commands |\killglyphweighted| and 
%   |\killglyph| is that the former lets one specify the weight exactly 
%   while the latter will use the value of the integer |killweight| 
%   \emph{at the time of conversion}. By changing the value of 
%   |killweight| between two conversions, one changes the weights 
%   used for all glyph killings declared using |\killglyph|.
%    \begin{macrocode}
\begingroup
   \catcode`\-=11
   \gdef\killglyph#1{
      \x_cs\def{slots-#1}{\kill_glyph\i-killweight}
   }
\endgroup
%    \end{macrocode}
%    \begin{macrocode}
\def\killglyphweighted#1#2{
   \eval_expr{#2}
   \x_cs\edef{slots-#1}{\noexpand\kill_glyph{\the\result}}
}
%    \end{macrocode}
% \end{macro} \end{macro}
% 
% 
% \begin{macro}{\reglyphfont}
%   The command
%   \begin{quote}
%     |\reglyphfont|\marg{destination font}\marg{source font}
%   \end{quote}
%   reads the font metric file \meta{source font}|.mtx| (which must be 
%   transformable), \meta{source font}|.pl|, or \meta{source font}|.afm| 
%   (the possibilities are tried in that order) and writes out a font 
%   metric file \meta{destination font}|.mtx| that is the converted (as 
%   described above) form of the source font.
%   
%   \meta{destination font} and \meta{source font} may not be equal.
%   \changes{1.903}{1999/06/01}{Using \cs{fromany} for locating font. 
%      (LH)}
%   \changes{1.904}{1999/06/16}{Added \cs{record_transform}. (LH)}
%    \begin{macrocode}
\def\reglyphfont#1#2{
   \fromany{#2}
   \ifisstr{afm-name}\then
      \reglyph_font{#1}{#2}
   \else
      \fontinsterror{Reglyph}{Could~not~find~font~metrics~for~#2.}
         \error_help_a
   \fi
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\reglyph_font}
%   This macro does the actual conversion.
%    \begin{macrocode}
\def\reglyph_font#1#2{{
   \open_out{\temp_prefix#1.mtx}
   \out_line{\percent_char~Filename:~#1.mtx}
   \out_line{\percent_char~Created~by:~tex~\jobname}
   \out_line{\percent_char~Created~using:~\string\reglyphfont{#1}{#2}}
   \out_line{}
   \out_line{\percent_char~This~file~is~used~by~the~fontinst~package.}
   \out_line{}
   \out_line{\percent_char~THIS~FILE~CAN~BE~DELETED.}
   \out_line{}
   \out_line{\string\relax}
   \out_line{\string\metrics}
   \out_line{}
   \out_line{\string\needsfontinstversion{\fontinstversion}}
   \out_line{}
   \record_transform{#1}{\string\frommtx{#2}}{\string\reglyphfont}
      \iftrue
   \out_line{}
   \reglyph_redefinitions
   \inputmtx{#2}
   \out_line{}
   \out_line{\endmetrics_text}
   \close_out{Reglyphed~metrics}
}}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\reglyph_redefinitions}
%   This macro serves as a hook. One can make additional commands 
%   transformable by appending suitable redefenitions of them to this 
%   macro.
%   \changes{1.927}{2003/12/08}{Macro added. The code used to be in 
%     \cs{reglyph_font}. (LH)}
%    \begin{macrocode}
\def\reglyph_redefinitions{
   \let\setint=\reglyph_setint
   \let\setdim=\reglyph_setdim
   \let\setstr=\reglyph_setstr
   \let\setscaledrawglyph=\reglyph_setscaledrawglyph
   \let\setscalednotglyph=\reglyph_setscaledrawglyph
   \let\setkern=\reglyph_setkern
   \let\setglyph=\reglyph_setglyph
   \let\glyphpcc=\reglyph_glyphpcc
   \let\samesize=\reglyph_samesize
   \let\endsetglyph=\reglyph_endsetglyph
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\reglyph_setint}
% \begin{macro}{\reglyph_setdim}
% \begin{macro}{\reglyph_setstr}
%   These are just copied to the file generated.
%    \begin{macrocode}
\def\reglyph_setint#1#2{\out_line{\string\setint{#1}{#2}}}
\def\reglyph_setdim#1#2{\out_line{\string\setdim{#1}{#2}}}
\def\reglyph_setstr#1#2{\out_line{\string\setstr{#1}{#2}}}
%    \end{macrocode}
% \end{macro} \end{macro} \end{macro}
% 
% \begin{macro}{\command_survivance}
%   This |\count| register stores the sum of the weights associated 
%   with the glyphs considered so far. It is updated by |\rename_glyph| 
%   and |\kill_glyph|.
%    \begin{macrocode}
\newcount\command_survivance
%    \end{macrocode}
% \end{macro}
% 
% The macro \DescribeMacro{\glyphname}|\glyphname| holds the name of 
% the glyph currently under consideration. It is altered by 
% |\rename_glyph|.
% 
% \begin{macro}{\rename_glyph}
% \begin{macro}{\kill_glyph}
%    \begin{macrocode}
\def\rename_glyph#1{\def\glyphname{#1}\kill_glyph}
\def\kill_glyph#1{\advance \command_survivance #1\x_relax}
%    \end{macrocode}
% \end{macro} \end{macro}
% 
% 
% \begin{macro}{\reglyph_setscaledrawglyph}
%   \changes{1.915}{2000/06/25}{Corrected bug in the \cs{ifnum}: it 
%      should test argument \#5, not \#4. (LH) Encountered by Thierry 
%      Bouche.}
%   The |\reglyph_|\-|setscaled|\-|rawglyph| macro is straightforward. 
%   Whether it writes a |\setscaled|\-|rawglyph| or a |\setscaled|\-^^A
%   |notglyph| command depends on the fifth parameter, just like with 
%   |\mtxtomtx_|\-|setscaled|\-|rawglyph|.
%    \begin{macrocode}
\def\reglyph_setscaledrawglyph#1#2#3#4#5#6#7#8#9{
   \command_survivance=0
   \def\glyphname{#1}
   \csname slots-#1\endcsname
   \iftokeep\command_survivance\then
      \out_line{
         \ifnum #5<\z@
            \string\setscalednotglyph
         \else
            \string\setscaledrawglyph
         \fi
         {\glyphname}{#2}{#3}{\number#4}{#5}{#6}{#7}{#8}{#9}
      }
   \fi
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\reglyph_setkern}
%    \begin{macrocode}
\def\reglyph_setkern#1#2#3{
   \command_survivance=0
   \def\glyphname{#1}
   \csname slots-#1\endcsname
   \let\a_macro=\glyphname
   \def\glyphname{#2}
   \csname slots-#2\endcsname
   \iftokeep\command_survivance\then
      \out_line{\string\setkern{\a_macro}{\glyphname}{#3}}
   \fi
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\reglyph_setglyph}
%   \multchanges{\cs{reglyph_glyphpcc}\cs{reglyph_samesize}^^A
%       \cs{reglyph_setglyph}}{1.911}{1999/12/10}{\cs{string}
%       which should be \cs{noexpand} corrected. (LH) Reported by 
%       Rolf Lindgren.}
% \begin{macro}{\off-\reglyph_setglyph}
% \begin{macro}{\reglyph_glyphpcc}
%   \changes{1.911}{1999/12/10}{Typo corrected. (LH) Spotted by Rolf 
%      Lindgren.}
% \begin{macro}{\reglyph_samesize}
% \begin{macro}{\reglyph_endsetglyph}
%   In |\setglyph| \textellipsis\ |\endsetglyph| constructions (which 
%   are written for composite characters in AFM files), the decision of 
%   whether to write a command or not due to glyph weights is done 
%   only once for the entire construction. This means that the commands 
%   must be saved until the |\endsetglyph| where the result is finally 
%   known. The token list register |\a_toks| is used for this purpose.
%    \begin{macrocode}
\def\reglyph_setglyph#1{
   \command_survivance=0
   \def\glyphname{#1}
   \csname slots-#1\endcsname
   \edef\a_macro{\noexpand\out_line{\string\setglyph{\glyphname}}}
   \a_toks=\expandafter{\a_macro}
}
\x_cs\def{off-\string\reglyph_setglyph}#1{\gobble_glyph}
%    \end{macrocode}
%    \begin{macrocode}
\def\reglyph_glyphpcc#1#2#3{
   \def\glyphname{#1}
   \csname slots-#1\endcsname
   \edef\a_macro{\noexpand\out_lline{ 
      \string\glyphpcc{\glyphname}{#2}{#3}
   }}
   \a_toks=\expandafter{\the\expandafter\a_toks \a_macro}
}
%    \end{macrocode}
%    \begin{macrocode}
\def\reglyph_samesize#1{
   \def\glyphname{#1}
   \csname slots-#1\endcsname
   \edef\a_macro{\noexpand\out_lline{ 
      \string\samesize{\glyphname}
   }}
   \a_toks=\expandafter{\the\expandafter\a_toks \a_macro}
}
%    \end{macrocode}
%    \begin{macrocode}
\def\reglyph_endsetglyph{
   \iftokeep\command_survivance\then
      \the\a_toks
      \out_line{\string\endsetglyph}
   \fi
   \a_toks={}
}
%</pkg>
%    \end{macrocode}
% \end{macro} \end{macro} \end{macro} \end{macro} \end{macro}
% 
% 
% \subsubsection*{Three common reglyphing schemes}
% 
% As is mensioned elsewhere, the most common reglyphing operation is to 
% take a caps and small caps font produced by some major foundry and 
% change the glyph names so that they agree with the glyph names used in 
% expert fonts. The following code contains the modifying reglyphing 
% commands to set up this reglyphing, in two different variants.
% 
% The commands are currently based on a comparision of Adobe Garamond 
% Small Caps \& Oldstyle Figures (\texttt{padrc8a} in the Berry 
% scheme) with Adobe Garamond Regular Expert (\texttt{padr8x} in the 
% Berry scheme), so they should be correct for a fair amount of Adobe 
% font families, but it is also highly probable that there are lots of 
% fonts out there for which it doesn't work quite right. In case you do 
% find such a font, please write to tell the \package{fontinst} mailing 
% list about it---it would be rather easy to add various alternative 
% set-up schemes, controlled by switches, to these files. Just make sure 
% first (by checking the newest version of \package{fontinst}) that the 
% alternative setting you have found hasn't already been included.
% 
% As mentioned, there are two different reglyphing schemes that are set 
% up by the code below---one has \package{docstrip} guard \Module{glyphs}, 
% the other has guard \Module{!glyphs}---but they both change SC names 
% to Expert names. The difference lies instead in what information is 
% copied from source font to destination font: the \Module{glyphs} 
% variant copies everything, whereas the \Module{!glyphs} variant 
% doesn't copy |\setrawglyph| commands, |\setnotglyph| commands, 
% |\setscaledrawglyph| commands, |\setscalednotglyph| commands or 
% |\setglyph| constructions. The \Module{!glyphs} variant also 
% suppresses kerns between two glyphs that doesn't change name.
% 
% The motive for having such a curious set-up naturally lies in how the 
% files are meant to be used. If you have SC fonts, but no Expert 
% fonts, then you should definitely use the \Module{glyphs} variant. If 
% on the other hand you have both SC and Expert fonts for a family, 
% then it is worth considering using the \Module{!glyphs} variant instead. 
% The observation this is based on is that within a triad of the 
% corresponding regular, expert, and SC fonts, almost all glyphs present 
% in the SC font can also be found in either the regular or the expert 
% font; furthermore the only missing glyphs were \texttt{FIsmall}, 
% \texttt{FLsmall}, and \texttt{SSsmall}, which (i) were included in the 
% SC font only to complete the \texttt{8a} encoding vector and (ii) are 
% identical to \package{fontinst}'s fakes for them. 
% 
% Thus by constructing the \texttt{sc} shape fonts from the regular and 
% expert variants, instead of the SC variant, one can get away with 
% using one raw font less, thus reducing the time needed for downloading 
% the fonts to the printer and the size of the corresponding postscript 
% file. One thing not found in either of the regular or expert font in 
% the triad is however the kerns between capitals and small capitals, but 
% these can be extracted from the metrics of the SC font, and doing this 
% is the primary objective for the \Module{!glyphs} variant.
% 
% \bigskip
% \changes{1.906}{1999/08/01}{Reglyphing settings files added. (LH)}
% 
% First there is the English alphabet:
%    \begin{macrocode}
%<*reglyphletters>
\renameglyph{Asmall}{a}
\renameglyph{Bsmall}{b}
\renameglyph{Csmall}{c}
\renameglyph{Dsmall}{d}
\renameglyph{Esmall}{e}
\renameglyph{Fsmall}{f}
\renameglyph{Gsmall}{g}
\renameglyph{Hsmall}{h}
\renameglyph{Ismall}{i}
\renameglyph{Jsmall}{j}
\renameglyph{Ksmall}{k}
\renameglyph{Lsmall}{l}
\renameglyph{Msmall}{m}
\renameglyph{Nsmall}{n}
\renameglyph{Osmall}{o}
\renameglyph{Psmall}{p}
\renameglyph{Qsmall}{q}
\renameglyph{Rsmall}{r}
\renameglyph{Ssmall}{s}
\renameglyph{Tsmall}{t}
\renameglyph{Usmall}{u}
\renameglyph{Vsmall}{v}
\renameglyph{Wsmall}{w}
\renameglyph{Xsmall}{x}
\renameglyph{Ysmall}{y}
\renameglyph{Zsmall}{z}
%</reglyphletters>
%    \end{macrocode}
% 
% Then there are the figures:
% \multchanges{\notcs{Reglyphing}}{1.911}{1999/12/10}
%    {\texttt{eightoldstyle} typo corrected. (LH) Spotted by 
%    Rolf Lindgren.}
% \multchanges{\notcs{Reglyphing}}{1.927}{2004/07/12}
%    {Placed commands for letters and figures in separate modules, 
%     so that they can be separated in generation. (LH)}
%    \begin{macrocode}
%<*reglyphfigures>
\renameglyph{zerooldstyle}{zero}
\renameglyph{oneoldstyle}{one}
\renameglyph{twooldstyle}{two}
\renameglyph{threeoldstyle}{three}
\renameglyph{fouroldstyle}{four}
\renameglyph{fiveoldstyle}{five}
\renameglyph{sixoldstyle}{six}
\renameglyph{sevenoldstyle}{seven}
\renameglyph{eightoldstyle}{eight}
\renameglyph{nineoldstyle}{nine}
%</reglyphfigures>
%    \end{macrocode}
% 
% Then there are the accents and a couple of miscellaneous symbols. You 
% might want to check these carefully, as there might not always be a 
% distinction.
% \changes{1.925}{2003/05/13}{Added \cs{renameglyph} for 
%   \texttt{Hungarumlautsmall}. Walter Schmidt noticed it was missing.
%   (LH)}
%    \begin{macrocode}
%<*reglyphletters>
\renameglyph{Acutesmall}{acute}
\renameglyph{Brevesmall}{breve}
\renameglyph{Caronsmall}{caron}
\renameglyph{Cedillasmall}{cedilla}
\renameglyph{Circumflexsmall}{circumflex}
\renameglyph{Dieresissmall}{dieresis}
\renameglyph{Dotaccentsmall}{dotaccent}
\renameglyph{Gravesmall}{grave}
\renameglyph{Hungarumlautsmall}{hungarumlaut}
\renameglyph{Macronsmall}{macron}
\renameglyph{Ogoneksmall}{ogonek}
\renameglyph{Ringsmall}{ring}
\renameglyph{Tildesmall}{tilde}
\renameglyph{ampersandsmall}{ampersand}
\renameglyph{centoldstyle}{cent}
\renameglyph{dollaroldstyle}{dollar}
%    \end{macrocode}
%   
% There are also all the non-English letters:
%    \begin{macrocode}
\renameglyph{AEsmall}{ae}
\renameglyph{Ethsmall}{eth}
\renameglyph{Lslashsmall}{lslash}
\renameglyph{Oslashsmall}{oslash}
\renameglyph{OEsmall}{oe}
\renameglyph{Thornsmall}{thorn}
%    \end{macrocode}
%    \begin{macrocode}
\renameglyph{Agravesmall}{agrave}
\renameglyph{Egravesmall}{egrave}
\renameglyph{Igravesmall}{igrave}
\renameglyph{Ogravesmall}{ograve}
\renameglyph{Ugravesmall}{ugrave}
%    \end{macrocode}
%    \begin{macrocode}
\renameglyph{Aacutesmall}{aacute}
\renameglyph{Eacutesmall}{eacute}
\renameglyph{Iacutesmall}{iacute}
\renameglyph{Oacutesmall}{oacute}
\renameglyph{Uacutesmall}{uacute}
\renameglyph{Yacutesmall}{yacute}
%    \end{macrocode}
%    \begin{macrocode}
\renameglyph{Acircumflexsmall}{acircumflex}
\renameglyph{Ecircumflexsmall}{ecircumflex}
\renameglyph{Icircumflexsmall}{icircumflex}
\renameglyph{Ocircumflexsmall}{ocircumflex}
\renameglyph{Ucircumflexsmall}{ucircumflex}
%    \end{macrocode}
%    \begin{macrocode}
\renameglyph{Atildesmall}{atilde}
\renameglyph{Ntildesmall}{ntilde}
\renameglyph{Otildesmall}{otilde}
%    \end{macrocode}
%    \begin{macrocode}
\renameglyph{Adieresissmall}{adieresis}
\renameglyph{Edieresissmall}{edieresis}
\renameglyph{Idieresissmall}{idieresis}
\renameglyph{Odieresissmall}{odieresis}
\renameglyph{Ydieresissmall}{ydieresis}
\renameglyph{Udieresissmall}{udieresis}
%    \end{macrocode}
%    \begin{macrocode}
\renameglyph{Aringsmall}{aring}
\renameglyph{Ccedillasmall}{ccedilla}
\renameglyph{Scaronsmall}{scaron}
\renameglyph{Zcaronsmall}{zcaron}
%    \end{macrocode}
%   
% The following four glyphs aren't really necessary, since they are 
% usually identical to another glyph or to their fakes.
%    \begin{macrocode}
\killglyph{dotlessi}
%<*glyphs>
\renameglyph{FIsmall}{fi}
\renameglyph{FLsmall}{fl}
\renameglyph{SSsmall}{germandbls}
%</glyphs>
%<*!glyphs>
\killglyph{fi}
\killglyph{fl}
\killglyph{germandbls}
%</!glyphs>  
%</reglyphletters>
%    \end{macrocode}
% 
% The \Module{!glyphs} settings have no need for |\setrawglyph|, 
% |\setscaledrawglyph|, or |\setglyph| commands, and no need for the 
% kerns between capitals either, since these are already known from the 
% regular variant. Note that it is pointless to say |\offmtxcommand|^^A
% \penalty0|\setrawglyph| as of v\,1.913 since |\setrawglyph| is now 
% simply syntactic sugar for the equivalent |\set|\-|scaled|\-|raw|\-^^A
% |glyph|.
%    \begin{macrocode}
%<*(reglyphletters|reglyphfigures)&!glyphs>
\offmtxcommand\setscaledrawglyph
\offmtxcommand\setglyph
\resetcommand\iftokeep#1\then{\ifnum 0<#1}
%</(reglyphletters|reglyphfigures)&!glyphs>
%    \end{macrocode}
% 
% 
% \changes{1.904}{1999/06/13}{Font transformation recordings moved to 
%    \texttt{fimapgen.dtx}, so that the interface will be specified 
%    in a single place. (LH)}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \Finale
\endinput